//
// File generated by HDevelop for HALCON/.NET (C#) Version 24.11.1.0
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
//

using HalconDotNet;

public partial class HDevelopExport
{
#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
    public HDevelopExport()
    {
        // Default settings used in HDevelop
        HOperatorSet.SetSystem("width", 512);
        HOperatorSet.SetSystem("height", 512);
        if (HalconAPI.isWindows)
            HOperatorSet.SetSystem("use_window_thread", "true");
        action();
    }
#endif

    // Procedures 
    // External procedures 
    // Chapter: Deep Learning / Object Detection and Instance Segmentation
    private void area_iou(HTuple hv_Sample, HTuple hv_Result, HTuple hv_InstanceType,
        HTuple hv_ResultSortIndices, out HTuple hv_SampleArea, out HTuple hv_ResultArea,
        out HTuple hv_IoU)
    {



        // Stack for temporary objects 
        HObject[] OTemp = new HObject[20];

        // Local iconic variables 

        HObject ho_GtMask = null, ho_ResMask = null, ho_CurrentGtMask = null;
        HObject ho_ValidResMask = null, ho_RegionIntersection = null;

        // Local control variables 

        HTuple hv_GtRow1 = new HTuple(), hv_GtCol1 = new HTuple();
        HTuple hv_GtRow2 = new HTuple(), hv_GtCol2 = new HTuple();
        HTuple hv_ResRow1 = new HTuple(), hv_ResCol1 = new HTuple();
        HTuple hv_ResRow2 = new HTuple(), hv_ResCol2 = new HTuple();
        HTuple hv_GtIdx = new HTuple(), hv_Height = new HTuple();
        HTuple hv_Width = new HTuple(), hv_ValidIdxs = new HTuple();
        HTuple hv_Intersection = new HTuple(), hv_Union = new HTuple();
        HTuple hv_GtRow = new HTuple(), hv_GtCol = new HTuple();
        HTuple hv_GtLength1 = new HTuple(), hv_GtLength2 = new HTuple();
        HTuple hv_GtPhi = new HTuple(), hv_ResRow = new HTuple();
        HTuple hv_ResCol = new HTuple(), hv_ResLength1 = new HTuple();
        HTuple hv_ResLength2 = new HTuple(), hv_ResPhi = new HTuple();
        HTuple hv__ = new HTuple(), hv_NumGt = new HTuple(), hv_NumRes = new HTuple();
        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_GtMask);
        HOperatorSet.GenEmptyObj(out ho_ResMask);
        HOperatorSet.GenEmptyObj(out ho_CurrentGtMask);
        HOperatorSet.GenEmptyObj(out ho_ValidResMask);
        HOperatorSet.GenEmptyObj(out ho_RegionIntersection);
        hv_SampleArea = new HTuple();
        hv_ResultArea = new HTuple();
        hv_IoU = new HTuple();
        try
        {
            //
            //Compute the intersection over union (IoU) between
            //the ground truth and the inferred bounding box or instance
            //segmentation mask of the object instances.
            //The instance type is determined over the InstanceType.
            //
            if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
            {
                //Get bounding box coordinates.
                hv_GtRow1.Dispose();
                HOperatorSet.GetDictTuple(hv_Sample, "bbox_row1", out hv_GtRow1);
                hv_GtCol1.Dispose();
                HOperatorSet.GetDictTuple(hv_Sample, "bbox_col1", out hv_GtCol1);
                hv_GtRow2.Dispose();
                HOperatorSet.GetDictTuple(hv_Sample, "bbox_row2", out hv_GtRow2);
                hv_GtCol2.Dispose();
                HOperatorSet.GetDictTuple(hv_Sample, "bbox_col2", out hv_GtCol2);
                hv_ResRow1.Dispose();
                HOperatorSet.GetDictTuple(hv_Result, "bbox_row1", out hv_ResRow1);
                hv_ResCol1.Dispose();
                HOperatorSet.GetDictTuple(hv_Result, "bbox_col1", out hv_ResCol1);
                hv_ResRow2.Dispose();
                HOperatorSet.GetDictTuple(hv_Result, "bbox_row2", out hv_ResRow2);
                hv_ResCol2.Dispose();
                HOperatorSet.GetDictTuple(hv_Result, "bbox_col2", out hv_ResCol2);
                //
                //Sort the results.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ResRow1 = hv_ResRow1.TupleSelect(
                            hv_ResultSortIndices);
                        hv_ResRow1.Dispose();
                        hv_ResRow1 = ExpTmpLocalVar_ResRow1;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ResCol1 = hv_ResCol1.TupleSelect(
                            hv_ResultSortIndices);
                        hv_ResCol1.Dispose();
                        hv_ResCol1 = ExpTmpLocalVar_ResCol1;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ResRow2 = hv_ResRow2.TupleSelect(
                            hv_ResultSortIndices);
                        hv_ResRow2.Dispose();
                        hv_ResRow2 = ExpTmpLocalVar_ResRow2;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ResCol2 = hv_ResCol2.TupleSelect(
                            hv_ResultSortIndices);
                        hv_ResCol2.Dispose();
                        hv_ResCol2 = ExpTmpLocalVar_ResCol2;
                    }
                }
                //
                //Compute areas.
                hv_SampleArea.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SampleArea = (hv_GtRow2 - hv_GtRow1) * (hv_GtCol2 - hv_GtCol1);
                }
                hv_ResultArea.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ResultArea = (hv_ResRow2 - hv_ResRow1) * (hv_ResCol2 - hv_ResCol1);
                }
                //
                //Compute IoUs.
                hv_IoU.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_IoU = HTuple.TupleGenConst(
                        (new HTuple(hv_GtRow1.TupleLength())) * (new HTuple(hv_ResRow1.TupleLength()
                        )), 0);
                }
                if ((int)(new HTuple((new HTuple(hv_IoU.TupleLength())).TupleGreater(0))) != 0)
                {
                    for (hv_GtIdx = 0; (int)hv_GtIdx <= (int)((new HTuple(hv_GtRow1.TupleLength()
                        )) - 1); hv_GtIdx = (int)hv_GtIdx + 1)
                    {
                        hv_Height.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Height = (((hv_GtRow2.TupleSelect(
                                hv_GtIdx))).TupleMin2(hv_ResRow2)) - (((hv_GtRow1.TupleSelect(hv_GtIdx))).TupleMax2(
                                hv_ResRow1));
                        }
                        hv_Width.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Width = (((hv_GtCol2.TupleSelect(
                                hv_GtIdx))).TupleMin2(hv_ResCol2)) - (((hv_GtCol1.TupleSelect(hv_GtIdx))).TupleMax2(
                                hv_ResCol1));
                        }
                        hv_ValidIdxs.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ValidIdxs = (new HTuple(((hv_Height.TupleGreaterElem(
                                0))).TupleAnd(hv_Width.TupleGreaterElem(0)))).TupleFind(1);
                        }
                        if ((int)(new HTuple(hv_ValidIdxs.TupleGreater(-1))) != 0)
                        {
                            hv_Intersection.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Intersection = (hv_Height.TupleSelect(
                                    hv_ValidIdxs)) * (hv_Width.TupleSelect(hv_ValidIdxs));
                            }
                            hv_Union.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Union = ((hv_SampleArea.TupleSelect(
                                    hv_GtIdx)) + (hv_ResultArea.TupleSelect(hv_ValidIdxs))) - hv_Intersection;
                            }
                            if (hv_IoU == null)
                                hv_IoU = new HTuple();
                            hv_IoU[(hv_GtIdx * (new HTuple(hv_ResRow1.TupleLength()))) + hv_ValidIdxs] = (hv_Intersection.TupleReal()
                                ) / hv_Union;
                        }
                    }
                }
            }
            else if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
            {
                //Get bounding box coordinates.
                hv_GtRow.Dispose();
                HOperatorSet.GetDictTuple(hv_Sample, "bbox_row", out hv_GtRow);
                hv_GtCol.Dispose();
                HOperatorSet.GetDictTuple(hv_Sample, "bbox_col", out hv_GtCol);
                hv_GtLength1.Dispose();
                HOperatorSet.GetDictTuple(hv_Sample, "bbox_length1", out hv_GtLength1);
                hv_GtLength2.Dispose();
                HOperatorSet.GetDictTuple(hv_Sample, "bbox_length2", out hv_GtLength2);
                hv_GtPhi.Dispose();
                HOperatorSet.GetDictTuple(hv_Sample, "bbox_phi", out hv_GtPhi);
                hv_ResRow.Dispose();
                HOperatorSet.GetDictTuple(hv_Result, "bbox_row", out hv_ResRow);
                hv_ResCol.Dispose();
                HOperatorSet.GetDictTuple(hv_Result, "bbox_col", out hv_ResCol);
                hv_ResLength1.Dispose();
                HOperatorSet.GetDictTuple(hv_Result, "bbox_length1", out hv_ResLength1);
                hv_ResLength2.Dispose();
                HOperatorSet.GetDictTuple(hv_Result, "bbox_length2", out hv_ResLength2);
                hv_ResPhi.Dispose();
                HOperatorSet.GetDictTuple(hv_Result, "bbox_phi", out hv_ResPhi);
                //
                //Sort results.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ResRow = hv_ResRow.TupleSelect(
                            hv_ResultSortIndices);
                        hv_ResRow.Dispose();
                        hv_ResRow = ExpTmpLocalVar_ResRow;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ResCol = hv_ResCol.TupleSelect(
                            hv_ResultSortIndices);
                        hv_ResCol.Dispose();
                        hv_ResCol = ExpTmpLocalVar_ResCol;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ResLength1 = hv_ResLength1.TupleSelect(
                            hv_ResultSortIndices);
                        hv_ResLength1.Dispose();
                        hv_ResLength1 = ExpTmpLocalVar_ResLength1;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ResLength2 = hv_ResLength2.TupleSelect(
                            hv_ResultSortIndices);
                        hv_ResLength2.Dispose();
                        hv_ResLength2 = ExpTmpLocalVar_ResLength2;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ResPhi = hv_ResPhi.TupleSelect(
                            hv_ResultSortIndices);
                        hv_ResPhi.Dispose();
                        hv_ResPhi = ExpTmpLocalVar_ResPhi;
                    }
                }
                //
                //Compute Areas.
                hv_SampleArea.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SampleArea = (4.0 * hv_GtLength1) * hv_GtLength2;
                }
                hv_ResultArea.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ResultArea = (4.0 * hv_ResLength1) * hv_ResLength2;
                }
                //
                //Compute IoUs.
                hv_IoU.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_IoU = HTuple.TupleGenConst(
                        (new HTuple(hv_GtRow.TupleLength())) * (new HTuple(hv_ResRow.TupleLength()
                        )), 0);
                }
                if ((int)(new HTuple((new HTuple(hv_IoU.TupleLength())).TupleGreater(0))) != 0)
                {
                    for (hv_GtIdx = 0; (int)hv_GtIdx <= (int)((new HTuple(hv_GtRow.TupleLength()
                        )) - 1); hv_GtIdx = (int)hv_GtIdx + 1)
                    {
                        hv_ValidIdxs.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ValidIdxs = (new HTuple(((((hv_SampleArea.TupleSelect(
                                hv_GtIdx))).TupleGreaterElem(0))).TupleAnd(hv_ResultArea.TupleGreaterElem(
                                0)))).TupleFind(1);
                        }
                        if ((int)(new HTuple(hv_ValidIdxs.TupleGreater(-1))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Intersection.Dispose();
                                HOperatorSet.AreaIntersectionRectangle2(hv_GtRow.TupleSelect(hv_GtIdx),
                                    hv_GtCol.TupleSelect(hv_GtIdx), hv_GtPhi.TupleSelect(hv_GtIdx),
                                    hv_GtLength1.TupleSelect(hv_GtIdx), hv_GtLength2.TupleSelect(hv_GtIdx),
                                    hv_ResRow.TupleSelect(hv_ValidIdxs), hv_ResCol.TupleSelect(hv_ValidIdxs),
                                    hv_ResPhi.TupleSelect(hv_ValidIdxs), hv_ResLength1.TupleSelect(
                                    hv_ValidIdxs), hv_ResLength2.TupleSelect(hv_ValidIdxs), out hv_Intersection);
                            }
                            hv_Union.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Union = ((hv_SampleArea.TupleSelect(
                                    hv_GtIdx)) + (hv_ResultArea.TupleSelect(hv_ValidIdxs))) - hv_Intersection;
                            }
                            if (hv_IoU == null)
                                hv_IoU = new HTuple();
                            hv_IoU[(hv_GtIdx * (new HTuple(hv_ResRow.TupleLength()))) + hv_ValidIdxs] = (hv_Intersection.TupleReal()
                                ) / hv_Union;
                        }
                    }
                }
            }
            else if ((int)(new HTuple(hv_InstanceType.TupleEqual("mask"))) != 0)
            {
                //Get the ground truth mask.
                ho_GtMask.Dispose();
                HOperatorSet.GetDictObject(out ho_GtMask, hv_Sample, "mask");
                //
                //Get the result mask.
                ho_ResMask.Dispose();
                HOperatorSet.GetDictObject(out ho_ResMask, hv_Result, "mask");
                //
                //Sort the results.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.SelectObj(ho_ResMask, out ExpTmpOutVar_0, hv_ResultSortIndices + 1);
                    ho_ResMask.Dispose();
                    ho_ResMask = ExpTmpOutVar_0;
                }
                //
                //Compute Areas.
                hv_SampleArea.Dispose(); hv__.Dispose(); hv__.Dispose();
                HOperatorSet.AreaCenter(ho_GtMask, out hv_SampleArea, out hv__, out hv__);
                hv_ResultArea.Dispose(); hv__.Dispose(); hv__.Dispose();
                HOperatorSet.AreaCenter(ho_ResMask, out hv_ResultArea, out hv__, out hv__);
                //
                //Compute IoUs.
                hv_NumGt.Dispose();
                HOperatorSet.CountObj(ho_GtMask, out hv_NumGt);
                hv_NumRes.Dispose();
                HOperatorSet.CountObj(ho_ResMask, out hv_NumRes);
                hv_IoU.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_IoU = HTuple.TupleGenConst(
                        hv_NumGt * hv_NumRes, 0);
                }
                if ((int)(new HTuple((new HTuple(hv_IoU.TupleLength())).TupleGreater(0))) != 0)
                {
                    HTuple end_val96 = hv_NumGt - 1;
                    HTuple step_val96 = 1;
                    for (hv_GtIdx = 0; hv_GtIdx.Continue(end_val96, step_val96); hv_GtIdx = hv_GtIdx.TupleAdd(step_val96))
                    {
                        hv_ValidIdxs.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ValidIdxs = (new HTuple(((((hv_SampleArea.TupleSelect(
                                hv_GtIdx))).TupleGreaterElem(0))).TupleAnd(hv_ResultArea.TupleGreaterElem(
                                0)))).TupleFind(1);
                        }
                        if ((int)(new HTuple(hv_ValidIdxs.TupleGreater(-1))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_CurrentGtMask.Dispose();
                                HOperatorSet.SelectObj(ho_GtMask, out ho_CurrentGtMask, hv_GtIdx + 1);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_ValidResMask.Dispose();
                                HOperatorSet.SelectObj(ho_ResMask, out ho_ValidResMask, hv_ValidIdxs + 1);
                            }
                            ho_RegionIntersection.Dispose();
                            HOperatorSet.Intersection(ho_ValidResMask, ho_CurrentGtMask, out ho_RegionIntersection
                                );
                            hv_Intersection.Dispose(); hv__.Dispose(); hv__.Dispose();
                            HOperatorSet.AreaCenter(ho_RegionIntersection, out hv_Intersection,
                                out hv__, out hv__);
                            hv_Union.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Union = ((hv_SampleArea.TupleSelect(
                                    hv_GtIdx)) + (hv_ResultArea.TupleSelect(hv_ValidIdxs))) - hv_Intersection;
                            }
                            if (hv_IoU == null)
                                hv_IoU = new HTuple();
                            hv_IoU[(hv_GtIdx * hv_NumRes) + hv_ValidIdxs] = (hv_Intersection.TupleReal()
                                ) / hv_Union;
                        }
                    }
                }
            }
            else
            {
                throw new HalconException(("Instance type '" + hv_InstanceType) + "' is not supported");
            }
            ho_GtMask.Dispose();
            ho_ResMask.Dispose();
            ho_CurrentGtMask.Dispose();
            ho_ValidResMask.Dispose();
            ho_RegionIntersection.Dispose();

            hv_GtRow1.Dispose();
            hv_GtCol1.Dispose();
            hv_GtRow2.Dispose();
            hv_GtCol2.Dispose();
            hv_ResRow1.Dispose();
            hv_ResCol1.Dispose();
            hv_ResRow2.Dispose();
            hv_ResCol2.Dispose();
            hv_GtIdx.Dispose();
            hv_Height.Dispose();
            hv_Width.Dispose();
            hv_ValidIdxs.Dispose();
            hv_Intersection.Dispose();
            hv_Union.Dispose();
            hv_GtRow.Dispose();
            hv_GtCol.Dispose();
            hv_GtLength1.Dispose();
            hv_GtLength2.Dispose();
            hv_GtPhi.Dispose();
            hv_ResRow.Dispose();
            hv_ResCol.Dispose();
            hv_ResLength1.Dispose();
            hv_ResLength2.Dispose();
            hv_ResPhi.Dispose();
            hv__.Dispose();
            hv_NumGt.Dispose();
            hv_NumRes.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_GtMask.Dispose();
            ho_ResMask.Dispose();
            ho_CurrentGtMask.Dispose();
            ho_ValidResMask.Dispose();
            ho_RegionIntersection.Dispose();

            hv_GtRow1.Dispose();
            hv_GtCol1.Dispose();
            hv_GtRow2.Dispose();
            hv_GtCol2.Dispose();
            hv_ResRow1.Dispose();
            hv_ResCol1.Dispose();
            hv_ResRow2.Dispose();
            hv_ResCol2.Dispose();
            hv_GtIdx.Dispose();
            hv_Height.Dispose();
            hv_Width.Dispose();
            hv_ValidIdxs.Dispose();
            hv_Intersection.Dispose();
            hv_Union.Dispose();
            hv_GtRow.Dispose();
            hv_GtCol.Dispose();
            hv_GtLength1.Dispose();
            hv_GtLength2.Dispose();
            hv_GtPhi.Dispose();
            hv_ResRow.Dispose();
            hv_ResCol.Dispose();
            hv_ResLength1.Dispose();
            hv_ResLength2.Dispose();
            hv_ResPhi.Dispose();
            hv__.Dispose();
            hv_NumGt.Dispose();
            hv_NumRes.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Model
    // Short Description: Calculate evaluation measures based on the values of RunningMeasures and the settings in EvalParams. 
    public void calculate_evaluation_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
        out HTuple hv_EvaluationResult)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_EvaluationType = new HTuple(), hv_EvaluationResultTmp = new HTuple();
        HTuple hv_PixelMeasures = new HTuple(), hv_PixelMeasureValues = new HTuple();
        HTuple hv_ResultKeys = new HTuple(), hv_KeyIndex = new HTuple();
        HTuple hv___Tmp_Ctrl_Type = new HTuple();
        // Initialize local and output iconic variables 
        hv_EvaluationResult = new HTuple();
        try
        {
            //
            //This procedure calculates the final measures depending on the evaluation type.
            //
            hv_EvaluationType.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
            if ((int)((new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))).TupleOr(
                new HTuple(hv_EvaluationType.TupleEqual("gc_anomaly_detection")))) != 0)
            {
                hv_EvaluationResult.Dispose();
                calculate_image_anomaly_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
            }
            else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
            {
                hv_EvaluationResult.Dispose();
                calculate_image_classification_measures(hv_RunningMeasures, hv_EvalParams,
                    out hv_EvaluationResult);
            }
            else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("multi_label_classification"))) != 0)
            {
                hv_EvaluationResult.Dispose();
                calculate_multi_label_classification_measures(hv_RunningMeasures, hv_EvalParams,
                    out hv_EvaluationResult);
            }
            else if ((int)((new HTuple(hv_EvaluationType.TupleEqual("detection"))).TupleOr(
                new HTuple(hv_EvaluationType.TupleEqual("ocr_detection")))) != 0)
            {
                hv_EvaluationResult.Dispose();
                calculate_instance_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
                if ((int)(new HTuple(hv_EvaluationType.TupleEqual("ocr_detection"))) != 0)
                {
                    {
                        HTuple ExpTmpOutVar_0;
                        calculate_ocr_detection_measures(hv_EvaluationResult, out ExpTmpOutVar_0);
                        hv_EvaluationResult.Dispose();
                        hv_EvaluationResult = ExpTmpOutVar_0;
                    }
                }
            }
            else if ((int)((new HTuple(hv_EvaluationType.TupleEqual("segmentation"))).TupleOr(
                new HTuple(hv_EvaluationType.TupleEqual("3d_gripping_point_detection")))) != 0)
            {
                hv_EvaluationResult.Dispose();
                calculate_pixel_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
                if ((int)(new HTuple(hv_EvaluationType.TupleEqual("3d_gripping_point_detection"))) != 0)
                {
                    hv_EvaluationResultTmp.Dispose();
                    calculate_region_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResultTmp);
                    //Only report requested pixel and region measures.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_PixelMeasures.Dispose();
                        get_requested_pixel_measures(hv_EvalParams.TupleGetDictTuple("measures"),
                            hv_EvaluationType, out hv_PixelMeasures);
                    }
                    hv_PixelMeasureValues.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvaluationResult, hv_PixelMeasures, out hv_PixelMeasureValues);
                    HOperatorSet.SetDictTuple(hv_EvaluationResultTmp, hv_PixelMeasures, hv_PixelMeasureValues);
                    hv_EvaluationResult.Dispose();
                    hv_EvaluationResult = new HTuple(hv_EvaluationResultTmp);
                    hv_EvaluationResultTmp.Dispose();
                    calculate_running_gripping_point_measures(hv_RunningMeasures, hv_EvalParams,
                        out hv_EvaluationResultTmp);
                    hv_ResultKeys.Dispose();
                    HOperatorSet.GetDictParam(hv_EvaluationResultTmp, "keys", new HTuple(),
                        out hv_ResultKeys);
                    for (hv_KeyIndex = 0; (int)hv_KeyIndex <= (int)((new HTuple(hv_ResultKeys.TupleLength()
                        )) - 1); hv_KeyIndex = (int)hv_KeyIndex + 1)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv___Tmp_Ctrl_Type.Dispose();
                            HOperatorSet.GetDictParam(hv_EvaluationResultTmp, "key_data_type", hv_ResultKeys.TupleSelect(
                                hv_KeyIndex), out hv___Tmp_Ctrl_Type);
                        }
                        if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictObject(hv_EvaluationResultTmp.TupleGetDictObject(
                                    hv_ResultKeys.TupleSelect(hv_KeyIndex)), hv_EvaluationResult, hv_ResultKeys.TupleSelect(
                                    hv_KeyIndex));
                            }
                        }
                        else
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_EvaluationResult, hv_ResultKeys.TupleSelect(
                                    hv_KeyIndex), hv_EvaluationResultTmp.TupleGetDictTuple(hv_ResultKeys.TupleSelect(
                                    hv_KeyIndex)));
                            }
                        }
                    }
                }
            }
            else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("ocr_recognition"))) != 0)
            {
                hv_EvaluationResult.Dispose();
                calculate_ocr_recognition_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
            }
            //

            hv_EvaluationType.Dispose();
            hv_EvaluationResultTmp.Dispose();
            hv_PixelMeasures.Dispose();
            hv_PixelMeasureValues.Dispose();
            hv_ResultKeys.Dispose();
            hv_KeyIndex.Dispose();
            hv___Tmp_Ctrl_Type.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_EvaluationType.Dispose();
            hv_EvaluationResultTmp.Dispose();
            hv_PixelMeasures.Dispose();
            hv_PixelMeasureValues.Dispose();
            hv_ResultKeys.Dispose();
            hv_KeyIndex.Dispose();
            hv___Tmp_Ctrl_Type.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
    // Short Description: Calculate anomaly measures based on RunningMeasures. 
    private void calculate_image_anomaly_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
        out HTuple hv_EvaluationResult)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_CalcAnomalyHistogram = new HTuple();
        HTuple hv_CalcPrecision = new HTuple(), hv_CalcRecall = new HTuple();
        HTuple hv_CalcAbsoluteConfusionMatrix = new HTuple(), hv_CalcRelativeConfusionMatrix = new HTuple();
        HTuple hv_MeasuresExists = new HTuple(), hv_Measures = new HTuple();
        HTuple hv_M = new HTuple(), hv_AnomalyClassificationThresholdExists = new HTuple();
        HTuple hv_AnomalyClassificationThreshold = new HTuple();
        HTuple hv_ImageIDs = new HTuple(), hv_AnomalyLabelIDs = new HTuple();
        HTuple hv_AnomalyScores = new HTuple(), hv_OKIndices = new HTuple();
        HTuple hv_NOKIndices = new HTuple(), hv_HistoOKXValues = new HTuple();
        HTuple hv_HistoOKYValues = new HTuple(), hv_NumOKEvalData = new HTuple();
        HTuple hv_ImageLevelScoresOK = new HTuple(), hv_HistoNOKXValues = new HTuple();
        HTuple hv_HistoNOKYValues = new HTuple(), hv_NumNOKEvalData = new HTuple();
        HTuple hv_ImageLevelScoresNOK = new HTuple(), hv_ScoreHistogram = new HTuple();
        HTuple hv_NumClasses = new HTuple(), hv_ClassIDs = new HTuple();
        HTuple hv_AllPredictions = new HTuple(), hv_IndThreshold = new HTuple();
        HTuple hv_CurrentThresholdValue = new HTuple(), hv_CurrentThresholdKey = new HTuple();
        HTuple hv_Predictions = new HTuple(), hv_AbsoluteConfustionMatrices = new HTuple();
        HTuple hv_AbsoluteConfusionMatrix = new HTuple(), hv_Rows = new HTuple();
        HTuple hv_Columns = new HTuple(), hv_Value = new HTuple();
        HTuple hv_AbsoluteConfusionMatrixDictionary = new HTuple();
        HTuple hv_RelativeConfustionMatrices = new HTuple(), hv_RelativeConfusionMatrix = new HTuple();
        HTuple hv_RelativeConfusionMatrixDictionary = new HTuple();
        HTuple hv_GlobalEvaluation = new HTuple(), hv_AllClassPrecisions = new HTuple();
        HTuple hv_AllMeanPrecisions = new HTuple(), hv_AbsoluteConfusionMatrices = new HTuple();
        HTuple hv_ClassPrecisions = new HTuple(), hv_MatrixRowSumID = new HTuple();
        HTuple hv_MatrixColumnSumID = new HTuple(), hv_Index = new HTuple();
        HTuple hv_TruePositive = new HTuple(), hv_SumPredictedClass = new HTuple();
        HTuple hv_SumLabel = new HTuple(), hv_ClassPrecision = new HTuple();
        HTuple hv_ValidClassPrecisions = new HTuple(), hv_MeanPrecision = new HTuple();
        HTuple hv_AllClassRecalls = new HTuple(), hv_AllMeanRecalls = new HTuple();
        HTuple hv_ClassRecalls = new HTuple(), hv_ClassRecall = new HTuple();
        HTuple hv_ValidClassRecalls = new HTuple(), hv_MeanRecall = new HTuple();
        // Initialize local and output iconic variables 
        hv_EvaluationResult = new HTuple();
        try
        {
            //
            //This procedure calculates the final summarizing image anomaly measures based on the running measures.
            //
            hv_CalcAnomalyHistogram.Dispose();
            hv_CalcAnomalyHistogram = 1;
            hv_CalcPrecision.Dispose();
            hv_CalcPrecision = 0;
            hv_CalcRecall.Dispose();
            hv_CalcRecall = 0;
            hv_CalcAbsoluteConfusionMatrix.Dispose();
            hv_CalcAbsoluteConfusionMatrix = 0;
            hv_CalcRelativeConfusionMatrix.Dispose();
            hv_CalcRelativeConfusionMatrix = 0;
            hv_MeasuresExists.Dispose();
            HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "measures", out hv_MeasuresExists);
            if ((int)(hv_MeasuresExists) != 0)
            {
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
                {
                    if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual("anomaly_score_histogram"))) != 0)
                    {
                        //The default, just here for consistency.
                        hv_CalcAnomalyHistogram.Dispose();
                        hv_CalcAnomalyHistogram = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "precision"))) != 0)
                    {
                        hv_CalcPrecision.Dispose();
                        hv_CalcPrecision = 1;
                        hv_CalcAbsoluteConfusionMatrix.Dispose();
                        hv_CalcAbsoluteConfusionMatrix = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "recall"))) != 0)
                    {
                        hv_CalcRecall.Dispose();
                        hv_CalcRecall = 1;
                        hv_CalcAbsoluteConfusionMatrix.Dispose();
                        hv_CalcAbsoluteConfusionMatrix = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "absolute_confusion_matrix"))) != 0)
                    {
                        hv_CalcAbsoluteConfusionMatrix.Dispose();
                        hv_CalcAbsoluteConfusionMatrix = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "relative_confusion_matrix"))) != 0)
                    {
                        hv_CalcRelativeConfusionMatrix.Dispose();
                        hv_CalcRelativeConfusionMatrix = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "all"))) != 0)
                    {
                        hv_CalcPrecision.Dispose();
                        hv_CalcPrecision = 1;
                        hv_CalcRecall.Dispose();
                        hv_CalcRecall = 1;
                        hv_CalcAbsoluteConfusionMatrix.Dispose();
                        hv_CalcAbsoluteConfusionMatrix = 1;
                        hv_CalcRelativeConfusionMatrix.Dispose();
                        hv_CalcRelativeConfusionMatrix = 1;
                    }
                    else
                    {
                        throw new HalconException(("Unknown Measure: " + (hv_Measures.TupleSelect(
                            hv_M))) + ".");
                    }
                }
            }
            //
            hv_AnomalyClassificationThresholdExists.Dispose();
            HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "anomaly_classification_thresholds",
                out hv_AnomalyClassificationThresholdExists);
            if ((int)(hv_AnomalyClassificationThresholdExists) != 0)
            {
                hv_AnomalyClassificationThreshold.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "anomaly_classification_thresholds",
                    out hv_AnomalyClassificationThreshold);
            }
            else if ((int)(hv_CalcRelativeConfusionMatrix.TupleOr(hv_CalcAbsoluteConfusionMatrix)) != 0)
            {
                throw new HalconException("A threshold value is needed to calculate a confusion matrix.");
            }
            //
            //Get and check values in RunningMeasures.
            //
            //Get image ids.
            hv_ImageIDs.Dispose();
            HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_ids", out hv_ImageIDs);
            //Get anomaly ids.
            hv_AnomalyLabelIDs.Dispose();
            HOperatorSet.GetDictTuple(hv_RunningMeasures, "anomaly_label_ids", out hv_AnomalyLabelIDs);
            //Get image scores.
            hv_AnomalyScores.Dispose();
            HOperatorSet.GetDictTuple(hv_RunningMeasures, "anomaly_scores", out hv_AnomalyScores);
            //
            //Calculate histograms.
            //
            //Find scores of 'ok' and 'nok' images.
            hv_OKIndices.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_OKIndices = hv_AnomalyLabelIDs.TupleFind(
                    0);
            }
            hv_NOKIndices.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_NOKIndices = hv_AnomalyLabelIDs.TupleFind(
                    1);
            }
            if ((int)((new HTuple(hv_OKIndices.TupleEqual(-1))).TupleAnd(new HTuple(hv_NOKIndices.TupleEqual(
                -1)))) != 0)
            {
                throw new HalconException("No data available for evaluation");
            }
            //
            //Calculate histogram for 'ok' images.
            hv_HistoOKXValues.Dispose();
            hv_HistoOKXValues = new HTuple();
            hv_HistoOKYValues.Dispose();
            hv_HistoOKYValues = new HTuple();
            hv_NumOKEvalData.Dispose();
            hv_NumOKEvalData = 0;
            if ((int)(new HTuple(hv_OKIndices.TupleNotEqual(-1))) != 0)
            {
                hv_NumOKEvalData.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumOKEvalData = new HTuple(hv_OKIndices.TupleLength()
                        );
                }
                hv_ImageLevelScoresOK.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageLevelScoresOK = hv_AnomalyScores.TupleSelect(
                        hv_OKIndices);
                }
                hv_HistoOKXValues.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HistoOKXValues = hv_ImageLevelScoresOK.TupleSort()
                        ;
                }
                hv_HistoOKYValues.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HistoOKYValues = ((HTuple.TupleGenSequence(
                        new HTuple(hv_ImageLevelScoresOK.TupleLength()), 1, -1)).TupleReal()) / (new HTuple(hv_ImageLevelScoresOK.TupleLength()
                        ));
                }
            }
            //
            //Calculate histogram for 'nok' images.
            hv_HistoNOKXValues.Dispose();
            hv_HistoNOKXValues = new HTuple();
            hv_HistoNOKYValues.Dispose();
            hv_HistoNOKYValues = new HTuple();
            hv_NumNOKEvalData.Dispose();
            hv_NumNOKEvalData = 0;
            if ((int)(new HTuple(hv_NOKIndices.TupleNotEqual(-1))) != 0)
            {
                hv_NumNOKEvalData.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumNOKEvalData = new HTuple(hv_NOKIndices.TupleLength()
                        );
                }
                hv_ImageLevelScoresNOK.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageLevelScoresNOK = hv_AnomalyScores.TupleSelect(
                        hv_NOKIndices);
                }
                hv_HistoNOKXValues.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HistoNOKXValues = hv_ImageLevelScoresNOK.TupleSort()
                        ;
                }
                hv_HistoNOKYValues.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HistoNOKYValues = ((HTuple.TupleGenSequence(
                        1, new HTuple(hv_ImageLevelScoresNOK.TupleLength()), 1)).TupleReal()) / (new HTuple(hv_ImageLevelScoresNOK.TupleLength()
                        ));
                }
            }
            //
            //Create dictionary for the score histogram.
            hv_ScoreHistogram.Dispose();
            HOperatorSet.CreateDict(out hv_ScoreHistogram);
            HOperatorSet.SetDictTuple(hv_ScoreHistogram, "ok_x", hv_HistoOKXValues);
            HOperatorSet.SetDictTuple(hv_ScoreHistogram, "ok_y", hv_HistoOKYValues);
            HOperatorSet.SetDictTuple(hv_ScoreHistogram, "nok_x", hv_HistoNOKXValues);
            HOperatorSet.SetDictTuple(hv_ScoreHistogram, "nok_y", hv_HistoNOKYValues);
            //
            //Set the score histogram in the results dictionary.
            hv_EvaluationResult.Dispose();
            HOperatorSet.CreateDict(out hv_EvaluationResult);
            HOperatorSet.SetDictTuple(hv_EvaluationResult, "anomaly_score_histogram", hv_ScoreHistogram);
            //
            //Get Predictions according to given Threshold value(s).
            //Remember, precision and recall base on the absolute confusion matrix.
            if ((int)(hv_CalcAbsoluteConfusionMatrix.TupleOr(hv_CalcRelativeConfusionMatrix)) != 0)
            {
                hv_NumClasses.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                hv_AllPredictions.Dispose();
                HOperatorSet.CreateDict(out hv_AllPredictions);
                for (hv_IndThreshold = 0; (int)hv_IndThreshold <= (int)((new HTuple(hv_AnomalyClassificationThreshold.TupleLength()
                    )) - 1); hv_IndThreshold = (int)hv_IndThreshold + 1)
                {
                    hv_CurrentThresholdValue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentThresholdValue = hv_AnomalyClassificationThreshold.TupleSelect(
                            hv_IndThreshold);
                    }
                    hv_CurrentThresholdKey.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentThresholdKey = hv_IndThreshold.TupleString(
                            ".3d");
                    }
                    hv_Predictions.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Predictions = hv_AnomalyScores.TupleGreaterEqualElem(
                            hv_CurrentThresholdValue);
                    }
                    HOperatorSet.SetDictTuple(hv_AllPredictions, hv_CurrentThresholdKey, hv_Predictions);
                }
            }
            //
            //Calculate absolute confusion matrix.
            if ((int)(hv_CalcAbsoluteConfusionMatrix) != 0)
            {
                hv_AbsoluteConfustionMatrices.Dispose();
                hv_AbsoluteConfustionMatrices = new HTuple();
                for (hv_IndThreshold = 0; (int)hv_IndThreshold <= (int)((new HTuple(hv_AnomalyClassificationThreshold.TupleLength()
                    )) - 1); hv_IndThreshold = (int)hv_IndThreshold + 1)
                {
                    hv_CurrentThresholdValue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentThresholdValue = hv_AnomalyClassificationThreshold.TupleSelect(
                            hv_IndThreshold);
                    }
                    hv_CurrentThresholdKey.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentThresholdKey = hv_IndThreshold.TupleString(
                            ".3d");
                    }
                    hv_Predictions.Dispose();
                    HOperatorSet.GetDictTuple(hv_AllPredictions, hv_CurrentThresholdKey, out hv_Predictions);
                    hv_AbsoluteConfusionMatrix.Dispose();
                    gen_confusion_matrix(hv_AnomalyLabelIDs, hv_Predictions, (new HTuple("display_matrix")).TupleConcat(
                        "return_matrix"), (new HTuple("none")).TupleConcat("absolute"), new HTuple(),
                        out hv_AbsoluteConfusionMatrix);
                    hv_Rows.Dispose(); hv_Columns.Dispose();
                    HOperatorSet.GetSizeMatrix(hv_AbsoluteConfusionMatrix, out hv_Rows, out hv_Columns);
                    if ((int)((new HTuple((new HTuple(hv_NumOKEvalData.TupleLessEqual(0))).TupleOr(
                        new HTuple(hv_NumNOKEvalData.TupleLessEqual(0))))).TupleAnd((new HTuple(hv_Rows.TupleLess(
                        2))).TupleOr(new HTuple(hv_Columns.TupleLess(2))))) != 0)
                    {
                        //Patch matrix to 2x2 in case only 'ok' or only 'nok'
                        //data is used for evaluation.
                        hv_Value.Dispose();
                        HOperatorSet.GetValueMatrix(hv_AbsoluteConfusionMatrix, 0, 0, out hv_Value);
                        hv_AbsoluteConfusionMatrix.Dispose();
                        HOperatorSet.CreateMatrix(2, 2, 0, out hv_AbsoluteConfusionMatrix);
                        if ((int)(new HTuple(hv_NumOKEvalData.TupleLessEqual(0))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetValueMatrix(hv_AbsoluteConfusionMatrix, 0, 1, (new HTuple(hv_Predictions.TupleLength()
                                    )) - hv_Value);
                            }
                            HOperatorSet.SetValueMatrix(hv_AbsoluteConfusionMatrix, 1, 1, hv_Value);
                        }
                        if ((int)(new HTuple(hv_NumNOKEvalData.TupleLessEqual(0))) != 0)
                        {
                            HOperatorSet.SetValueMatrix(hv_AbsoluteConfusionMatrix, 0, 0, hv_Value);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetValueMatrix(hv_AbsoluteConfusionMatrix, 1, 0, (new HTuple(hv_Predictions.TupleLength()
                                    )) - hv_Value);
                            }
                        }
                    }
                    hv_AbsoluteConfusionMatrixDictionary.Dispose();
                    HOperatorSet.CreateDict(out hv_AbsoluteConfusionMatrixDictionary);
                    HOperatorSet.SetDictTuple(hv_AbsoluteConfusionMatrixDictionary, "confusion_matrix",
                        hv_AbsoluteConfusionMatrix);
                    HOperatorSet.SetDictTuple(hv_AbsoluteConfusionMatrixDictionary, "threshold",
                        hv_CurrentThresholdValue);
                    if (hv_AbsoluteConfustionMatrices == null)
                        hv_AbsoluteConfustionMatrices = new HTuple();
                    hv_AbsoluteConfustionMatrices[hv_IndThreshold] = hv_AbsoluteConfusionMatrixDictionary;
                }
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "absolute_confusion_matrix",
                    hv_AbsoluteConfustionMatrices);
            }
            //
            //Calculate relative confusion matrix.
            if ((int)(hv_CalcRelativeConfusionMatrix) != 0)
            {
                hv_RelativeConfustionMatrices.Dispose();
                hv_RelativeConfustionMatrices = new HTuple();
                for (hv_IndThreshold = 0; (int)hv_IndThreshold <= (int)((new HTuple(hv_AnomalyClassificationThreshold.TupleLength()
                    )) - 1); hv_IndThreshold = (int)hv_IndThreshold + 1)
                {
                    hv_CurrentThresholdValue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentThresholdValue = hv_AnomalyClassificationThreshold.TupleSelect(
                            hv_IndThreshold);
                    }
                    hv_CurrentThresholdKey.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentThresholdKey = hv_IndThreshold.TupleString(
                            ".3d");
                    }
                    hv_Predictions.Dispose();
                    HOperatorSet.GetDictTuple(hv_AllPredictions, hv_CurrentThresholdKey, out hv_Predictions);
                    hv_RelativeConfusionMatrix.Dispose();
                    gen_confusion_matrix(hv_AnomalyLabelIDs, hv_Predictions, (new HTuple("display_matrix")).TupleConcat(
                        "return_matrix"), (new HTuple("none")).TupleConcat("relative"), new HTuple(),
                        out hv_RelativeConfusionMatrix);
                    hv_Rows.Dispose(); hv_Columns.Dispose();
                    HOperatorSet.GetSizeMatrix(hv_RelativeConfusionMatrix, out hv_Rows, out hv_Columns);
                    if ((int)((new HTuple((new HTuple(hv_NumOKEvalData.TupleLessEqual(0))).TupleOr(
                        new HTuple(hv_NumNOKEvalData.TupleLessEqual(0))))).TupleAnd((new HTuple(hv_Rows.TupleLess(
                        2))).TupleOr(new HTuple(hv_Columns.TupleLess(2))))) != 0)
                    {
                        //Patch matrix to 2x2 in case only 'ok' or only 'nok'
                        //data is used for evaluation.
                        hv_Value.Dispose();
                        HOperatorSet.GetValueMatrix(hv_RelativeConfusionMatrix, 0, 0, out hv_Value);
                        hv_RelativeConfusionMatrix.Dispose();
                        HOperatorSet.CreateMatrix(2, 2, 0, out hv_RelativeConfusionMatrix);
                        if ((int)(new HTuple(hv_NumOKEvalData.TupleLessEqual(0))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetValueMatrix(hv_RelativeConfusionMatrix, 0, 1, 1.0 - hv_Value);
                            }
                            HOperatorSet.SetValueMatrix(hv_RelativeConfusionMatrix, 1, 1, hv_Value);
                        }
                        if ((int)(new HTuple(hv_NumNOKEvalData.TupleLessEqual(0))) != 0)
                        {
                            HOperatorSet.SetValueMatrix(hv_RelativeConfusionMatrix, 0, 0, hv_Value);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetValueMatrix(hv_RelativeConfusionMatrix, 1, 0, 1.0 - hv_Value);
                            }
                        }
                    }
                    hv_RelativeConfusionMatrixDictionary.Dispose();
                    HOperatorSet.CreateDict(out hv_RelativeConfusionMatrixDictionary);
                    HOperatorSet.SetDictTuple(hv_RelativeConfusionMatrixDictionary, "confusion_matrix",
                        hv_RelativeConfusionMatrix);
                    HOperatorSet.SetDictTuple(hv_RelativeConfusionMatrixDictionary, "threshold",
                        hv_CurrentThresholdValue);
                    if (hv_RelativeConfustionMatrices == null)
                        hv_RelativeConfustionMatrices = new HTuple();
                    hv_RelativeConfustionMatrices[hv_IndThreshold] = hv_RelativeConfusionMatrixDictionary;
                }
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "relative_confusion_matrix",
                    hv_RelativeConfustionMatrices);
            }
            //
            if ((int)(hv_CalcPrecision.TupleOr(hv_CalcRecall)) != 0)
            {
                hv_GlobalEvaluation.Dispose();
                HOperatorSet.CreateDict(out hv_GlobalEvaluation);
            }
            //Calculate precision.
            if ((int)(hv_CalcPrecision) != 0)
            {
                hv_AllClassPrecisions.Dispose();
                hv_AllClassPrecisions = new HTuple();
                hv_AllMeanPrecisions.Dispose();
                hv_AllMeanPrecisions = new HTuple();
                hv_AbsoluteConfusionMatrices.Dispose();
                HOperatorSet.GetDictTuple(hv_EvaluationResult, "absolute_confusion_matrix",
                    out hv_AbsoluteConfusionMatrices);
                for (hv_IndThreshold = 0; (int)hv_IndThreshold <= (int)((new HTuple(hv_AbsoluteConfusionMatrices.TupleLength()
                    )) - 1); hv_IndThreshold = (int)hv_IndThreshold + 1)
                {
                    hv_AbsoluteConfusionMatrixDictionary.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_AbsoluteConfusionMatrixDictionary = hv_AbsoluteConfusionMatrices.TupleSelect(
                            hv_IndThreshold);
                    }
                    hv_AbsoluteConfusionMatrix.Dispose();
                    HOperatorSet.GetDictTuple(hv_AbsoluteConfusionMatrixDictionary, "confusion_matrix",
                        out hv_AbsoluteConfusionMatrix);
                    hv_ClassPrecisions.Dispose();
                    hv_ClassPrecisions = new HTuple();
                    hv_MatrixRowSumID.Dispose();
                    HOperatorSet.SumMatrix(hv_AbsoluteConfusionMatrix, "rows", out hv_MatrixRowSumID);
                    hv_MatrixColumnSumID.Dispose();
                    HOperatorSet.SumMatrix(hv_AbsoluteConfusionMatrix, "columns", out hv_MatrixColumnSumID);
                    HTuple end_val184 = hv_NumClasses - 1;
                    HTuple step_val184 = 1;
                    for (hv_Index = 0; hv_Index.Continue(end_val184, step_val184); hv_Index = hv_Index.TupleAdd(step_val184))
                    {
                        //Compute the precision for every selected class.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TruePositive.Dispose();
                            HOperatorSet.GetValueMatrix(hv_AbsoluteConfusionMatrix, hv_ClassIDs.TupleSelect(
                                hv_Index), hv_ClassIDs.TupleSelect(hv_Index), out hv_TruePositive);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SumPredictedClass.Dispose();
                            HOperatorSet.GetValueMatrix(hv_MatrixRowSumID, hv_ClassIDs.TupleSelect(
                                hv_Index), 0, out hv_SumPredictedClass);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SumLabel.Dispose();
                            HOperatorSet.GetValueMatrix(hv_MatrixColumnSumID, 0, hv_ClassIDs.TupleSelect(
                                hv_Index), out hv_SumLabel);
                        }
                        if ((int)(new HTuple(hv_SumLabel.TupleLessEqual(0))) != 0)
                        {
                            //Invalid per-class precision.
                            hv_ClassPrecision.Dispose();
                            hv_ClassPrecision = -1.0;
                        }
                        else if ((int)(new HTuple(hv_SumPredictedClass.TupleEqual(
                            0))) != 0)
                        {
                            hv_ClassPrecision.Dispose();
                            hv_ClassPrecision = 0.0;
                        }
                        else
                        {
                            hv_ClassPrecision.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassPrecision = hv_TruePositive / hv_SumPredictedClass;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ClassPrecisions = hv_ClassPrecisions.TupleConcat(
                                    hv_ClassPrecision);
                                hv_ClassPrecisions.Dispose();
                                hv_ClassPrecisions = ExpTmpLocalVar_ClassPrecisions;
                            }
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ValidClassPrecisions.Dispose();
                        HOperatorSet.TupleSelectMask(hv_ClassPrecisions, hv_ClassPrecisions.TupleGreaterEqualElem(
                            0.0), out hv_ValidClassPrecisions);
                    }
                    hv_MeanPrecision.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MeanPrecision = hv_ValidClassPrecisions.TupleMean()
                            ;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_AllClassPrecisions = hv_AllClassPrecisions.TupleConcat(
                                hv_ClassPrecisions);
                            hv_AllClassPrecisions.Dispose();
                            hv_AllClassPrecisions = ExpTmpLocalVar_AllClassPrecisions;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_AllMeanPrecisions = hv_AllMeanPrecisions.TupleConcat(
                                hv_MeanPrecision);
                            hv_AllMeanPrecisions.Dispose();
                            hv_AllMeanPrecisions = ExpTmpLocalVar_AllMeanPrecisions;
                        }
                    }
                    HOperatorSet.ClearMatrix(hv_MatrixRowSumID);
                }
                HOperatorSet.SetDictTuple(hv_GlobalEvaluation, "precision_per_class", hv_AllClassPrecisions);
                HOperatorSet.SetDictTuple(hv_GlobalEvaluation, "mean_precision", hv_AllMeanPrecisions);
            }
            //
            //Calculate recall.
            if ((int)(hv_CalcRecall) != 0)
            {
                hv_AllClassRecalls.Dispose();
                hv_AllClassRecalls = new HTuple();
                hv_AllMeanRecalls.Dispose();
                hv_AllMeanRecalls = new HTuple();
                hv_AbsoluteConfustionMatrices.Dispose();
                HOperatorSet.GetDictTuple(hv_EvaluationResult, "absolute_confusion_matrix",
                    out hv_AbsoluteConfustionMatrices);
                for (hv_IndThreshold = 0; (int)hv_IndThreshold <= (int)((new HTuple(hv_AbsoluteConfustionMatrices.TupleLength()
                    )) - 1); hv_IndThreshold = (int)hv_IndThreshold + 1)
                {
                    hv_AbsoluteConfusionMatrixDictionary.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_AbsoluteConfusionMatrixDictionary = hv_AbsoluteConfustionMatrices.TupleSelect(
                            hv_IndThreshold);
                    }
                    hv_AbsoluteConfusionMatrix.Dispose();
                    HOperatorSet.GetDictTuple(hv_AbsoluteConfusionMatrixDictionary, "confusion_matrix",
                        out hv_AbsoluteConfusionMatrix);
                    hv_ClassRecalls.Dispose();
                    hv_ClassRecalls = new HTuple();
                    hv_MatrixColumnSumID.Dispose();
                    HOperatorSet.SumMatrix(hv_AbsoluteConfusionMatrix, "columns", out hv_MatrixColumnSumID);
                    HTuple end_val219 = hv_NumClasses - 1;
                    HTuple step_val219 = 1;
                    for (hv_Index = 0; hv_Index.Continue(end_val219, step_val219); hv_Index = hv_Index.TupleAdd(step_val219))
                    {
                        //Compute the recall for every selected class.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TruePositive.Dispose();
                            HOperatorSet.GetValueMatrix(hv_AbsoluteConfusionMatrix, hv_ClassIDs.TupleSelect(
                                hv_Index), hv_ClassIDs.TupleSelect(hv_Index), out hv_TruePositive);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SumLabel.Dispose();
                            HOperatorSet.GetValueMatrix(hv_MatrixColumnSumID, 0, hv_ClassIDs.TupleSelect(
                                hv_Index), out hv_SumLabel);
                        }
                        if ((int)(new HTuple(hv_SumLabel.TupleEqual(0))) != 0)
                        {
                            //Invalid per-class recall.
                            hv_ClassRecall.Dispose();
                            hv_ClassRecall = -1.0;
                        }
                        else
                        {
                            hv_ClassRecall.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassRecall = hv_TruePositive / hv_SumLabel;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ClassRecalls = hv_ClassRecalls.TupleConcat(
                                    hv_ClassRecall);
                                hv_ClassRecalls.Dispose();
                                hv_ClassRecalls = ExpTmpLocalVar_ClassRecalls;
                            }
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ValidClassRecalls.Dispose();
                        HOperatorSet.TupleSelectMask(hv_ClassRecalls, hv_ClassRecalls.TupleGreaterEqualElem(
                            0.0), out hv_ValidClassRecalls);
                    }
                    hv_MeanRecall.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MeanRecall = hv_ValidClassRecalls.TupleMean()
                            ;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_AllClassRecalls = hv_AllClassRecalls.TupleConcat(
                                hv_ClassRecalls);
                            hv_AllClassRecalls.Dispose();
                            hv_AllClassRecalls = ExpTmpLocalVar_AllClassRecalls;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_AllMeanRecalls = hv_AllMeanRecalls.TupleConcat(
                                hv_MeanRecall);
                            hv_AllMeanRecalls.Dispose();
                            hv_AllMeanRecalls = ExpTmpLocalVar_AllMeanRecalls;
                        }
                    }
                    HOperatorSet.ClearMatrix(hv_MatrixColumnSumID);
                    //
                }
                HOperatorSet.SetDictTuple(hv_GlobalEvaluation, "recall_per_class", hv_AllClassRecalls);
                HOperatorSet.SetDictTuple(hv_GlobalEvaluation, "mean_recall", hv_AllMeanRecalls);
            }
            //
            if ((int)(hv_CalcPrecision.TupleOr(hv_CalcRecall)) != 0)
            {
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "global_evaluation", hv_GlobalEvaluation);
            }
            //

            hv_CalcAnomalyHistogram.Dispose();
            hv_CalcPrecision.Dispose();
            hv_CalcRecall.Dispose();
            hv_CalcAbsoluteConfusionMatrix.Dispose();
            hv_CalcRelativeConfusionMatrix.Dispose();
            hv_MeasuresExists.Dispose();
            hv_Measures.Dispose();
            hv_M.Dispose();
            hv_AnomalyClassificationThresholdExists.Dispose();
            hv_AnomalyClassificationThreshold.Dispose();
            hv_ImageIDs.Dispose();
            hv_AnomalyLabelIDs.Dispose();
            hv_AnomalyScores.Dispose();
            hv_OKIndices.Dispose();
            hv_NOKIndices.Dispose();
            hv_HistoOKXValues.Dispose();
            hv_HistoOKYValues.Dispose();
            hv_NumOKEvalData.Dispose();
            hv_ImageLevelScoresOK.Dispose();
            hv_HistoNOKXValues.Dispose();
            hv_HistoNOKYValues.Dispose();
            hv_NumNOKEvalData.Dispose();
            hv_ImageLevelScoresNOK.Dispose();
            hv_ScoreHistogram.Dispose();
            hv_NumClasses.Dispose();
            hv_ClassIDs.Dispose();
            hv_AllPredictions.Dispose();
            hv_IndThreshold.Dispose();
            hv_CurrentThresholdValue.Dispose();
            hv_CurrentThresholdKey.Dispose();
            hv_Predictions.Dispose();
            hv_AbsoluteConfustionMatrices.Dispose();
            hv_AbsoluteConfusionMatrix.Dispose();
            hv_Rows.Dispose();
            hv_Columns.Dispose();
            hv_Value.Dispose();
            hv_AbsoluteConfusionMatrixDictionary.Dispose();
            hv_RelativeConfustionMatrices.Dispose();
            hv_RelativeConfusionMatrix.Dispose();
            hv_RelativeConfusionMatrixDictionary.Dispose();
            hv_GlobalEvaluation.Dispose();
            hv_AllClassPrecisions.Dispose();
            hv_AllMeanPrecisions.Dispose();
            hv_AbsoluteConfusionMatrices.Dispose();
            hv_ClassPrecisions.Dispose();
            hv_MatrixRowSumID.Dispose();
            hv_MatrixColumnSumID.Dispose();
            hv_Index.Dispose();
            hv_TruePositive.Dispose();
            hv_SumPredictedClass.Dispose();
            hv_SumLabel.Dispose();
            hv_ClassPrecision.Dispose();
            hv_ValidClassPrecisions.Dispose();
            hv_MeanPrecision.Dispose();
            hv_AllClassRecalls.Dispose();
            hv_AllMeanRecalls.Dispose();
            hv_ClassRecalls.Dispose();
            hv_ClassRecall.Dispose();
            hv_ValidClassRecalls.Dispose();
            hv_MeanRecall.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_CalcAnomalyHistogram.Dispose();
            hv_CalcPrecision.Dispose();
            hv_CalcRecall.Dispose();
            hv_CalcAbsoluteConfusionMatrix.Dispose();
            hv_CalcRelativeConfusionMatrix.Dispose();
            hv_MeasuresExists.Dispose();
            hv_Measures.Dispose();
            hv_M.Dispose();
            hv_AnomalyClassificationThresholdExists.Dispose();
            hv_AnomalyClassificationThreshold.Dispose();
            hv_ImageIDs.Dispose();
            hv_AnomalyLabelIDs.Dispose();
            hv_AnomalyScores.Dispose();
            hv_OKIndices.Dispose();
            hv_NOKIndices.Dispose();
            hv_HistoOKXValues.Dispose();
            hv_HistoOKYValues.Dispose();
            hv_NumOKEvalData.Dispose();
            hv_ImageLevelScoresOK.Dispose();
            hv_HistoNOKXValues.Dispose();
            hv_HistoNOKYValues.Dispose();
            hv_NumNOKEvalData.Dispose();
            hv_ImageLevelScoresNOK.Dispose();
            hv_ScoreHistogram.Dispose();
            hv_NumClasses.Dispose();
            hv_ClassIDs.Dispose();
            hv_AllPredictions.Dispose();
            hv_IndThreshold.Dispose();
            hv_CurrentThresholdValue.Dispose();
            hv_CurrentThresholdKey.Dispose();
            hv_Predictions.Dispose();
            hv_AbsoluteConfustionMatrices.Dispose();
            hv_AbsoluteConfusionMatrix.Dispose();
            hv_Rows.Dispose();
            hv_Columns.Dispose();
            hv_Value.Dispose();
            hv_AbsoluteConfusionMatrixDictionary.Dispose();
            hv_RelativeConfustionMatrices.Dispose();
            hv_RelativeConfusionMatrix.Dispose();
            hv_RelativeConfusionMatrixDictionary.Dispose();
            hv_GlobalEvaluation.Dispose();
            hv_AllClassPrecisions.Dispose();
            hv_AllMeanPrecisions.Dispose();
            hv_AbsoluteConfusionMatrices.Dispose();
            hv_ClassPrecisions.Dispose();
            hv_MatrixRowSumID.Dispose();
            hv_MatrixColumnSumID.Dispose();
            hv_Index.Dispose();
            hv_TruePositive.Dispose();
            hv_SumPredictedClass.Dispose();
            hv_SumLabel.Dispose();
            hv_ClassPrecision.Dispose();
            hv_ValidClassPrecisions.Dispose();
            hv_MeanPrecision.Dispose();
            hv_AllClassRecalls.Dispose();
            hv_AllMeanRecalls.Dispose();
            hv_ClassRecalls.Dispose();
            hv_ClassRecall.Dispose();
            hv_ValidClassRecalls.Dispose();
            hv_MeanRecall.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Classification
    // Short Description: Calculate image classification measures based on RunningMeasures. 
    private void calculate_image_classification_measures(HTuple hv_RunningMeasures,
        HTuple hv_EvalParams, out HTuple hv_EvaluationResult)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_TopKErrorKs = new HTuple(), hv_CalcPrecision = new HTuple();
        HTuple hv_CalcRecall = new HTuple(), hv_CalcFScore = new HTuple();
        HTuple hv_CalcAbsoluteConfusionMatrix = new HTuple(), hv_CalcRelativeConfusionMatrix = new HTuple();
        HTuple hv_Measures = new HTuple(), hv_OODDetectionMeasures = new HTuple();
        HTuple hv_RegExpTopKError = new HTuple(), hv_M = new HTuple();
        HTuple hv_ComputeTopKError = new HTuple(), hv_K = new HTuple();
        HTuple hv_ClassIDs = new HTuple(), hv_KeyExists = new HTuple();
        HTuple hv_ClassesToEvaluate = new HTuple(), hv_ClassIDsToEvaluate = new HTuple();
        HTuple hv_ClassNames = new HTuple(), hv_Index = new HTuple();
        HTuple hv_Position = new HTuple(), hv_ImageIDs = new HTuple();
        HTuple hv_ImageLabelIDs = new HTuple(), hv_Predictions = new HTuple();
        HTuple hv_TopKPredictions = new HTuple(), hv_EvalIndex = new HTuple();
        HTuple hv_CurrentEvalClass = new HTuple(), hv_IndexClass = new HTuple();
        HTuple hv_EvaluatedSamples = new HTuple(), hv_ConfusionMatrix = new HTuple();
        HTuple hv_RelativeConfusionMatrix = new HTuple(), hv_EvalClassID = new HTuple();
        HTuple hv_KIndex = new HTuple(), hv_Indices = new HTuple();
        HTuple hv_TopKError = new HTuple(), hv_NumClasses = new HTuple();
        HTuple hv_ClassPrecisions = new HTuple(), hv_MatrixRowSumID = new HTuple();
        HTuple hv_TruePositive = new HTuple(), hv_SumPredictedClass = new HTuple();
        HTuple hv_ClassPrecision = new HTuple(), hv_Precision = new HTuple();
        HTuple hv_ClassRecalls = new HTuple(), hv_MatrixColumnSumID = new HTuple();
        HTuple hv_SumLabel = new HTuple(), hv_ClassRecall = new HTuple();
        HTuple hv_Recall = new HTuple(), hv_ClassFScores = new HTuple();
        HTuple hv_SumPrecisionRecall = new HTuple(), hv_PositiveIndices = new HTuple();
        HTuple hv_FScore = new HTuple(), hv_KeyName = new HTuple();
        HTuple hv_CalculateOodMeasuresExists = new HTuple();
        // Initialize local and output iconic variables 
        hv_EvaluationResult = new HTuple();
        try
        {
            //
            //This procedure calculates the final summarizing image classification measures based on the running measures.
            //
            //Set default values.
            hv_TopKErrorKs.Dispose();
            hv_TopKErrorKs = new HTuple();
            hv_CalcPrecision.Dispose();
            hv_CalcPrecision = 0;
            hv_CalcRecall.Dispose();
            hv_CalcRecall = 0;
            hv_CalcFScore.Dispose();
            hv_CalcFScore = 0;
            hv_CalcAbsoluteConfusionMatrix.Dispose();
            hv_CalcAbsoluteConfusionMatrix = 0;
            hv_CalcRelativeConfusionMatrix.Dispose();
            hv_CalcRelativeConfusionMatrix = 0;
            //
            //Check which measures are to be calculated.
            hv_Measures.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
            hv_OODDetectionMeasures.Dispose();
            hv_OODDetectionMeasures = new HTuple();
            hv_OODDetectionMeasures[0] = "ood_confusion_matrix";
            hv_OODDetectionMeasures[1] = "ood_precision";
            hv_OODDetectionMeasures[2] = "ood_recall";
            hv_OODDetectionMeasures[3] = "ood_f_score";
            hv_OODDetectionMeasures[4] = "ood_false_positive_rate";
            hv_OODDetectionMeasures[5] = "ood_score_histogram";
            hv_OODDetectionMeasures[6] = "ood_thresholds";
            hv_RegExpTopKError.Dispose();
            hv_RegExpTopKError = "top([0-9]+)_error";
            for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
            {
                hv_ComputeTopKError.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ComputeTopKError = ((hv_Measures.TupleSelect(
                        hv_M))).TupleRegexpTest("top([0-9]+)_error");
                }
                if ((int)(hv_ComputeTopKError) != 0)
                {
                    hv_K.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_K = ((((hv_Measures.TupleSelect(
                            hv_M))).TupleRegexpMatch(hv_RegExpTopKError))).TupleNumber();
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TopKErrorKs = ((hv_TopKErrorKs.TupleConcat(
                                hv_K))).TupleSort();
                            hv_TopKErrorKs.Dispose();
                            hv_TopKErrorKs = ExpTmpLocalVar_TopKErrorKs;
                        }
                    }
                }
                else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                    "precision"))) != 0)
                {
                    hv_CalcPrecision.Dispose();
                    hv_CalcPrecision = 1;
                }
                else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                    "recall"))) != 0)
                {
                    hv_CalcRecall.Dispose();
                    hv_CalcRecall = 1;
                }
                else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                    "f_score"))) != 0)
                {
                    hv_CalcFScore.Dispose();
                    hv_CalcFScore = 1;
                }
                else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                    "absolute_confusion_matrix"))) != 0)
                {
                    hv_CalcAbsoluteConfusionMatrix.Dispose();
                    hv_CalcAbsoluteConfusionMatrix = 1;
                }
                else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                    "relative_confusion_matrix"))) != 0)
                {
                    hv_CalcRelativeConfusionMatrix.Dispose();
                    hv_CalcRelativeConfusionMatrix = 1;
                }
                else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                    "all"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TopKErrorKs = ((hv_TopKErrorKs.TupleConcat(
                                1))).TupleSort();
                            hv_TopKErrorKs.Dispose();
                            hv_TopKErrorKs = ExpTmpLocalVar_TopKErrorKs;
                        }
                    }
                    hv_CalcPrecision.Dispose();
                    hv_CalcPrecision = 1;
                    hv_CalcRecall.Dispose();
                    hv_CalcRecall = 1;
                    hv_CalcFScore.Dispose();
                    hv_CalcFScore = 1;
                    hv_CalcAbsoluteConfusionMatrix.Dispose();
                    hv_CalcAbsoluteConfusionMatrix = 1;
                    hv_CalcRelativeConfusionMatrix.Dispose();
                    hv_CalcRelativeConfusionMatrix = 1;
                }
                else if ((int)(new HTuple(((hv_OODDetectionMeasures.TupleFind(hv_Measures.TupleSelect(
                    hv_M)))).TupleNotEqual(-1))) != 0)
                {
                    //OOD detection measures are computed in a separate procedure.
                }
                else
                {
                    throw new HalconException("Unknown image classification measure: " + (hv_Measures.TupleSelect(
                        hv_M)));
                }
            }
            //
            //Initialize output dictionary and get necessary evaluation parameters.
            hv_EvaluationResult.Dispose();
            HOperatorSet.CreateDict(out hv_EvaluationResult);
            hv_ClassIDs.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
            hv_KeyExists.Dispose();
            HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_names_to_evaluate",
                out hv_KeyExists);
            if ((int)(hv_KeyExists) != 0)
            {
                hv_ClassesToEvaluate.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_names_to_evaluate", out hv_ClassesToEvaluate);
                hv_ClassIDsToEvaluate.Dispose();
                hv_ClassIDsToEvaluate = new HTuple();
                hv_ClassNames.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_names", out hv_ClassNames);
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ClassesToEvaluate.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_Position.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Position = (((((new HTuple("global")).TupleConcat(
                            hv_ClassNames))).TupleEqualElem(hv_ClassesToEvaluate.TupleSelect(hv_Index)))).TupleFind(
                            1);
                    }
                    if ((int)((new HTuple(hv_Position.TupleEqual(-1))).TupleOr(new HTuple(hv_Position.TupleEqual(
                        new HTuple())))) != 0)
                    {
                        throw new HalconException("Invalid entry in  'class_names_to_evaluate': " + ((((new HTuple("global")).TupleConcat(
                            hv_ClassesToEvaluate))).TupleSelect(hv_Index)));
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ClassIDsToEvaluate = hv_ClassIDsToEvaluate.TupleConcat(
                                (((new HTuple("global")).TupleConcat(hv_ClassIDs))).TupleSelect(hv_Position));
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate = ExpTmpLocalVar_ClassIDsToEvaluate;
                        }
                    }
                }
                HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids_to_evaluate", hv_ClassIDsToEvaluate);
            }
            hv_ClassIDsToEvaluate.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids_to_evaluate", out hv_ClassIDsToEvaluate);
            //
            //Get and check values in RunningMeasures.
            hv_ImageIDs.Dispose();
            HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_ids", out hv_ImageIDs);
            hv_ImageLabelIDs.Dispose();
            HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_label_ids", out hv_ImageLabelIDs);
            hv_Predictions.Dispose();
            HOperatorSet.GetDictTuple(hv_RunningMeasures, "top1_predictions", out hv_Predictions);
            hv_TopKPredictions.Dispose();
            HOperatorSet.GetDictTuple(hv_RunningMeasures, "topk_predictions", out hv_TopKPredictions);
            //
            //Check if needed classes appear in image label IDs.
            //For the confusion matrices, all classes need to be represented.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                {
                    HTuple
                      ExpTmpLocalVar_CalcAbsoluteConfusionMatrix = (new HTuple((new HTuple(hv_CalcPrecision.TupleOr(
                        hv_CalcRecall))).TupleOr(hv_CalcFScore))).TupleOr(hv_CalcAbsoluteConfusionMatrix);
                    hv_CalcAbsoluteConfusionMatrix.Dispose();
                    hv_CalcAbsoluteConfusionMatrix = ExpTmpLocalVar_CalcAbsoluteConfusionMatrix;
                }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                {
                    HTuple
                      ExpTmpLocalVar_CalcRelativeConfusionMatrix = (new HTuple((new HTuple(hv_CalcPrecision.TupleOr(
                        hv_CalcRecall))).TupleOr(hv_CalcFScore))).TupleOr(hv_CalcRelativeConfusionMatrix);
                    hv_CalcRelativeConfusionMatrix.Dispose();
                    hv_CalcRelativeConfusionMatrix = ExpTmpLocalVar_CalcRelativeConfusionMatrix;
                }
            }
            if ((int)(hv_CalcAbsoluteConfusionMatrix.TupleOr(hv_CalcRelativeConfusionMatrix)) != 0)
            {
                if ((int)(new HTuple(((((hv_ImageLabelIDs.TupleSort())).TupleUniq())).TupleNotEqual(
                    hv_ClassIDs.TupleSort()))) != 0)
                {
                    throw new HalconException("Not all classes are represented in the ground truth labels. \nPlease check your data split.");
                }
            }
            //For top-K errors, the evaluated classes need to be represented.
            if ((int)(new HTuple(hv_TopKErrorKs.TupleNotEqual(new HTuple()))) != 0)
            {
                for (hv_EvalIndex = 0; (int)hv_EvalIndex <= (int)((new HTuple(hv_ClassIDsToEvaluate.TupleLength()
                    )) - 1); hv_EvalIndex = (int)hv_EvalIndex + 1)
                {
                    hv_CurrentEvalClass.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentEvalClass = hv_ClassIDsToEvaluate.TupleSelect(
                            hv_EvalIndex);
                    }
                    if ((int)(new HTuple(hv_CurrentEvalClass.TupleNotEqual("global"))) != 0)
                    {
                        hv_IndexClass.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IndexClass = hv_ImageLabelIDs.TupleFind(
                                hv_CurrentEvalClass);
                        }
                        if ((int)((new HTuple(hv_IndexClass.TupleEqual(-1))).TupleOr(new HTuple(hv_IndexClass.TupleEqual(
                            new HTuple())))) != 0)
                        {
                            throw new HalconException(("The evaluated class ID " + hv_CurrentEvalClass) + " is not represented in the ground truth labels.");
                        }
                    }
                }
            }
            //
            //Set image IDs, image label IDs, and top1-predictions to of evaluated samples EvaluationResult.
            hv_EvaluatedSamples.Dispose();
            HOperatorSet.CreateDict(out hv_EvaluatedSamples);
            HOperatorSet.SetDictTuple(hv_EvaluatedSamples, "image_ids", hv_ImageIDs);
            HOperatorSet.SetDictTuple(hv_EvaluatedSamples, "image_label_ids", hv_ImageLabelIDs);
            HOperatorSet.SetDictTuple(hv_EvaluatedSamples, "top1_predictions", hv_Predictions);
            HOperatorSet.SetDictTuple(hv_EvaluationResult, "evaluated_samples", hv_EvaluatedSamples);
            //
            //Calculate absolute confusion matrix if needed and set it to EvaluationResult.
            if ((int)(hv_CalcAbsoluteConfusionMatrix) != 0)
            {
                hv_ConfusionMatrix.Dispose();
                gen_confusion_matrix(hv_ImageLabelIDs, hv_Predictions, "display_matrix",
                    "none", new HTuple(), out hv_ConfusionMatrix);
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "absolute_confusion_matrix",
                    hv_ConfusionMatrix);
            }
            //
            //Calculate relative confusion matrix.
            if ((int)(hv_CalcRelativeConfusionMatrix) != 0)
            {
                hv_RelativeConfusionMatrix.Dispose();
                gen_confusion_matrix(hv_ImageLabelIDs, hv_Predictions, (new HTuple("display_matrix")).TupleConcat(
                    "return_matrix"), (new HTuple("none")).TupleConcat("relative"), new HTuple(),
                    out hv_RelativeConfusionMatrix);
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "relative_confusion_matrix",
                    hv_RelativeConfusionMatrix);
            }
            //
            // Calculate measures for every class to be evaluated.
            for (hv_EvalIndex = 0; (int)hv_EvalIndex <= (int)((new HTuple(hv_ClassIDsToEvaluate.TupleLength()
                )) - 1); hv_EvalIndex = (int)hv_EvalIndex + 1)
            {
                hv_CurrentEvalClass.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_CurrentEvalClass = hv_ClassIDsToEvaluate.TupleSelect(
                        hv_EvalIndex);
                }
                hv_EvalClassID.Dispose();
                HOperatorSet.CreateDict(out hv_EvalClassID);
                //
                //Calculate top-K errors.
                for (hv_KIndex = 0; (int)hv_KIndex <= (int)((new HTuple(hv_TopKErrorKs.TupleLength()
                    )) - 1); hv_KIndex = (int)hv_KIndex + 1)
                {
                    hv_K.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_K = hv_TopKErrorKs.TupleSelect(
                            hv_KIndex);
                    }
                    if ((int)(new HTuple(hv_CurrentEvalClass.TupleEqual("global"))) != 0)
                    {
                        hv_Indices.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Indices = HTuple.TupleGenSequence(
                                0, (new HTuple(hv_ImageLabelIDs.TupleLength())) - 1, 1);
                        }
                    }
                    else
                    {
                        hv_Indices.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Indices = hv_ImageLabelIDs.TupleFind(
                                hv_CurrentEvalClass);
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TopKError.Dispose();
                        compute_top_k_error(hv_ImageLabelIDs.TupleSelect(hv_Indices), hv_TopKPredictions.TupleSelect(
                            hv_Indices), hv_K, out hv_TopKError);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvalClassID, ("top" + hv_K) + "_error", hv_TopKError);
                    }
                }
                //
                if ((int)(new HTuple(hv_CurrentEvalClass.TupleEqual("global"))) != 0)
                {
                    //Compute the mean of the measures for all classes.
                    hv_NumClasses.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumClasses = new HTuple(hv_ClassIDs.TupleLength()
                            );
                    }
                    hv_IndexClass.Dispose();
                    hv_IndexClass = new HTuple(hv_ClassIDs);
                }
                else
                {
                    //Compute the measures for a certain class.
                    hv_NumClasses.Dispose();
                    hv_NumClasses = 1;
                    hv_IndexClass.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IndexClass = hv_ClassIDs.TupleFind(
                            hv_CurrentEvalClass);
                    }
                }
                //
                //Calculate prediction.
                if ((int)(hv_CalcPrecision.TupleOr(hv_CalcFScore)) != 0)
                {
                    hv_ClassPrecisions.Dispose();
                    hv_ClassPrecisions = new HTuple();
                    hv_MatrixRowSumID.Dispose();
                    HOperatorSet.SumMatrix(hv_ConfusionMatrix, "rows", out hv_MatrixRowSumID);
                    HTuple end_val141 = hv_NumClasses - 1;
                    HTuple step_val141 = 1;
                    for (hv_Index = 0; hv_Index.Continue(end_val141, step_val141); hv_Index = hv_Index.TupleAdd(step_val141))
                    {
                        //Compute the precision for every selected class.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TruePositive.Dispose();
                            HOperatorSet.GetValueMatrix(hv_ConfusionMatrix, hv_IndexClass.TupleSelect(
                                hv_Index), hv_IndexClass.TupleSelect(hv_Index), out hv_TruePositive);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SumPredictedClass.Dispose();
                            HOperatorSet.GetValueMatrix(hv_MatrixRowSumID, hv_IndexClass.TupleSelect(
                                hv_Index), 0, out hv_SumPredictedClass);
                        }
                        if ((int)(new HTuple(hv_SumPredictedClass.TupleEqual(0))) != 0)
                        {
                            hv_ClassPrecision.Dispose();
                            hv_ClassPrecision = 0;
                        }
                        else
                        {
                            hv_ClassPrecision.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassPrecision = hv_TruePositive / hv_SumPredictedClass;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ClassPrecisions = hv_ClassPrecisions.TupleConcat(
                                    hv_ClassPrecision);
                                hv_ClassPrecisions.Dispose();
                                hv_ClassPrecisions = ExpTmpLocalVar_ClassPrecisions;
                            }
                        }
                    }
                    hv_Precision.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Precision = hv_ClassPrecisions.TupleMean()
                            ;
                    }
                    HOperatorSet.ClearMatrix(hv_MatrixRowSumID);
                    if ((int)(new HTuple(hv_NumClasses.TupleEqual(1))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_EvalClassID, "precision", hv_Precision);
                    }
                    else
                    {
                        HOperatorSet.SetDictTuple(hv_EvalClassID, "mean_precision", hv_Precision);
                        HOperatorSet.SetDictTuple(hv_EvalClassID, "precision_per_class", hv_ClassPrecisions);
                    }
                }
                //
                //Calculate recall.
                if ((int)(hv_CalcRecall.TupleOr(hv_CalcFScore)) != 0)
                {
                    hv_ClassRecalls.Dispose();
                    hv_ClassRecalls = new HTuple();
                    hv_MatrixColumnSumID.Dispose();
                    HOperatorSet.SumMatrix(hv_ConfusionMatrix, "columns", out hv_MatrixColumnSumID);
                    HTuple end_val166 = hv_NumClasses - 1;
                    HTuple step_val166 = 1;
                    for (hv_Index = 0; hv_Index.Continue(end_val166, step_val166); hv_Index = hv_Index.TupleAdd(step_val166))
                    {
                        //Compute the recall for every class.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TruePositive.Dispose();
                            HOperatorSet.GetValueMatrix(hv_ConfusionMatrix, hv_IndexClass.TupleSelect(
                                hv_Index), hv_IndexClass.TupleSelect(hv_Index), out hv_TruePositive);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SumLabel.Dispose();
                            HOperatorSet.GetValueMatrix(hv_MatrixColumnSumID, 0, hv_IndexClass.TupleSelect(
                                hv_Index), out hv_SumLabel);
                        }
                        hv_ClassRecall.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassRecall = hv_TruePositive / hv_SumLabel;
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ClassRecalls = hv_ClassRecalls.TupleConcat(
                                    hv_ClassRecall);
                                hv_ClassRecalls.Dispose();
                                hv_ClassRecalls = ExpTmpLocalVar_ClassRecalls;
                            }
                        }
                    }
                    hv_Recall.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Recall = hv_ClassRecalls.TupleMean()
                            ;
                    }
                    HOperatorSet.ClearMatrix(hv_MatrixColumnSumID);
                    if ((int)(new HTuple(hv_NumClasses.TupleEqual(1))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_EvalClassID, "recall", hv_Recall);
                    }
                    else
                    {
                        HOperatorSet.SetDictTuple(hv_EvalClassID, "mean_recall", hv_Recall);
                        HOperatorSet.SetDictTuple(hv_EvalClassID, "recall_per_class", hv_ClassRecalls);
                    }
                }
                //
                //Calculate F-score.
                if ((int)(hv_CalcFScore) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassFScores.Dispose();
                        HOperatorSet.TupleGenConst(new HTuple(hv_ClassPrecisions.TupleLength()),
                            0.0, out hv_ClassFScores);
                    }
                    hv_SumPrecisionRecall.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SumPrecisionRecall = hv_ClassPrecisions + hv_ClassRecalls;
                    }
                    hv_PositiveIndices.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_PositiveIndices = ((hv_SumPrecisionRecall.TupleNotEqualElem(
                            0.0))).TupleFind(1);
                    }
                    if ((int)((new HTuple(hv_PositiveIndices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_PositiveIndices.TupleNotEqual(
                        new HTuple())))) != 0)
                    {
                        if (hv_ClassFScores == null)
                            hv_ClassFScores = new HTuple();
                        hv_ClassFScores[hv_PositiveIndices] = ((2 * (hv_ClassPrecisions.TupleSelect(
                            hv_PositiveIndices))) * (hv_ClassRecalls.TupleSelect(hv_PositiveIndices))) / (hv_SumPrecisionRecall.TupleSelect(
                            hv_PositiveIndices));
                    }
                    hv_FScore.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FScore = hv_ClassFScores.TupleMean()
                            ;
                    }
                    if ((int)(new HTuple(hv_NumClasses.TupleEqual(1))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_EvalClassID, "f_score", hv_FScore);
                    }
                    else
                    {
                        HOperatorSet.SetDictTuple(hv_EvalClassID, "mean_f_score", hv_FScore);
                        HOperatorSet.SetDictTuple(hv_EvalClassID, "f_score_per_class", hv_ClassFScores);
                    }
                }
                //
                //Set evaluation results for current class ID.
                hv_KeyName.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_KeyName = hv_ClassIDsToEvaluate.TupleSelect(
                        hv_EvalIndex);
                }
                if ((int)(new HTuple(((hv_ClassIDsToEvaluate.TupleSelect(hv_EvalIndex))).TupleNotEqual(
                    "global"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_KeyName = "class_id_" + hv_KeyName;
                            hv_KeyName.Dispose();
                            hv_KeyName = ExpTmpLocalVar_KeyName;
                        }
                    }
                }
                HOperatorSet.SetDictTuple(hv_EvaluationResult, hv_KeyName, hv_EvalClassID);
            }
            //
            hv_CalculateOodMeasuresExists.Dispose();
            HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "calculate_ood_measures",
                out hv_CalculateOodMeasuresExists);
            if ((int)(hv_CalculateOodMeasuresExists) != 0)
            {
                if ((int)(hv_EvalParams.TupleGetDictTuple("calculate_ood_measures")) != 0)
                {
                    calculate_ood_detection_measures(hv_RunningMeasures, hv_EvalParams, hv_EvaluationResult);
                }
            }
            //

            hv_TopKErrorKs.Dispose();
            hv_CalcPrecision.Dispose();
            hv_CalcRecall.Dispose();
            hv_CalcFScore.Dispose();
            hv_CalcAbsoluteConfusionMatrix.Dispose();
            hv_CalcRelativeConfusionMatrix.Dispose();
            hv_Measures.Dispose();
            hv_OODDetectionMeasures.Dispose();
            hv_RegExpTopKError.Dispose();
            hv_M.Dispose();
            hv_ComputeTopKError.Dispose();
            hv_K.Dispose();
            hv_ClassIDs.Dispose();
            hv_KeyExists.Dispose();
            hv_ClassesToEvaluate.Dispose();
            hv_ClassIDsToEvaluate.Dispose();
            hv_ClassNames.Dispose();
            hv_Index.Dispose();
            hv_Position.Dispose();
            hv_ImageIDs.Dispose();
            hv_ImageLabelIDs.Dispose();
            hv_Predictions.Dispose();
            hv_TopKPredictions.Dispose();
            hv_EvalIndex.Dispose();
            hv_CurrentEvalClass.Dispose();
            hv_IndexClass.Dispose();
            hv_EvaluatedSamples.Dispose();
            hv_ConfusionMatrix.Dispose();
            hv_RelativeConfusionMatrix.Dispose();
            hv_EvalClassID.Dispose();
            hv_KIndex.Dispose();
            hv_Indices.Dispose();
            hv_TopKError.Dispose();
            hv_NumClasses.Dispose();
            hv_ClassPrecisions.Dispose();
            hv_MatrixRowSumID.Dispose();
            hv_TruePositive.Dispose();
            hv_SumPredictedClass.Dispose();
            hv_ClassPrecision.Dispose();
            hv_Precision.Dispose();
            hv_ClassRecalls.Dispose();
            hv_MatrixColumnSumID.Dispose();
            hv_SumLabel.Dispose();
            hv_ClassRecall.Dispose();
            hv_Recall.Dispose();
            hv_ClassFScores.Dispose();
            hv_SumPrecisionRecall.Dispose();
            hv_PositiveIndices.Dispose();
            hv_FScore.Dispose();
            hv_KeyName.Dispose();
            hv_CalculateOodMeasuresExists.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_TopKErrorKs.Dispose();
            hv_CalcPrecision.Dispose();
            hv_CalcRecall.Dispose();
            hv_CalcFScore.Dispose();
            hv_CalcAbsoluteConfusionMatrix.Dispose();
            hv_CalcRelativeConfusionMatrix.Dispose();
            hv_Measures.Dispose();
            hv_OODDetectionMeasures.Dispose();
            hv_RegExpTopKError.Dispose();
            hv_M.Dispose();
            hv_ComputeTopKError.Dispose();
            hv_K.Dispose();
            hv_ClassIDs.Dispose();
            hv_KeyExists.Dispose();
            hv_ClassesToEvaluate.Dispose();
            hv_ClassIDsToEvaluate.Dispose();
            hv_ClassNames.Dispose();
            hv_Index.Dispose();
            hv_Position.Dispose();
            hv_ImageIDs.Dispose();
            hv_ImageLabelIDs.Dispose();
            hv_Predictions.Dispose();
            hv_TopKPredictions.Dispose();
            hv_EvalIndex.Dispose();
            hv_CurrentEvalClass.Dispose();
            hv_IndexClass.Dispose();
            hv_EvaluatedSamples.Dispose();
            hv_ConfusionMatrix.Dispose();
            hv_RelativeConfusionMatrix.Dispose();
            hv_EvalClassID.Dispose();
            hv_KIndex.Dispose();
            hv_Indices.Dispose();
            hv_TopKError.Dispose();
            hv_NumClasses.Dispose();
            hv_ClassPrecisions.Dispose();
            hv_MatrixRowSumID.Dispose();
            hv_TruePositive.Dispose();
            hv_SumPredictedClass.Dispose();
            hv_ClassPrecision.Dispose();
            hv_Precision.Dispose();
            hv_ClassRecalls.Dispose();
            hv_MatrixColumnSumID.Dispose();
            hv_SumLabel.Dispose();
            hv_ClassRecall.Dispose();
            hv_Recall.Dispose();
            hv_ClassFScores.Dispose();
            hv_SumPrecisionRecall.Dispose();
            hv_PositiveIndices.Dispose();
            hv_FScore.Dispose();
            hv_KeyName.Dispose();
            hv_CalculateOodMeasuresExists.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Object Detection and Instance Segmentation
    // Short Description: Calculate instance measures based on RunningMeasures. 
    private void calculate_instance_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
        out HTuple hv_EvaluationResult)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_CalcClassAP = new HTuple(), hv_CalcMeanAP = new HTuple();
        HTuple hv_CalcSoAP = new HTuple(), hv_EvalType = new HTuple();
        HTuple hv_InstanceType = new HTuple(), hv_Measures = new HTuple();
        HTuple hv_M = new HTuple(), hv_ClassIDs = new HTuple();
        HTuple hv_NumClasses = new HTuple(), hv_MaxNumDetections = new HTuple();
        HTuple hv_AreaRanges = new HTuple(), hv_IoUThresholds = new HTuple();
        HTuple hv_DetailedEvaluation = new HTuple(), hv_InterpolatePRCurves = new HTuple();
        HTuple hv_KeyExists = new HTuple(), hv_AreaNames = new HTuple();
        HTuple hv_MinAreas = new HTuple(), hv_MaxAreas = new HTuple();
        HTuple hv_RecThreshs = new HTuple(), hv_MDIdx = new HTuple();
        HTuple hv_MaxNum = new HTuple(), hv_MaxNumStr = new HTuple();
        HTuple hv_CurrentRunningMeasures = new HTuple(), hv_PerMaxNumEvaluationResult = new HTuple();
        HTuple hv_AreaIdx = new HTuple(), hv_MinArea = new HTuple();
        HTuple hv_MaxArea = new HTuple(), hv_AreaName = new HTuple();
        HTuple hv_AreaRunningMeasures = new HTuple(), hv_PerClassNumGt = new HTuple();
        HTuple hv_PerClassNumPred = new HTuple(), hv_PerClassConfidence = new HTuple();
        HTuple hv_PerClassNumGtIgnore = new HTuple(), hv_CurrentEvaluationResult = new HTuple();
        HTuple hv_ITIdx = new HTuple(), hv_PerIoUAP = new HTuple();
        HTuple hv_PerIoUSoAP = new HTuple(), hv_PerIoUDetailedEvaluation = new HTuple();
        HTuple hv_ClsIdx = new HTuple(), hv_PerClassDetailedEvaluation = new HTuple();
        HTuple hv_DetectionConfusionMatrix = new HTuple(), hv_PerIoUMeasure = new HTuple();
        HTuple hv_NumImgIDsWithFN = new HTuple(), hv_NumImgIDsWithFP = new HTuple();
        HTuple hv_ImgIDsWithFN = new HTuple(), hv_ImgIDsWithFP = new HTuple();
        HTuple hv_ClassMAPDict = new HTuple(), hv_ClassMSoAPDict = new HTuple();
        HTuple hv_ClassesWithGt = new HTuple(), hv_PerClassMAP = new HTuple();
        HTuple hv_PerIoUMAP = new HTuple(), hv_PerClassMSoAP = new HTuple();
        HTuple hv_PerIoUMSoAP = new HTuple(), hv_PerIoUNumClassesWithTP = new HTuple();
        HTuple hv_PerIoUTP = new HTuple(), hv_PerIoUFN = new HTuple();
        HTuple hv_PerIoUFP = new HTuple(), hv_PerIoUFPClass = new HTuple();
        HTuple hv_PerIoUFPBackground = new HTuple(), hv_PerIoUFPLocalization = new HTuple();
        HTuple hv_PerIoUFPDuplicate = new HTuple(), hv_PerIoUFPMultiple = new HTuple();
        HTuple hv_PerIoUSoAPClass = new HTuple(), hv_PerIoUSoAPLocalization = new HTuple();
        HTuple hv_PerIoUSoAPDuplicate = new HTuple(), hv_PerIoUSoAPMultiple = new HTuple();
        HTuple hv_PerIoUNumClassesWithFPClass = new HTuple(), hv_PerIoUNumClassesWithFPLocalization = new HTuple();
        HTuple hv_PerIoUNumClassesWithFPDuplicate = new HTuple();
        HTuple hv_PerIoUNumClassesWithFPMultiple = new HTuple();
        HTuple hv_ClassAPPerIoU = new HTuple(), hv_ClassSoAPPerIoU = new HTuple();
        HTuple hv_NumGt = new HTuple(), hv_NumGtIgnore = new HTuple();
        HTuple hv_NumPred = new HTuple(), hv_Confidences = new HTuple();
        HTuple hv_SortIdxs = new HTuple(), hv_CurrentClassMeasures = new HTuple();
        HTuple hv_IsTP = new HTuple(), hv_Ignore = new HTuple();
        HTuple hv_NoIgnoreIdxs = new HTuple(), hv_IsFP = new HTuple();
        HTuple hv_AccumulatedIsTP = new HTuple(), hv_AccumulatedIsFP = new HTuple();
        HTuple hv_Recall = new HTuple(), hv_Precision = new HTuple();
        HTuple hv_InterpolatedPrecision = new HTuple(), hv_PIdx = new HTuple();
        HTuple hv_PrecisionAtRecThreshs = new HTuple(), hv_RTIdx = new HTuple();
        HTuple hv_RecQuantile = new HTuple(), hv_AOD = new HTuple();
        HTuple hv_IdxsTP = new HTuple(), hv_IsFPClass = new HTuple();
        HTuple hv_IsFPBackground = new HTuple(), hv_IsFPLocalization = new HTuple();
        HTuple hv_IsFPDuplicate = new HTuple(), hv_IsFPMultiple = new HTuple();
        HTuple hv_NumTP = new HTuple(), hv_NumFP = new HTuple();
        HTuple hv_NumFN = new HTuple(), hv_NumFPClass = new HTuple();
        HTuple hv_NumFPBackground = new HTuple(), hv_NumFPLocalization = new HTuple();
        HTuple hv_NumFPDuplicate = new HTuple(), hv_NumFPMultiple = new HTuple();
        HTuple hv_IndicesWithClassConfusion = new HTuple(), hv_IsFPClassIdxs = new HTuple();
        HTuple hv_ClassIdxsConfused = new HTuple(), hv_Idx = new HTuple();
        HTuple hv_NumConfusedThisIdx = new HTuple(), hv_AODClass = new HTuple();
        HTuple hv_IdxsClass = new HTuple(), hv_ResSoAPClass = new HTuple();
        HTuple hv_AODLocalization = new HTuple(), hv_IdxsLocalization = new HTuple();
        HTuple hv_ResSoAPLocalization = new HTuple(), hv_AODDuplicate = new HTuple();
        HTuple hv_IdxsDuplicate = new HTuple(), hv_ResSoAPDuplicate = new HTuple();
        HTuple hv_AODMultiple = new HTuple(), hv_IdxsMultiple = new HTuple();
        HTuple hv_ResSoAPMultiple = new HTuple(), hv_SoAPIoUIdxsPositive = new HTuple();
        HTuple hv_MeanClassAP = new HTuple(), hv_MeanClassSoAP = new HTuple();
        HTuple hv_MAP = new HTuple(), hv_MSoAP = new HTuple();
        HTuple hv_IoUsWithTP = new HTuple(), hv_MSoAPAll = new HTuple();
        HTuple hv_NumSoAPAll = new HTuple(), hv_IoUsWithFPClass = new HTuple();
        HTuple hv_IoUsWithFPLocalization = new HTuple(), hv_IoUsWithFPDuplicate = new HTuple();
        HTuple hv_IoUsWithFPMultiple = new HTuple();
        // Initialize local and output iconic variables 
        hv_EvaluationResult = new HTuple();
        try
        {
            //
            //This procedure calculates the final summarizing instance measures based on the running measures.
            //
            //Set default values.
            hv_CalcClassAP.Dispose();
            hv_CalcClassAP = 0;
            hv_CalcMeanAP.Dispose();
            hv_CalcMeanAP = 0;
            hv_CalcSoAP.Dispose();
            hv_CalcSoAP = 0;
            //Check which measures are to be calculated.
            hv_EvalType.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvalType);
            hv_InstanceType.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "instance_type", out hv_InstanceType);
            hv_Measures.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
            for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
            {
                if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual("mean_ap"))) != 0)
                {
                    hv_CalcMeanAP.Dispose();
                    hv_CalcMeanAP = 1;
                    //As we need to calculate the class APs anyway, we also write them out.
                    hv_CalcClassAP.Dispose();
                    hv_CalcClassAP = 1;
                }
                else if ((int)((new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                    "soap"))).TupleAnd(new HTuple(hv_InstanceType.TupleEqual("rectangle2")))) != 0)
                {
                    hv_CalcSoAP.Dispose();
                    hv_CalcSoAP = 1;
                }
                else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                    "all"))) != 0)
                {
                    hv_CalcClassAP.Dispose();
                    hv_CalcClassAP = 1;
                    hv_CalcMeanAP.Dispose();
                    hv_CalcMeanAP = 1;
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
                    {
                        hv_CalcSoAP.Dispose();
                        hv_CalcSoAP = 1;
                    }
                }
                else
                {
                    if ((int)((new HTuple(hv_EvalType.TupleEqual("ocr_detection"))).TupleAnd(
                        (new HTuple((new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "recall"))).TupleOr(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "precision"))))).TupleOr(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "f_score"))))) != 0)
                    {
                        hv_CalcMeanAP.Dispose();
                        hv_CalcMeanAP = 1;
                        hv_CalcClassAP.Dispose();
                        hv_CalcClassAP = 1;
                        continue;
                    }
                    else
                    {
                        throw new HalconException("Unknown Instance Measure: " + (hv_Measures.TupleSelect(
                            hv_M)));
                    }
                }
            }
            //*
            //Dependencies of measures:
            //
            //Recall (per-class)       *                   --> AP per class --> mAP
            //Precision (per-class)  /
            //
            //*
            //Initialize output dictionary and get necessary evaluation parameters.
            hv_EvaluationResult.Dispose();
            HOperatorSet.CreateDict(out hv_EvaluationResult);
            hv_ClassIDs.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
            hv_NumClasses.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
            hv_MaxNumDetections.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "max_num_detections", out hv_MaxNumDetections);
            hv_AreaRanges.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "area_ranges", out hv_AreaRanges);
            hv_IoUThresholds.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_IoUThresholds);
            //Check if a detailed evaluation should be done and if PR-curves should be interpolated.
            hv_DetailedEvaluation.Dispose();
            hv_DetailedEvaluation = 0;
            hv_InterpolatePRCurves.Dispose();
            hv_InterpolatePRCurves = 0;
            hv_KeyExists.Dispose();
            HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", (new HTuple("detailed_evaluation")).TupleConcat(
                "interpolate_pr_curves"), out hv_KeyExists);
            if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
            {
                hv_DetailedEvaluation.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "detailed_evaluation", out hv_DetailedEvaluation);
            }
            if ((int)(hv_KeyExists.TupleSelect(1)) != 0)
            {
                hv_InterpolatePRCurves.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "interpolate_pr_curves", out hv_InterpolatePRCurves);
            }
            //
            //Get information about area ranges.
            hv_AreaNames.Dispose();
            HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaNames);
            hv_MinAreas.Dispose();
            HOperatorSet.GetDictTuple(hv_AreaRanges, "min", out hv_MinAreas);
            hv_MaxAreas.Dispose();
            HOperatorSet.GetDictTuple(hv_AreaRanges, "max", out hv_MaxAreas);
            //
            //Equidistant thresholds used to approximate the area under the Precision-Recall curve.
            hv_RecThreshs.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_RecThreshs = HTuple.TupleGenSequence(
                    0.0, 1.0, 0.01);
            }
            //Start with calculation.
            if ((int)((new HTuple(hv_CalcClassAP.TupleOr(hv_CalcMeanAP))).TupleOr(hv_CalcSoAP)) != 0)
            {
                //Loop over maximal number of detections.
                for (hv_MDIdx = 0; (int)hv_MDIdx <= (int)((new HTuple(hv_MaxNumDetections.TupleLength()
                    )) - 1); hv_MDIdx = (int)hv_MDIdx + 1)
                {
                    //
                    //Get corresponding running measures.
                    hv_MaxNum.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxNum = hv_MaxNumDetections.TupleSelect(
                            hv_MDIdx);
                    }
                    hv_MaxNumStr.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxNumStr = "" + hv_MaxNum;
                    }
                    if ((int)(new HTuple(hv_MaxNum.TupleEqual(-1))) != 0)
                    {
                        hv_MaxNumStr.Dispose();
                        hv_MaxNumStr = "all";
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentRunningMeasures.Dispose();
                        HOperatorSet.GetDictTuple(hv_RunningMeasures, "max_num_detections_" + hv_MaxNumStr,
                            out hv_CurrentRunningMeasures);
                    }
                    //
                    //Initialize output dictionary.
                    hv_PerMaxNumEvaluationResult.Dispose();
                    HOperatorSet.CreateDict(out hv_PerMaxNumEvaluationResult);
                    //
                    //Loop over area ranges.
                    for (hv_AreaIdx = 0; (int)hv_AreaIdx <= (int)((new HTuple(hv_AreaNames.TupleLength()
                        )) - 1); hv_AreaIdx = (int)hv_AreaIdx + 1)
                    {
                        //Get area thresholds.
                        hv_MinArea.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MinArea = hv_MinAreas.TupleSelect(
                                hv_AreaIdx);
                        }
                        hv_MaxArea.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MaxArea = hv_MaxAreas.TupleSelect(
                                hv_AreaIdx);
                        }
                        hv_AreaName.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AreaName = hv_AreaNames.TupleSelect(
                                hv_AreaIdx);
                        }
                        //
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AreaRunningMeasures.Dispose();
                            HOperatorSet.GetDictTuple(hv_CurrentRunningMeasures, "area_" + hv_AreaName,
                                out hv_AreaRunningMeasures);
                        }
                        //
                        hv_PerClassNumGt.Dispose();
                        HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_gt", out hv_PerClassNumGt);
                        hv_PerClassNumPred.Dispose();
                        HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_pred", out hv_PerClassNumPred);
                        hv_PerClassConfidence.Dispose();
                        HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "confidence", out hv_PerClassConfidence);
                        hv_PerClassNumGtIgnore.Dispose();
                        HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_gt_ignore", out hv_PerClassNumGtIgnore);
                        //
                        //Initialize output dictionary.
                        hv_CurrentEvaluationResult.Dispose();
                        HOperatorSet.CreateDict(out hv_CurrentEvaluationResult);
                        for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                            )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                        {
                            hv_PerIoUAP.Dispose();
                            HOperatorSet.CreateDict(out hv_PerIoUAP);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "ap_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                    hv_ITIdx)))).TupleRegexpReplace("\\.", "")), hv_PerIoUAP);
                            }
                            if ((int)(hv_CalcSoAP) != 0)
                            {
                                hv_PerIoUSoAP.Dispose();
                                HOperatorSet.CreateDict(out hv_PerIoUSoAP);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "soap_tp_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                        hv_ITIdx)))).TupleRegexpReplace("\\.", "")), hv_PerIoUSoAP);
                                }
                            }
                            if ((int)(hv_DetailedEvaluation) != 0)
                            {
                                //Initialize detailed measures.
                                hv_PerIoUDetailedEvaluation.Dispose();
                                HOperatorSet.CreateDict(out hv_PerIoUDetailedEvaluation);
                                HTuple end_val108 = hv_NumClasses - 1;
                                HTuple step_val108 = 1;
                                for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val108, step_val108); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val108))
                                {
                                    hv_PerClassDetailedEvaluation.Dispose();
                                    HOperatorSet.CreateDict(out hv_PerClassDetailedEvaluation);
                                    //Initialize with zeros in case there is no ground truth for this class.
                                    HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_tp",
                                        0);
                                    HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fn",
                                        0);
                                    HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp",
                                        0);
                                    HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_class",
                                        0);
                                    HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_background",
                                        0);
                                    HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_duplicate",
                                        0);
                                    HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_localization",
                                        0);
                                    HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_multiple",
                                        0);
                                    if ((int)(hv_CalcSoAP) != 0)
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_class",
                                            -1);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_duplicate",
                                            -1);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_localization",
                                            -1);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_multiple",
                                            -1);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "class_" + (hv_ClassIDs.TupleSelect(
                                            hv_ClsIdx)), hv_PerClassDetailedEvaluation);
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_DetectionConfusionMatrix.Dispose();
                                    HOperatorSet.CreateMatrix(hv_NumClasses + 1, hv_NumClasses + 4, 0, out hv_DetectionConfusionMatrix);
                                }
                                HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "detection_confusion_matrix",
                                    hv_DetectionConfusionMatrix);
                                //
                                //Get and set image IDs with false negatives and false positives.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUMeasure.Dispose();
                                    HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                        hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUMeasure);
                                }
                                //Get image IDs with false negatives and false positives, respectively.
                                hv_NumImgIDsWithFN.Dispose();
                                HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_negatives",
                                    out hv_NumImgIDsWithFN);
                                hv_NumImgIDsWithFP.Dispose();
                                HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_positives",
                                    out hv_NumImgIDsWithFP);
                                hv_ImgIDsWithFN.Dispose();
                                HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_negatives",
                                    out hv_ImgIDsWithFN);
                                hv_ImgIDsWithFP.Dispose();
                                HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_positives",
                                    out hv_ImgIDsWithFP);
                                //Set in current output.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "image_ids_with_false_negatives",
                                        hv_ImgIDsWithFN.TupleSelectRange(0, hv_NumImgIDsWithFN - 1));
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "image_ids_with_false_positives",
                                        hv_ImgIDsWithFP.TupleSelectRange(0, hv_NumImgIDsWithFP - 1));
                                }
                                //
                                //Set output for this IoU.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "detailed_evaluation_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                        hv_ITIdx)))).TupleRegexpReplace("\\.", "")), hv_PerIoUDetailedEvaluation);
                                }
                            }
                        }
                        hv_ClassMAPDict.Dispose();
                        HOperatorSet.CreateDict(out hv_ClassMAPDict);
                        HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_iou_ap",
                            hv_ClassMAPDict);
                        if ((int)(hv_CalcSoAP) != 0)
                        {
                            hv_ClassMSoAPDict.Dispose();
                            HOperatorSet.CreateDict(out hv_ClassMSoAPDict);
                            HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_iou_soap_tp",
                                hv_ClassMSoAPDict);
                        }
                        //
                        //Check which classes have ground truth annotations.
                        hv_ClassesWithGt.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassesWithGt = ((((hv_PerClassNumGt - hv_PerClassNumGtIgnore)).TupleGreaterElem(
                                0))).TupleFind(1);
                        }
                        if ((int)(new HTuple(hv_ClassesWithGt.TupleEqual(-1))) != 0)
                        {
                            hv_ClassesWithGt.Dispose();
                            hv_ClassesWithGt = new HTuple();
                        }
                        //
                        //Initialize PerClassMAP, i.e. mean average precision over IoU-thresholds per class.
                        hv_PerClassMAP.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PerClassMAP = HTuple.TupleGenConst(
                                hv_NumClasses, -1.0);
                        }
                        //
                        //Initialize PerIoUMAP, i.e. mean average precision over classes per IoU-threshold.
                        hv_PerIoUMAP.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PerIoUMAP = HTuple.TupleGenConst(
                                new HTuple(hv_IoUThresholds.TupleLength()), 0.0);
                        }
                        //
                        if ((int)(hv_CalcSoAP) != 0)
                        {
                            //Initialize PerClassMSoAP, i.e. mean SoAP over IoU-thresholds per class.
                            hv_PerClassMSoAP.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PerClassMSoAP = HTuple.TupleGenConst(
                                    hv_NumClasses, -1.0);
                            }
                            //Initialize PerIoUMSoAP, i.e. mean SoAP over classes per IoU-threshold.
                            hv_PerIoUMSoAP.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PerIoUMSoAP = HTuple.TupleGenConst(
                                    new HTuple(hv_IoUThresholds.TupleLength()), 0.0);
                            }
                            //Initialize PerIoUNumClassesWithTP to store the class-indices where true positives occurred.
                            hv_PerIoUNumClassesWithTP.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PerIoUNumClassesWithTP = HTuple.TupleGenConst(
                                    new HTuple(hv_IoUThresholds.TupleLength()), 0);
                            }
                        }
                        //
                        if ((int)(hv_DetailedEvaluation) != 0)
                        {
                            //Initialize overall num_fn, num_tp, ...
                            hv_PerIoUTP.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PerIoUTP = HTuple.TupleGenConst(
                                    new HTuple(hv_IoUThresholds.TupleLength()), 0);
                            }
                            hv_PerIoUFN.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PerIoUFN = HTuple.TupleGenConst(
                                    new HTuple(hv_IoUThresholds.TupleLength()), 0);
                            }
                            hv_PerIoUFP.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PerIoUFP = HTuple.TupleGenConst(
                                    new HTuple(hv_IoUThresholds.TupleLength()), 0);
                            }
                            hv_PerIoUFPClass.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PerIoUFPClass = HTuple.TupleGenConst(
                                    new HTuple(hv_IoUThresholds.TupleLength()), 0);
                            }
                            hv_PerIoUFPBackground.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PerIoUFPBackground = HTuple.TupleGenConst(
                                    new HTuple(hv_IoUThresholds.TupleLength()), 0);
                            }
                            hv_PerIoUFPLocalization.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PerIoUFPLocalization = HTuple.TupleGenConst(
                                    new HTuple(hv_IoUThresholds.TupleLength()), 0);
                            }
                            hv_PerIoUFPDuplicate.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PerIoUFPDuplicate = HTuple.TupleGenConst(
                                    new HTuple(hv_IoUThresholds.TupleLength()), 0);
                            }
                            hv_PerIoUFPMultiple.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PerIoUFPMultiple = HTuple.TupleGenConst(
                                    new HTuple(hv_IoUThresholds.TupleLength()), 0);
                            }
                            if ((int)(hv_CalcSoAP) != 0)
                            {
                                hv_PerIoUSoAPClass.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUSoAPClass = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), -1);
                                }
                                hv_PerIoUSoAPLocalization.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUSoAPLocalization = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), -1);
                                }
                                hv_PerIoUSoAPDuplicate.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUSoAPDuplicate = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), -1);
                                }
                                hv_PerIoUSoAPMultiple.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUSoAPMultiple = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), -1);
                                }
                                hv_PerIoUNumClassesWithFPClass.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUNumClassesWithFPClass = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUNumClassesWithFPLocalization.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUNumClassesWithFPLocalization = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUNumClassesWithFPDuplicate.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUNumClassesWithFPDuplicate = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUNumClassesWithFPMultiple.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUNumClassesWithFPMultiple = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                            }
                        }
                        //Loop over all classes.
                        HTuple end_val195 = hv_NumClasses - 1;
                        HTuple step_val195 = 1;
                        for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val195, step_val195); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val195))
                        {
                            //
                            //Initialize per-class AP per IoU-threshold (only for one class).
                            hv_ClassAPPerIoU.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassAPPerIoU = HTuple.TupleGenConst(
                                    new HTuple(hv_IoUThresholds.TupleLength()), -1.0);
                            }
                            //
                            if ((int)(hv_CalcSoAP) != 0)
                            {
                                hv_ClassSoAPPerIoU.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ClassSoAPPerIoU = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), -1.0);
                                }
                            }
                            //Get results for this class.
                            hv_NumGt.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_NumGt = hv_PerClassNumGt.TupleSelect(
                                    hv_ClsIdx);
                            }
                            hv_NumGtIgnore.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_NumGtIgnore = hv_PerClassNumGtIgnore.TupleSelect(
                                    hv_ClsIdx);
                            }
                            if ((int)(new HTuple(((hv_NumGt - hv_NumGtIgnore)).TupleGreater(0))) != 0)
                            {
                                hv_NumPred.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_NumPred = hv_PerClassNumPred.TupleSelect(
                                        hv_ClsIdx);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Confidences.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerClassConfidence, "class_" + (hv_ClassIDs.TupleSelect(
                                        hv_ClsIdx)), out hv_Confidences);
                                }
                                //
                                //Sort the confidences in descending order and
                                //only take the first NumPred ones due to block allocation.
                                hv_SortIdxs.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_SortIdxs = ((-(hv_Confidences.TupleSelectRange(
                                        0, hv_NumPred - 1)))).TupleSortIndex();
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Confidences = hv_Confidences.TupleSelect(
                                            hv_SortIdxs);
                                        hv_Confidences.Dispose();
                                        hv_Confidences = ExpTmpLocalVar_Confidences;
                                    }
                                }
                            }
                            //
                            //Loop over IoU thresholds.
                            for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                            {
                                //
                                //Check if there are ground truth labels for this class.
                                if ((int)(new HTuple(((hv_NumGt - hv_NumGtIgnore)).TupleGreater(0))) != 0)
                                {
                                    //
                                    //Get results for this class and IoU-threshold.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUMeasure.Dispose();
                                        HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUMeasure);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_CurrentClassMeasures.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "class_" + (hv_ClassIDs.TupleSelect(
                                            hv_ClsIdx)), out hv_CurrentClassMeasures);
                                    }
                                    hv_IsTP.Dispose();
                                    HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_tp", out hv_IsTP);
                                    hv_Ignore.Dispose();
                                    HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "ignore", out hv_Ignore);
                                    //
                                    //Sort the arrays IsTP and Ignore according to the confidence values.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_IsTP = hv_IsTP.TupleSelect(
                                                hv_SortIdxs);
                                            hv_IsTP.Dispose();
                                            hv_IsTP = ExpTmpLocalVar_IsTP;
                                        }
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_Ignore = hv_Ignore.TupleSelect(
                                                hv_SortIdxs);
                                            hv_Ignore.Dispose();
                                            hv_Ignore = ExpTmpLocalVar_Ignore;
                                        }
                                    }
                                    //
                                    //Sort out the ignored results.
                                    if ((int)(new HTuple((new HTuple(hv_IsTP.TupleLength())).TupleGreater(
                                        0))) != 0)
                                    {
                                        hv_NoIgnoreIdxs.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_NoIgnoreIdxs = hv_Ignore.TupleFind(
                                                0);
                                        }
                                        if ((int)(new HTuple(hv_NoIgnoreIdxs.TupleNotEqual(-1))) != 0)
                                        {
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                {
                                                    HTuple
                                                      ExpTmpLocalVar_IsTP = hv_IsTP.TupleSelect(
                                                        hv_NoIgnoreIdxs);
                                                    hv_IsTP.Dispose();
                                                    hv_IsTP = ExpTmpLocalVar_IsTP;
                                                }
                                            }
                                            hv_IsFP.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_IsFP = hv_IsTP.TupleNot()
                                                    ;
                                            }
                                        }
                                        else
                                        {
                                            hv_IsTP.Dispose();
                                            hv_IsTP = new HTuple();
                                            hv_IsFP.Dispose();
                                            hv_IsFP = new HTuple();
                                        }
                                    }
                                    else
                                    {
                                        hv_IsFP.Dispose();
                                        hv_IsFP = new HTuple();
                                    }
                                    //
                                    //Accumulate IsTP and IsFP.
                                    hv_AccumulatedIsTP.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_AccumulatedIsTP = hv_IsTP.TupleCumul()
                                            ;
                                    }
                                    hv_AccumulatedIsFP.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_AccumulatedIsFP = hv_IsFP.TupleCumul()
                                            ;
                                    }
                                    //
                                    //Compute recall.
                                    //The recall is computed with respect to all ground truth instances,
                                    //independent of MaxNum.
                                    hv_Recall.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Recall = (hv_AccumulatedIsTP.TupleReal()
                                            ) / (hv_NumGt - hv_NumGtIgnore);
                                    }
                                    //
                                    //Compute precision.
                                    hv_Precision.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Precision = (hv_AccumulatedIsTP.TupleReal()
                                            ) / (hv_AccumulatedIsTP + hv_AccumulatedIsFP);
                                    }
                                    //
                                    //(Optionally) smooth precision-recall curve.
                                    hv_InterpolatedPrecision.Dispose();
                                    hv_InterpolatedPrecision = new HTuple(hv_Precision);
                                    if ((int)(hv_InterpolatePRCurves) != 0)
                                    {
                                        HTuple end_val261 = 0;
                                        HTuple step_val261 = -1;
                                        for (hv_PIdx = hv_NumPred - 2; hv_PIdx.Continue(end_val261, step_val261); hv_PIdx = hv_PIdx.TupleAdd(step_val261))
                                        {
                                            if (hv_InterpolatedPrecision == null)
                                                hv_InterpolatedPrecision = new HTuple();
                                            hv_InterpolatedPrecision[hv_PIdx] = ((hv_InterpolatedPrecision.TupleSelect(
                                                hv_PIdx))).TupleMax2(hv_InterpolatedPrecision.TupleSelect(
                                                hv_PIdx + 1));
                                        }
                                    }
                                    //Compute approximated area under the Precision-Recall curve using Recall-Thresholds.
                                    hv_PrecisionAtRecThreshs.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PrecisionAtRecThreshs = HTuple.TupleGenConst(
                                            new HTuple(hv_RecThreshs.TupleLength()), 0.0);
                                    }
                                    for (hv_RTIdx = 0; (int)hv_RTIdx <= (int)((new HTuple(hv_RecThreshs.TupleLength()
                                        )) - 1); hv_RTIdx = (int)hv_RTIdx + 1)
                                    {
                                        hv_RecQuantile.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_RecQuantile = ((hv_Recall.TupleGreaterEqualElem(
                                                hv_RecThreshs.TupleSelect(hv_RTIdx)))).TupleFindFirst(1);
                                        }
                                        if ((int)(new HTuple(hv_RecQuantile.TupleGreater(-1))) != 0)
                                        {
                                            if (hv_PrecisionAtRecThreshs == null)
                                                hv_PrecisionAtRecThreshs = new HTuple();
                                            hv_PrecisionAtRecThreshs[hv_RTIdx] = hv_InterpolatedPrecision.TupleSelect(
                                                hv_RecQuantile);
                                        }
                                    }
                                    //
                                    //Calculate AP as mean of precision at equidistant recall values.
                                    if (hv_ClassAPPerIoU == null)
                                        hv_ClassAPPerIoU = new HTuple();
                                    hv_ClassAPPerIoU[hv_ITIdx] = hv_PrecisionAtRecThreshs.TupleMean()
                                        ;
                                    //
                                    //Accumulate AP over classes.
                                    if (hv_PerIoUMAP == null)
                                        hv_PerIoUMAP = new HTuple();
                                    hv_PerIoUMAP[hv_ITIdx] = (hv_PerIoUMAP.TupleSelect(hv_ITIdx)) + (hv_ClassAPPerIoU.TupleSelect(
                                        hv_ITIdx));
                                    //
                                    if ((int)(hv_CalcSoAP) != 0)
                                    {
                                        //Calculate SoAP out of the mean over absolute orientation differences.
                                        hv_AOD.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff",
                                            out hv_AOD);
                                        hv_IdxsTP.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_IdxsTP = hv_IsTP.TupleFind(
                                                1);
                                        }
                                        if ((int)((new HTuple((new HTuple(hv_IdxsTP.TupleLength())).TupleGreater(
                                            0))).TupleAnd(new HTuple(hv_IdxsTP.TupleNotEqual(-1)))) != 0)
                                        {
                                            if (hv_ClassSoAPPerIoU == null)
                                                hv_ClassSoAPPerIoU = new HTuple();
                                            hv_ClassSoAPPerIoU[hv_ITIdx] = 1.0 - ((((hv_AOD.TupleSelect(hv_SortIdxs.TupleSelect(
                                                hv_NoIgnoreIdxs.TupleSelect(hv_IdxsTP))))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                ));
                                            //Accumulate SoAP over classes.
                                            if (hv_PerIoUMSoAP == null)
                                                hv_PerIoUMSoAP = new HTuple();
                                            hv_PerIoUMSoAP[hv_ITIdx] = (hv_PerIoUMSoAP.TupleSelect(hv_ITIdx)) + (hv_ClassSoAPPerIoU.TupleSelect(
                                                hv_ITIdx));
                                        }
                                        //Update PerIoUNumClassesWithTP.
                                        if ((int)(new HTuple((new HTuple(hv_AccumulatedIsTP.TupleLength()
                                            )).TupleGreater(0))) != 0)
                                        {
                                            if (hv_PerIoUNumClassesWithTP == null)
                                                hv_PerIoUNumClassesWithTP = new HTuple();
                                            hv_PerIoUNumClassesWithTP[hv_ITIdx] = (hv_PerIoUNumClassesWithTP.TupleSelect(
                                                hv_ITIdx)) + (((hv_AccumulatedIsTP.TupleSelect((new HTuple(hv_AccumulatedIsTP.TupleLength()
                                                )) - 1))).TupleGreaterElem(0));
                                        }
                                    }
                                    //
                                    if ((int)(hv_DetailedEvaluation) != 0)
                                    {
                                        //Summarize detailed evaluation running measures, set matrix-values and update overall detailed measures.
                                        //
                                        //Get the necessary running measures.
                                        hv_IsFPClass.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_class",
                                            out hv_IsFPClass);
                                        hv_IsFPBackground.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_background",
                                            out hv_IsFPBackground);
                                        hv_IsFPLocalization.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_localization",
                                            out hv_IsFPLocalization);
                                        hv_IsFPDuplicate.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_duplicate",
                                            out hv_IsFPDuplicate);
                                        hv_IsFPMultiple.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_multiple",
                                            out hv_IsFPMultiple);
                                        //
                                        //We use the values with maximal recall,
                                        //in case a higher precision is desired, increase 'min_confidence'.
                                        if ((int)(new HTuple((new HTuple(hv_AccumulatedIsTP.TupleLength()
                                            )).TupleGreater(0))) != 0)
                                        {
                                            hv_NumTP.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumTP = hv_AccumulatedIsTP.TupleSelect(
                                                    (new HTuple(hv_AccumulatedIsTP.TupleLength())) - 1);
                                            }
                                        }
                                        else
                                        {
                                            hv_NumTP.Dispose();
                                            hv_NumTP = 0;
                                        }
                                        if ((int)(new HTuple((new HTuple(hv_AccumulatedIsFP.TupleLength()
                                            )).TupleGreater(0))) != 0)
                                        {
                                            hv_NumFP.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFP = hv_AccumulatedIsFP.TupleSelect(
                                                    (new HTuple(hv_AccumulatedIsFP.TupleLength())) - 1);
                                            }
                                        }
                                        else
                                        {
                                            hv_NumFP.Dispose();
                                            hv_NumFP = 0;
                                        }
                                        hv_NumFN.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_NumFN = (hv_NumGt - hv_NumGtIgnore) - hv_NumTP;
                                        }
                                        hv_NumFPClass.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_NumFPClass = ((((hv_IsFPClass.TupleSelect(
                                                hv_SortIdxs))).TupleGreaterElem(-1))).TupleSum();
                                        }
                                        hv_NumFPBackground.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_NumFPBackground = ((((hv_IsFPBackground.TupleSelect(
                                                hv_SortIdxs))).TupleGreaterElem(0))).TupleSum();
                                        }
                                        hv_NumFPLocalization.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_NumFPLocalization = ((((hv_IsFPLocalization.TupleSelect(
                                                hv_SortIdxs))).TupleGreaterElem(0))).TupleSum();
                                        }
                                        hv_NumFPDuplicate.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_NumFPDuplicate = ((((hv_IsFPDuplicate.TupleSelect(
                                                hv_SortIdxs))).TupleGreaterElem(0))).TupleSum();
                                        }
                                        hv_NumFPMultiple.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_NumFPMultiple = ((((hv_IsFPMultiple.TupleSelect(
                                                hv_SortIdxs))).TupleGreaterElem(0))).TupleSum();
                                        }
                                        if ((int)(new HTuple((new HTuple(hv_SortIdxs.TupleLength())).TupleEqual(
                                            0))) != 0)
                                        {
                                            hv_NumFPClass.Dispose();
                                            hv_NumFPClass = 0;
                                            hv_NumFPBackground.Dispose();
                                            hv_NumFPBackground = 0;
                                            hv_NumFPLocalization.Dispose();
                                            hv_NumFPLocalization = 0;
                                            hv_NumFPDuplicate.Dispose();
                                            hv_NumFPDuplicate = 0;
                                            hv_NumFPMultiple.Dispose();
                                            hv_NumFPMultiple = 0;
                                        }
                                        //Consistency checks.
                                        if ((int)(new HTuple(((((((((((((((((hv_NumTP.TupleConcat(hv_NumFN))).TupleConcat(
                                            hv_NumFP))).TupleConcat(hv_NumFPClass))).TupleConcat(hv_NumFPBackground))).TupleConcat(
                                            hv_NumFPLocalization))).TupleConcat(hv_NumFPDuplicate))).TupleConcat(
                                            hv_NumFPMultiple))).TupleMin())).TupleLess(0))) != 0)
                                        {
                                            throw new HalconException("Fatal error while calculating instance measures.");
                                        }
                                        if ((int)(new HTuple(hv_NumFP.TupleNotEqual((((hv_NumFPClass + hv_NumFPBackground) + hv_NumFPLocalization) + hv_NumFPDuplicate) + hv_NumFPMultiple))) != 0)
                                        {
                                            throw new HalconException("Fatal error while calculating instance measures.");
                                        }
                                        //
                                        //Set per-class measures.
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_PerIoUDetailedEvaluation.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "detailed_evaluation_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                                hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUDetailedEvaluation);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_PerClassDetailedEvaluation.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerIoUDetailedEvaluation, "class_" + (hv_ClassIDs.TupleSelect(
                                                hv_ClsIdx)), out hv_PerClassDetailedEvaluation);
                                        }
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_tp",
                                            hv_NumTP);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fn",
                                            hv_NumFN);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp",
                                            hv_NumFP);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_class",
                                            hv_NumFPClass);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_background",
                                            hv_NumFPBackground);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_duplicate",
                                            hv_NumFPDuplicate);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_localization",
                                            hv_NumFPLocalization);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_multiple",
                                            hv_NumFPMultiple);
                                        //
                                        //Set detection confusion matrix values.
                                        hv_DetectionConfusionMatrix.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerIoUDetailedEvaluation, "detection_confusion_matrix",
                                            out hv_DetectionConfusionMatrix);
                                        HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                            hv_ClsIdx, hv_NumTP);
                                        HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_NumClasses,
                                            hv_ClsIdx, hv_NumFN);
                                        HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                            hv_NumClasses, hv_NumFPBackground);
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                hv_NumClasses + 1, hv_NumFPLocalization);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                hv_NumClasses + 2, hv_NumFPDuplicate);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                hv_NumClasses + 3, hv_NumFPMultiple);
                                        }
                                        //
                                        //Go over IsFPClass and set confusions in matrix.
                                        hv_IndicesWithClassConfusion.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_IndicesWithClassConfusion = ((((hv_IsFPClass.TupleSelect(
                                                hv_SortIdxs))).TupleGreaterElem(-1))).TupleFind(1);
                                        }
                                        hv_IsFPClassIdxs.Dispose();
                                        hv_IsFPClassIdxs = new HTuple();
                                        if ((int)(new HTuple(hv_IndicesWithClassConfusion.TupleGreater(
                                            -1))) != 0)
                                        {
                                            hv_IsFPClassIdxs.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_IsFPClassIdxs = hv_IsFPClass.TupleSelect(
                                                    hv_SortIdxs.TupleSelect(hv_IndicesWithClassConfusion));
                                            }
                                        }
                                        hv_ClassIdxsConfused.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_ClassIdxsConfused = ((hv_IsFPClassIdxs.TupleSort()
                                                )).TupleUniq();
                                        }
                                        for (hv_Idx = 0; (int)hv_Idx <= (int)((new HTuple(hv_ClassIdxsConfused.TupleLength()
                                            )) - 1); hv_Idx = (int)hv_Idx + 1)
                                        {
                                            hv_NumConfusedThisIdx.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumConfusedThisIdx = ((((hv_IsFPClassIdxs.TupleFind(
                                                    hv_ClassIdxsConfused.TupleSelect(hv_Idx)))).TupleGreaterElem(
                                                    -1))).TupleSum();
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                    hv_ClassIdxsConfused.TupleSelect(hv_Idx), hv_NumConfusedThisIdx);
                                            }
                                        }
                                        //
                                        //Update overall measures.
                                        if (hv_PerIoUFN == null)
                                            hv_PerIoUFN = new HTuple();
                                        hv_PerIoUFN[hv_ITIdx] = (hv_PerIoUFN.TupleSelect(hv_ITIdx)) + hv_NumFN;
                                        if (hv_PerIoUTP == null)
                                            hv_PerIoUTP = new HTuple();
                                        hv_PerIoUTP[hv_ITIdx] = (hv_PerIoUTP.TupleSelect(hv_ITIdx)) + hv_NumTP;
                                        if (hv_PerIoUFP == null)
                                            hv_PerIoUFP = new HTuple();
                                        hv_PerIoUFP[hv_ITIdx] = (hv_PerIoUFP.TupleSelect(hv_ITIdx)) + hv_NumFP;
                                        if (hv_PerIoUFPClass == null)
                                            hv_PerIoUFPClass = new HTuple();
                                        hv_PerIoUFPClass[hv_ITIdx] = (hv_PerIoUFPClass.TupleSelect(hv_ITIdx)) + hv_NumFPClass;
                                        if (hv_PerIoUFPBackground == null)
                                            hv_PerIoUFPBackground = new HTuple();
                                        hv_PerIoUFPBackground[hv_ITIdx] = (hv_PerIoUFPBackground.TupleSelect(
                                            hv_ITIdx)) + hv_NumFPBackground;
                                        if (hv_PerIoUFPLocalization == null)
                                            hv_PerIoUFPLocalization = new HTuple();
                                        hv_PerIoUFPLocalization[hv_ITIdx] = (hv_PerIoUFPLocalization.TupleSelect(
                                            hv_ITIdx)) + hv_NumFPLocalization;
                                        if (hv_PerIoUFPDuplicate == null)
                                            hv_PerIoUFPDuplicate = new HTuple();
                                        hv_PerIoUFPDuplicate[hv_ITIdx] = (hv_PerIoUFPDuplicate.TupleSelect(
                                            hv_ITIdx)) + hv_NumFPDuplicate;
                                        if (hv_PerIoUFPMultiple == null)
                                            hv_PerIoUFPMultiple = new HTuple();
                                        hv_PerIoUFPMultiple[hv_ITIdx] = (hv_PerIoUFPMultiple.TupleSelect(
                                            hv_ITIdx)) + hv_NumFPMultiple;
                                        if ((int)(hv_CalcSoAP) != 0)
                                        {
                                            //Calculate and update absolute difference of orientation for class false positives.
                                            hv_AODClass.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff_class",
                                                out hv_AODClass);
                                            hv_IdxsClass.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_IdxsClass = ((hv_AODClass.TupleGreaterElem(
                                                    -1))).TupleFind(1);
                                            }
                                            if ((int)(new HTuple(hv_IdxsClass.TupleNotEqual(-1))) != 0)
                                            {
                                                hv_ResSoAPClass.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_ResSoAPClass = 1.0 - ((((hv_AODClass.TupleSelect(
                                                        hv_IdxsClass))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                        ));
                                                }
                                                HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation,
                                                    "soap_fp_class", hv_ResSoAPClass);
                                                //Update mean over classes.
                                                if (hv_PerIoUNumClassesWithFPClass == null)
                                                    hv_PerIoUNumClassesWithFPClass = new HTuple();
                                                hv_PerIoUNumClassesWithFPClass[hv_ITIdx] = (hv_PerIoUNumClassesWithFPClass.TupleSelect(
                                                    hv_ITIdx)) + 1;
                                                if ((int)(new HTuple(((hv_PerIoUSoAPClass.TupleSelect(hv_ITIdx))).TupleEqual(
                                                    -1))) != 0)
                                                {
                                                    if (hv_PerIoUSoAPClass == null)
                                                        hv_PerIoUSoAPClass = new HTuple();
                                                    hv_PerIoUSoAPClass[hv_ITIdx] = hv_ResSoAPClass;
                                                }
                                                else
                                                {
                                                    if (hv_PerIoUSoAPClass == null)
                                                        hv_PerIoUSoAPClass = new HTuple();
                                                    hv_PerIoUSoAPClass[hv_ITIdx] = (hv_PerIoUSoAPClass.TupleSelect(
                                                        hv_ITIdx)) + hv_ResSoAPClass;
                                                }
                                            }
                                            //Calculate and update absolute difference of orientation for localization false positives.
                                            hv_AODLocalization.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff_localization",
                                                out hv_AODLocalization);
                                            hv_IdxsLocalization.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_IdxsLocalization = ((hv_AODLocalization.TupleGreaterElem(
                                                    -1))).TupleFind(1);
                                            }
                                            if ((int)(new HTuple(hv_IdxsLocalization.TupleNotEqual(-1))) != 0)
                                            {
                                                hv_ResSoAPLocalization.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_ResSoAPLocalization = 1.0 - ((((hv_AODLocalization.TupleSelect(
                                                        hv_IdxsLocalization))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                        ));
                                                }
                                                HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation,
                                                    "soap_fp_localization", hv_ResSoAPLocalization);
                                                //Update mean over classes.
                                                if (hv_PerIoUNumClassesWithFPLocalization == null)
                                                    hv_PerIoUNumClassesWithFPLocalization = new HTuple();
                                                hv_PerIoUNumClassesWithFPLocalization[hv_ITIdx] = (hv_PerIoUNumClassesWithFPLocalization.TupleSelect(
                                                    hv_ITIdx)) + 1;
                                                if ((int)(new HTuple(((hv_PerIoUSoAPLocalization.TupleSelect(
                                                    hv_ITIdx))).TupleEqual(-1))) != 0)
                                                {
                                                    if (hv_PerIoUSoAPLocalization == null)
                                                        hv_PerIoUSoAPLocalization = new HTuple();
                                                    hv_PerIoUSoAPLocalization[hv_ITIdx] = hv_ResSoAPLocalization;
                                                }
                                                else
                                                {
                                                    if (hv_PerIoUSoAPLocalization == null)
                                                        hv_PerIoUSoAPLocalization = new HTuple();
                                                    hv_PerIoUSoAPLocalization[hv_ITIdx] = (hv_PerIoUSoAPLocalization.TupleSelect(
                                                        hv_ITIdx)) + hv_ResSoAPLocalization;
                                                }
                                            }
                                            //Calculate and update absolute difference of orientation for class false positives.
                                            hv_AODDuplicate.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff_duplicate",
                                                out hv_AODDuplicate);
                                            hv_IdxsDuplicate.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_IdxsDuplicate = ((hv_AODDuplicate.TupleGreaterElem(
                                                    -1))).TupleFind(1);
                                            }
                                            if ((int)(new HTuple(hv_IdxsDuplicate.TupleNotEqual(-1))) != 0)
                                            {
                                                hv_ResSoAPDuplicate.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_ResSoAPDuplicate = 1.0 - ((((hv_AODDuplicate.TupleSelect(
                                                        hv_IdxsDuplicate))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                        ));
                                                }
                                                HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation,
                                                    "soap_fp_duplicate", hv_ResSoAPDuplicate);
                                                //Update mean over classes.
                                                if (hv_PerIoUNumClassesWithFPDuplicate == null)
                                                    hv_PerIoUNumClassesWithFPDuplicate = new HTuple();
                                                hv_PerIoUNumClassesWithFPDuplicate[hv_ITIdx] = (hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(
                                                    hv_ITIdx)) + 1;
                                                if ((int)(new HTuple(((hv_PerIoUSoAPDuplicate.TupleSelect(
                                                    hv_ITIdx))).TupleEqual(-1))) != 0)
                                                {
                                                    if (hv_PerIoUSoAPDuplicate == null)
                                                        hv_PerIoUSoAPDuplicate = new HTuple();
                                                    hv_PerIoUSoAPDuplicate[hv_ITIdx] = hv_ResSoAPDuplicate;
                                                }
                                                else
                                                {
                                                    if (hv_PerIoUSoAPDuplicate == null)
                                                        hv_PerIoUSoAPDuplicate = new HTuple();
                                                    hv_PerIoUSoAPDuplicate[hv_ITIdx] = (hv_PerIoUSoAPDuplicate.TupleSelect(
                                                        hv_ITIdx)) + hv_ResSoAPDuplicate;
                                                }
                                            }
                                            //Calculate and update absolute difference of orientation for multiple false positives.
                                            hv_AODMultiple.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff_multiple",
                                                out hv_AODMultiple);
                                            hv_IdxsMultiple.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_IdxsMultiple = ((hv_AODMultiple.TupleGreaterElem(
                                                    -1))).TupleFind(1);
                                            }
                                            if ((int)(new HTuple(hv_IdxsMultiple.TupleNotEqual(-1))) != 0)
                                            {
                                                hv_ResSoAPMultiple.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_ResSoAPMultiple = 1.0 - ((((hv_AODMultiple.TupleSelect(
                                                        hv_IdxsMultiple))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                        ));
                                                }
                                                HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation,
                                                    "soap_fp_multiple", hv_ResSoAPMultiple);
                                                //Update mean over classes.
                                                if (hv_PerIoUNumClassesWithFPMultiple == null)
                                                    hv_PerIoUNumClassesWithFPMultiple = new HTuple();
                                                hv_PerIoUNumClassesWithFPMultiple[hv_ITIdx] = (hv_PerIoUNumClassesWithFPMultiple.TupleSelect(
                                                    hv_ITIdx)) + 1;
                                                if ((int)(new HTuple(((hv_PerIoUSoAPMultiple.TupleSelect(
                                                    hv_ITIdx))).TupleEqual(-1))) != 0)
                                                {
                                                    if (hv_PerIoUSoAPMultiple == null)
                                                        hv_PerIoUSoAPMultiple = new HTuple();
                                                    hv_PerIoUSoAPMultiple[hv_ITIdx] = hv_ResSoAPMultiple;
                                                }
                                                else
                                                {
                                                    if (hv_PerIoUSoAPMultiple == null)
                                                        hv_PerIoUSoAPMultiple = new HTuple();
                                                    hv_PerIoUSoAPMultiple[hv_ITIdx] = (hv_PerIoUSoAPMultiple.TupleSelect(
                                                        hv_ITIdx)) + hv_ResSoAPMultiple;
                                                }
                                            }
                                        }
                                    }
                                }
                                //
                                //Write to output.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUAP.Dispose();
                                    HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "ap_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                        hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUAP);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_PerIoUAP, "class_" + (hv_ClassIDs.TupleSelect(
                                        hv_ClsIdx)), hv_ClassAPPerIoU.TupleSelect(hv_ITIdx));
                                }
                                if ((int)(hv_CalcSoAP) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUSoAP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "soap_tp_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUSoAP);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUSoAP, "class_" + (hv_ClassIDs.TupleSelect(
                                            hv_ClsIdx)), hv_ClassSoAPPerIoU.TupleSelect(hv_ITIdx));
                                    }
                                }
                            }
                            //
                            //Class mAP is the mean over IoU-thresholds.
                            if (hv_PerClassMAP == null)
                                hv_PerClassMAP = new HTuple();
                            hv_PerClassMAP[hv_ClsIdx] = hv_ClassAPPerIoU.TupleMean();
                            hv_ClassMAPDict.Dispose();
                            HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "mean_iou_ap",
                                out hv_ClassMAPDict);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_ClassMAPDict, "class_" + (hv_ClassIDs.TupleSelect(
                                    hv_ClsIdx)), hv_PerClassMAP.TupleSelect(hv_ClsIdx));
                            }
                            if ((int)(hv_CalcSoAP) != 0)
                            {
                                //ClassMSoAP is the mean over IoU-thresholds.
                                hv_SoAPIoUIdxsPositive.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_SoAPIoUIdxsPositive = ((hv_ClassSoAPPerIoU.TupleGreaterEqualElem(
                                        0.0))).TupleFind(1);
                                }
                                if ((int)(new HTuple(hv_SoAPIoUIdxsPositive.TupleNotEqual(-1))) != 0)
                                {
                                    if (hv_PerClassMSoAP == null)
                                        hv_PerClassMSoAP = new HTuple();
                                    hv_PerClassMSoAP[hv_ClsIdx] = ((hv_ClassSoAPPerIoU.TupleSelect(
                                        hv_SoAPIoUIdxsPositive))).TupleMean();
                                }
                                else
                                {
                                    if (hv_PerClassMSoAP == null)
                                        hv_PerClassMSoAP = new HTuple();
                                    hv_PerClassMSoAP[hv_ClsIdx] = -1.0;
                                }
                                hv_ClassMSoAPDict.Dispose();
                                HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "mean_iou_soap_tp",
                                    out hv_ClassMSoAPDict);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_ClassMSoAPDict, "class_" + (hv_ClassIDs.TupleSelect(
                                        hv_ClsIdx)), hv_PerClassMSoAP.TupleSelect(hv_ClsIdx));
                                }
                            }
                        }
                        //
                        //Calculate the mean AP and optionally mean SoAP (over classes) per IoU-threshold.
                        for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                            )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PerIoUAP.Dispose();
                                HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "ap_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                    hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUAP);
                            }
                            //
                            //Consider only present classes.
                            hv_MeanClassAP.Dispose();
                            hv_MeanClassAP = -1.0;
                            if ((int)(new HTuple((new HTuple(hv_ClassesWithGt.TupleLength())).TupleGreater(
                                0))) != 0)
                            {
                                hv_MeanClassAP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_MeanClassAP = (hv_PerIoUMAP.TupleSelect(
                                        hv_ITIdx)) / (new HTuple(hv_ClassesWithGt.TupleLength()));
                                }
                            }
                            HOperatorSet.SetDictTuple(hv_PerIoUAP, "mean_class_ap", hv_MeanClassAP);
                            if ((int)(hv_CalcSoAP) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUSoAP.Dispose();
                                    HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "soap_tp_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                        hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUSoAP);
                                }
                                //
                                //Consider only present classes.
                                hv_MeanClassSoAP.Dispose();
                                hv_MeanClassSoAP = -1.0;
                                if ((int)(new HTuple(((hv_PerIoUNumClassesWithTP.TupleSelect(hv_ITIdx))).TupleGreater(
                                    0))) != 0)
                                {
                                    hv_MeanClassSoAP.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_MeanClassSoAP = (hv_PerIoUMSoAP.TupleSelect(
                                            hv_ITIdx)) / (hv_PerIoUNumClassesWithTP.TupleSelect(hv_ITIdx));
                                    }
                                }
                                HOperatorSet.SetDictTuple(hv_PerIoUSoAP, "mean_class_soap_tp", hv_MeanClassSoAP);
                            }
                            //
                            if ((int)(hv_DetailedEvaluation) != 0)
                            {
                                //Add overall measures for TP, FN, FP, ...
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUDetailedEvaluation.Dispose();
                                    HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "detailed_evaluation_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                        hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUDetailedEvaluation);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_tp",
                                        hv_PerIoUTP.TupleSelect(hv_ITIdx));
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fn",
                                        hv_PerIoUFN.TupleSelect(hv_ITIdx));
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp",
                                        hv_PerIoUFP.TupleSelect(hv_ITIdx));
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_class",
                                        hv_PerIoUFPClass.TupleSelect(hv_ITIdx));
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_background",
                                        hv_PerIoUFPBackground.TupleSelect(hv_ITIdx));
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_duplicate",
                                        hv_PerIoUFPDuplicate.TupleSelect(hv_ITIdx));
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_localization",
                                        hv_PerIoUFPLocalization.TupleSelect(hv_ITIdx));
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_multiple",
                                        hv_PerIoUFPMultiple.TupleSelect(hv_ITIdx));
                                }
                                if ((int)(hv_CalcSoAP) != 0)
                                {
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPClass.TupleSelect(
                                        hv_ITIdx))).TupleGreater(0))) != 0)
                                    {
                                        if (hv_PerIoUSoAPClass == null)
                                            hv_PerIoUSoAPClass = new HTuple();
                                        hv_PerIoUSoAPClass[hv_ITIdx] = (hv_PerIoUSoAPClass.TupleSelect(
                                            hv_ITIdx)) / (hv_PerIoUNumClassesWithFPClass.TupleSelect(hv_ITIdx));
                                    }
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPLocalization.TupleSelect(
                                        hv_ITIdx))).TupleGreater(0))) != 0)
                                    {
                                        if (hv_PerIoUSoAPLocalization == null)
                                            hv_PerIoUSoAPLocalization = new HTuple();
                                        hv_PerIoUSoAPLocalization[hv_ITIdx] = (hv_PerIoUSoAPLocalization.TupleSelect(
                                            hv_ITIdx)) / (hv_PerIoUNumClassesWithFPLocalization.TupleSelect(
                                            hv_ITIdx));
                                    }
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(
                                        hv_ITIdx))).TupleGreater(0))) != 0)
                                    {
                                        if (hv_PerIoUSoAPDuplicate == null)
                                            hv_PerIoUSoAPDuplicate = new HTuple();
                                        hv_PerIoUSoAPDuplicate[hv_ITIdx] = (hv_PerIoUSoAPDuplicate.TupleSelect(
                                            hv_ITIdx)) / (hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(
                                            hv_ITIdx));
                                    }
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPMultiple.TupleSelect(
                                        hv_ITIdx))).TupleGreater(0))) != 0)
                                    {
                                        if (hv_PerIoUSoAPMultiple == null)
                                            hv_PerIoUSoAPMultiple = new HTuple();
                                        hv_PerIoUSoAPMultiple[hv_ITIdx] = (hv_PerIoUSoAPMultiple.TupleSelect(
                                            hv_ITIdx)) / (hv_PerIoUNumClassesWithFPMultiple.TupleSelect(
                                            hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "soap_fp_class",
                                            hv_PerIoUSoAPClass.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "soap_fp_localization",
                                            hv_PerIoUSoAPLocalization.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "soap_fp_duplicate",
                                            hv_PerIoUSoAPDuplicate.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "soap_fp_multiple",
                                            hv_PerIoUSoAPMultiple.TupleSelect(hv_ITIdx));
                                    }
                                }
                            }
                        }
                        //
                        //Calculate overall mean AP (over classes and IoU-thresholds).
                        //Also here only classes with ground truth annotations are taken into account.
                        hv_MAP.Dispose();
                        hv_MAP = -1.0;
                        if ((int)(new HTuple((new HTuple(hv_ClassesWithGt.TupleLength())).TupleGreater(
                            0))) != 0)
                        {
                            hv_MAP.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MAP = (((hv_PerClassMAP.TupleSelect(
                                    hv_ClassesWithGt))).TupleSum()) / (new HTuple(hv_ClassesWithGt.TupleLength()
                                    ));
                            }
                        }
                        HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_ap", hv_MAP);
                        if ((int)(hv_CalcSoAP) != 0)
                        {
                            hv_MSoAP.Dispose();
                            hv_MSoAP = -1.0;
                            if ((int)(new HTuple(((hv_PerIoUNumClassesWithTP.TupleSum())).TupleGreater(
                                0))) != 0)
                            {
                                hv_IoUsWithTP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_IoUsWithTP = ((hv_PerIoUNumClassesWithTP.TupleGreaterElem(
                                        0))).TupleFind(1);
                                }
                                hv_MSoAP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_MSoAP = ((((hv_PerIoUMSoAP.TupleSelect(
                                        hv_IoUsWithTP)) / (hv_PerIoUNumClassesWithTP.TupleSelect(hv_IoUsWithTP)))).TupleSum()
                                        ) / (new HTuple(hv_IoUsWithTP.TupleLength()));
                                }
                            }
                            HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_soap_tp",
                                hv_MSoAP);
                            if ((int)(hv_DetailedEvaluation) != 0)
                            {
                                hv_MSoAPAll.Dispose();
                                hv_MSoAPAll = 0.0;
                                hv_NumSoAPAll.Dispose();
                                hv_NumSoAPAll = 0;
                                if ((int)(new HTuple(((hv_PerIoUNumClassesWithTP.TupleSum())).TupleGreater(
                                    0))) != 0)
                                {
                                    hv_IoUsWithTP.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_IoUsWithTP = ((hv_PerIoUNumClassesWithTP.TupleGreaterElem(
                                            0))).TupleFind(1);
                                    }
                                    hv_MSoAPAll.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_MSoAPAll = hv_MSoAP * (((hv_PerIoUNumClassesWithTP.TupleSelect(
                                            hv_IoUsWithTP))).TupleSum());
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithTP.TupleSelect(
                                                hv_IoUsWithTP))).TupleSum());
                                            hv_NumSoAPAll.Dispose();
                                            hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                        }
                                    }
                                }
                                if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPClass.TupleSum())).TupleGreater(
                                    0))) != 0)
                                {
                                    hv_IoUsWithFPClass.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_IoUsWithFPClass = ((hv_PerIoUNumClassesWithFPClass.TupleGreaterElem(
                                            0))).TupleFind(1);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_MSoAPAll = hv_MSoAPAll + (((((hv_PerIoUSoAPClass.TupleSelect(
                                                hv_IoUsWithFPClass))).TupleSum()) / (new HTuple(hv_IoUsWithFPClass.TupleLength()
                                                ))) * (((hv_PerIoUNumClassesWithFPClass.TupleSelect(hv_IoUsWithFPClass))).TupleSum()
                                                ));
                                            hv_MSoAPAll.Dispose();
                                            hv_MSoAPAll = ExpTmpLocalVar_MSoAPAll;
                                        }
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithFPClass.TupleSelect(
                                                hv_IoUsWithFPClass))).TupleSum());
                                            hv_NumSoAPAll.Dispose();
                                            hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                        }
                                    }
                                }
                                if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPLocalization.TupleSum()
                                    )).TupleGreater(0))) != 0)
                                {
                                    hv_IoUsWithFPLocalization.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_IoUsWithFPLocalization = ((hv_PerIoUNumClassesWithFPLocalization.TupleGreaterElem(
                                            0))).TupleFind(1);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_MSoAPAll = hv_MSoAPAll + (((((hv_PerIoUSoAPLocalization.TupleSelect(
                                                hv_IoUsWithFPLocalization))).TupleSum()) / (new HTuple(hv_IoUsWithFPLocalization.TupleLength()
                                                ))) * (((hv_PerIoUNumClassesWithFPLocalization.TupleSelect(hv_IoUsWithFPLocalization))).TupleSum()
                                                ));
                                            hv_MSoAPAll.Dispose();
                                            hv_MSoAPAll = ExpTmpLocalVar_MSoAPAll;
                                        }
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithFPLocalization.TupleSelect(
                                                hv_IoUsWithFPLocalization))).TupleSum());
                                            hv_NumSoAPAll.Dispose();
                                            hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                        }
                                    }
                                }
                                if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPDuplicate.TupleSum()
                                    )).TupleGreater(0))) != 0)
                                {
                                    hv_IoUsWithFPDuplicate.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_IoUsWithFPDuplicate = ((hv_PerIoUNumClassesWithFPDuplicate.TupleGreaterElem(
                                            0))).TupleFind(1);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_MSoAPAll = hv_MSoAPAll + (((((hv_PerIoUSoAPDuplicate.TupleSelect(
                                                hv_IoUsWithFPDuplicate))).TupleSum()) / (new HTuple(hv_IoUsWithFPDuplicate.TupleLength()
                                                ))) * (((hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(hv_IoUsWithFPDuplicate))).TupleSum()
                                                ));
                                            hv_MSoAPAll.Dispose();
                                            hv_MSoAPAll = ExpTmpLocalVar_MSoAPAll;
                                        }
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(
                                                hv_IoUsWithFPDuplicate))).TupleSum());
                                            hv_NumSoAPAll.Dispose();
                                            hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                        }
                                    }
                                }
                                if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPMultiple.TupleSum()
                                    )).TupleGreater(0))) != 0)
                                {
                                    hv_IoUsWithFPMultiple.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_IoUsWithFPMultiple = ((hv_PerIoUNumClassesWithFPMultiple.TupleGreaterElem(
                                            0))).TupleFind(1);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_MSoAPAll = hv_MSoAPAll + (((((hv_PerIoUSoAPMultiple.TupleSelect(
                                                hv_IoUsWithFPMultiple))).TupleSum()) / (new HTuple(hv_IoUsWithFPMultiple.TupleLength()
                                                ))) * (((hv_PerIoUNumClassesWithFPMultiple.TupleSelect(hv_IoUsWithFPMultiple))).TupleSum()
                                                ));
                                            hv_MSoAPAll.Dispose();
                                            hv_MSoAPAll = ExpTmpLocalVar_MSoAPAll;
                                        }
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithFPMultiple.TupleSelect(
                                                hv_IoUsWithFPMultiple))).TupleSum());
                                            hv_NumSoAPAll.Dispose();
                                            hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                        }
                                    }
                                }
                                if ((int)(new HTuple(hv_NumSoAPAll.TupleGreater(0))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_soap_all",
                                            (hv_MSoAPAll.TupleReal()) / hv_NumSoAPAll);
                                    }
                                }
                                else
                                {
                                    HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_soap_all",
                                        -1);
                                }
                                //
                            }
                        }
                        //
                        //Add CurrentEvaluationResult to output.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_PerMaxNumEvaluationResult, "area_" + hv_AreaName,
                                hv_CurrentEvaluationResult);
                        }
                    }
                    //Add PerMaxNumEvaluationResult to output.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvaluationResult, "max_num_detections_" + hv_MaxNumStr,
                            hv_PerMaxNumEvaluationResult);
                    }
                }
            }
            //

            hv_CalcClassAP.Dispose();
            hv_CalcMeanAP.Dispose();
            hv_CalcSoAP.Dispose();
            hv_EvalType.Dispose();
            hv_InstanceType.Dispose();
            hv_Measures.Dispose();
            hv_M.Dispose();
            hv_ClassIDs.Dispose();
            hv_NumClasses.Dispose();
            hv_MaxNumDetections.Dispose();
            hv_AreaRanges.Dispose();
            hv_IoUThresholds.Dispose();
            hv_DetailedEvaluation.Dispose();
            hv_InterpolatePRCurves.Dispose();
            hv_KeyExists.Dispose();
            hv_AreaNames.Dispose();
            hv_MinAreas.Dispose();
            hv_MaxAreas.Dispose();
            hv_RecThreshs.Dispose();
            hv_MDIdx.Dispose();
            hv_MaxNum.Dispose();
            hv_MaxNumStr.Dispose();
            hv_CurrentRunningMeasures.Dispose();
            hv_PerMaxNumEvaluationResult.Dispose();
            hv_AreaIdx.Dispose();
            hv_MinArea.Dispose();
            hv_MaxArea.Dispose();
            hv_AreaName.Dispose();
            hv_AreaRunningMeasures.Dispose();
            hv_PerClassNumGt.Dispose();
            hv_PerClassNumPred.Dispose();
            hv_PerClassConfidence.Dispose();
            hv_PerClassNumGtIgnore.Dispose();
            hv_CurrentEvaluationResult.Dispose();
            hv_ITIdx.Dispose();
            hv_PerIoUAP.Dispose();
            hv_PerIoUSoAP.Dispose();
            hv_PerIoUDetailedEvaluation.Dispose();
            hv_ClsIdx.Dispose();
            hv_PerClassDetailedEvaluation.Dispose();
            hv_DetectionConfusionMatrix.Dispose();
            hv_PerIoUMeasure.Dispose();
            hv_NumImgIDsWithFN.Dispose();
            hv_NumImgIDsWithFP.Dispose();
            hv_ImgIDsWithFN.Dispose();
            hv_ImgIDsWithFP.Dispose();
            hv_ClassMAPDict.Dispose();
            hv_ClassMSoAPDict.Dispose();
            hv_ClassesWithGt.Dispose();
            hv_PerClassMAP.Dispose();
            hv_PerIoUMAP.Dispose();
            hv_PerClassMSoAP.Dispose();
            hv_PerIoUMSoAP.Dispose();
            hv_PerIoUNumClassesWithTP.Dispose();
            hv_PerIoUTP.Dispose();
            hv_PerIoUFN.Dispose();
            hv_PerIoUFP.Dispose();
            hv_PerIoUFPClass.Dispose();
            hv_PerIoUFPBackground.Dispose();
            hv_PerIoUFPLocalization.Dispose();
            hv_PerIoUFPDuplicate.Dispose();
            hv_PerIoUFPMultiple.Dispose();
            hv_PerIoUSoAPClass.Dispose();
            hv_PerIoUSoAPLocalization.Dispose();
            hv_PerIoUSoAPDuplicate.Dispose();
            hv_PerIoUSoAPMultiple.Dispose();
            hv_PerIoUNumClassesWithFPClass.Dispose();
            hv_PerIoUNumClassesWithFPLocalization.Dispose();
            hv_PerIoUNumClassesWithFPDuplicate.Dispose();
            hv_PerIoUNumClassesWithFPMultiple.Dispose();
            hv_ClassAPPerIoU.Dispose();
            hv_ClassSoAPPerIoU.Dispose();
            hv_NumGt.Dispose();
            hv_NumGtIgnore.Dispose();
            hv_NumPred.Dispose();
            hv_Confidences.Dispose();
            hv_SortIdxs.Dispose();
            hv_CurrentClassMeasures.Dispose();
            hv_IsTP.Dispose();
            hv_Ignore.Dispose();
            hv_NoIgnoreIdxs.Dispose();
            hv_IsFP.Dispose();
            hv_AccumulatedIsTP.Dispose();
            hv_AccumulatedIsFP.Dispose();
            hv_Recall.Dispose();
            hv_Precision.Dispose();
            hv_InterpolatedPrecision.Dispose();
            hv_PIdx.Dispose();
            hv_PrecisionAtRecThreshs.Dispose();
            hv_RTIdx.Dispose();
            hv_RecQuantile.Dispose();
            hv_AOD.Dispose();
            hv_IdxsTP.Dispose();
            hv_IsFPClass.Dispose();
            hv_IsFPBackground.Dispose();
            hv_IsFPLocalization.Dispose();
            hv_IsFPDuplicate.Dispose();
            hv_IsFPMultiple.Dispose();
            hv_NumTP.Dispose();
            hv_NumFP.Dispose();
            hv_NumFN.Dispose();
            hv_NumFPClass.Dispose();
            hv_NumFPBackground.Dispose();
            hv_NumFPLocalization.Dispose();
            hv_NumFPDuplicate.Dispose();
            hv_NumFPMultiple.Dispose();
            hv_IndicesWithClassConfusion.Dispose();
            hv_IsFPClassIdxs.Dispose();
            hv_ClassIdxsConfused.Dispose();
            hv_Idx.Dispose();
            hv_NumConfusedThisIdx.Dispose();
            hv_AODClass.Dispose();
            hv_IdxsClass.Dispose();
            hv_ResSoAPClass.Dispose();
            hv_AODLocalization.Dispose();
            hv_IdxsLocalization.Dispose();
            hv_ResSoAPLocalization.Dispose();
            hv_AODDuplicate.Dispose();
            hv_IdxsDuplicate.Dispose();
            hv_ResSoAPDuplicate.Dispose();
            hv_AODMultiple.Dispose();
            hv_IdxsMultiple.Dispose();
            hv_ResSoAPMultiple.Dispose();
            hv_SoAPIoUIdxsPositive.Dispose();
            hv_MeanClassAP.Dispose();
            hv_MeanClassSoAP.Dispose();
            hv_MAP.Dispose();
            hv_MSoAP.Dispose();
            hv_IoUsWithTP.Dispose();
            hv_MSoAPAll.Dispose();
            hv_NumSoAPAll.Dispose();
            hv_IoUsWithFPClass.Dispose();
            hv_IoUsWithFPLocalization.Dispose();
            hv_IoUsWithFPDuplicate.Dispose();
            hv_IoUsWithFPMultiple.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_CalcClassAP.Dispose();
            hv_CalcMeanAP.Dispose();
            hv_CalcSoAP.Dispose();
            hv_EvalType.Dispose();
            hv_InstanceType.Dispose();
            hv_Measures.Dispose();
            hv_M.Dispose();
            hv_ClassIDs.Dispose();
            hv_NumClasses.Dispose();
            hv_MaxNumDetections.Dispose();
            hv_AreaRanges.Dispose();
            hv_IoUThresholds.Dispose();
            hv_DetailedEvaluation.Dispose();
            hv_InterpolatePRCurves.Dispose();
            hv_KeyExists.Dispose();
            hv_AreaNames.Dispose();
            hv_MinAreas.Dispose();
            hv_MaxAreas.Dispose();
            hv_RecThreshs.Dispose();
            hv_MDIdx.Dispose();
            hv_MaxNum.Dispose();
            hv_MaxNumStr.Dispose();
            hv_CurrentRunningMeasures.Dispose();
            hv_PerMaxNumEvaluationResult.Dispose();
            hv_AreaIdx.Dispose();
            hv_MinArea.Dispose();
            hv_MaxArea.Dispose();
            hv_AreaName.Dispose();
            hv_AreaRunningMeasures.Dispose();
            hv_PerClassNumGt.Dispose();
            hv_PerClassNumPred.Dispose();
            hv_PerClassConfidence.Dispose();
            hv_PerClassNumGtIgnore.Dispose();
            hv_CurrentEvaluationResult.Dispose();
            hv_ITIdx.Dispose();
            hv_PerIoUAP.Dispose();
            hv_PerIoUSoAP.Dispose();
            hv_PerIoUDetailedEvaluation.Dispose();
            hv_ClsIdx.Dispose();
            hv_PerClassDetailedEvaluation.Dispose();
            hv_DetectionConfusionMatrix.Dispose();
            hv_PerIoUMeasure.Dispose();
            hv_NumImgIDsWithFN.Dispose();
            hv_NumImgIDsWithFP.Dispose();
            hv_ImgIDsWithFN.Dispose();
            hv_ImgIDsWithFP.Dispose();
            hv_ClassMAPDict.Dispose();
            hv_ClassMSoAPDict.Dispose();
            hv_ClassesWithGt.Dispose();
            hv_PerClassMAP.Dispose();
            hv_PerIoUMAP.Dispose();
            hv_PerClassMSoAP.Dispose();
            hv_PerIoUMSoAP.Dispose();
            hv_PerIoUNumClassesWithTP.Dispose();
            hv_PerIoUTP.Dispose();
            hv_PerIoUFN.Dispose();
            hv_PerIoUFP.Dispose();
            hv_PerIoUFPClass.Dispose();
            hv_PerIoUFPBackground.Dispose();
            hv_PerIoUFPLocalization.Dispose();
            hv_PerIoUFPDuplicate.Dispose();
            hv_PerIoUFPMultiple.Dispose();
            hv_PerIoUSoAPClass.Dispose();
            hv_PerIoUSoAPLocalization.Dispose();
            hv_PerIoUSoAPDuplicate.Dispose();
            hv_PerIoUSoAPMultiple.Dispose();
            hv_PerIoUNumClassesWithFPClass.Dispose();
            hv_PerIoUNumClassesWithFPLocalization.Dispose();
            hv_PerIoUNumClassesWithFPDuplicate.Dispose();
            hv_PerIoUNumClassesWithFPMultiple.Dispose();
            hv_ClassAPPerIoU.Dispose();
            hv_ClassSoAPPerIoU.Dispose();
            hv_NumGt.Dispose();
            hv_NumGtIgnore.Dispose();
            hv_NumPred.Dispose();
            hv_Confidences.Dispose();
            hv_SortIdxs.Dispose();
            hv_CurrentClassMeasures.Dispose();
            hv_IsTP.Dispose();
            hv_Ignore.Dispose();
            hv_NoIgnoreIdxs.Dispose();
            hv_IsFP.Dispose();
            hv_AccumulatedIsTP.Dispose();
            hv_AccumulatedIsFP.Dispose();
            hv_Recall.Dispose();
            hv_Precision.Dispose();
            hv_InterpolatedPrecision.Dispose();
            hv_PIdx.Dispose();
            hv_PrecisionAtRecThreshs.Dispose();
            hv_RTIdx.Dispose();
            hv_RecQuantile.Dispose();
            hv_AOD.Dispose();
            hv_IdxsTP.Dispose();
            hv_IsFPClass.Dispose();
            hv_IsFPBackground.Dispose();
            hv_IsFPLocalization.Dispose();
            hv_IsFPDuplicate.Dispose();
            hv_IsFPMultiple.Dispose();
            hv_NumTP.Dispose();
            hv_NumFP.Dispose();
            hv_NumFN.Dispose();
            hv_NumFPClass.Dispose();
            hv_NumFPBackground.Dispose();
            hv_NumFPLocalization.Dispose();
            hv_NumFPDuplicate.Dispose();
            hv_NumFPMultiple.Dispose();
            hv_IndicesWithClassConfusion.Dispose();
            hv_IsFPClassIdxs.Dispose();
            hv_ClassIdxsConfused.Dispose();
            hv_Idx.Dispose();
            hv_NumConfusedThisIdx.Dispose();
            hv_AODClass.Dispose();
            hv_IdxsClass.Dispose();
            hv_ResSoAPClass.Dispose();
            hv_AODLocalization.Dispose();
            hv_IdxsLocalization.Dispose();
            hv_ResSoAPLocalization.Dispose();
            hv_AODDuplicate.Dispose();
            hv_IdxsDuplicate.Dispose();
            hv_ResSoAPDuplicate.Dispose();
            hv_AODMultiple.Dispose();
            hv_IdxsMultiple.Dispose();
            hv_ResSoAPMultiple.Dispose();
            hv_SoAPIoUIdxsPositive.Dispose();
            hv_MeanClassAP.Dispose();
            hv_MeanClassSoAP.Dispose();
            hv_MAP.Dispose();
            hv_MSoAP.Dispose();
            hv_IoUsWithTP.Dispose();
            hv_MSoAPAll.Dispose();
            hv_NumSoAPAll.Dispose();
            hv_IoUsWithFPClass.Dispose();
            hv_IoUsWithFPLocalization.Dispose();
            hv_IoUsWithFPDuplicate.Dispose();
            hv_IoUsWithFPMultiple.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Multi-Label Classification
    // Short Description: Calculate multi-label classification measures based on RunningMeasures. 
    private void calculate_multi_label_classification_measures(HTuple hv_RunningMeasures,
        HTuple hv_EvalParams, out HTuple hv_EvaluationResult)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_ClassIDs = new HTuple(), hv_ClassNames = new HTuple();
        HTuple hv_MinConfidence = new HTuple(), hv_InterpolatePRCurves = new HTuple();
        HTuple hv_KeyExists = new HTuple(), hv_CalcPrecision = new HTuple();
        HTuple hv_CalcRecall = new HTuple(), hv_CalcFScore = new HTuple();
        HTuple hv_CalcMap = new HTuple(), hv_CalcAccuracy = new HTuple();
        HTuple hv_AveragePrecisions = new HTuple(), hv_ClassIdx = new HTuple();
        HTuple hv_ResultClassDict = new HTuple(), hv_ClassKey = new HTuple();
        HTuple hv_RunningMeasuresClassDict = new HTuple(), hv_TP = new HTuple();
        HTuple hv_FP = new HTuple(), hv_FN = new HTuple(), hv_SortIdxs = new HTuple();
        HTuple hv_GroundTruth = new HTuple(), hv_Confidences = new HTuple();
        HTuple hv_Thresholds = new HTuple(), hv_ThreshIdx = new HTuple();
        HTuple hv_Threshold = new HTuple(), hv_PredictedPositives = new HTuple();
        HTuple hv_DivisorPrec = new HTuple(), hv_DivisorRec = new HTuple();
        HTuple hv_InvalidIndPrec = new HTuple(), hv_InvalidIndRec = new HTuple();
        HTuple hv_Precision = new HTuple(), hv_Recall = new HTuple();
        HTuple hv_InterpolatedPrecision = new HTuple(), hv_PIdx = new HTuple();
        HTuple hv_AreaUnderCurve = new HTuple(), hv_RecIdx = new HTuple();
        HTuple hv_DivisorFscore = new HTuple(), hv_NSamples = new HTuple();
        HTuple hv_CorrectPredictions = new HTuple(), hv___Tmp_Ctrl_Dict_Init_1 = new HTuple();
        HTuple hv___Tmp_Ctrl_Dict_Init_3 = new HTuple();
        // Initialize local and output iconic variables 
        hv_EvaluationResult = new HTuple();
        try
        {
            //
            //Retrieve information from EvalParams
            hv_ClassIDs.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_ClassIDs = hv_EvalParams.TupleGetDictTuple(
                    "class_ids");
            }
            hv_ClassNames.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_ClassNames = hv_EvalParams.TupleGetDictTuple(
                    "class_names");
            }
            hv_MinConfidence.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_MinConfidence = hv_EvalParams.TupleGetDictTuple(
                    "min_confidence");
            }
            hv_InterpolatePRCurves.Dispose();
            hv_InterpolatePRCurves = 0;
            hv_KeyExists.Dispose();
            HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "interpolate_pr_curves",
                out hv_KeyExists);
            if ((int)(hv_KeyExists) != 0)
            {
                hv_InterpolatePRCurves.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "interpolate_pr_curves", out hv_InterpolatePRCurves);
            }
            hv_CalcPrecision.Dispose(); hv_CalcRecall.Dispose(); hv_CalcFScore.Dispose(); hv_CalcMap.Dispose(); hv_CalcAccuracy.Dispose();
            check_multi_label_classification_measures(hv_EvalParams, out hv_CalcPrecision,
                out hv_CalcRecall, out hv_CalcFScore, out hv_CalcMap, out hv_CalcAccuracy);
            //
            //Initialize EvaluationResult
            hv_EvaluationResult.Dispose();
            HOperatorSet.CreateDict(out hv_EvaluationResult);
            hv___Tmp_Ctrl_Dict_Init_1.Dispose();
            HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_1);
            HOperatorSet.SetDictTuple(hv_EvaluationResult, "classes", hv___Tmp_Ctrl_Dict_Init_1);
            hv___Tmp_Ctrl_Dict_Init_1.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv___Tmp_Ctrl_Dict_Init_1 = HTuple.TupleConstant(
                    "HNULL");
            }
            if ((int)((new HTuple(hv_CalcPrecision.TupleOr(hv_CalcRecall))).TupleOr(hv_CalcFScore)) != 0)
            {
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_precision", 0.0);
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_recall", 0.0);
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_f_score", 0.0);
            }
            if ((int)(hv_CalcMap) != 0)
            {
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_ap", 0.0);
            }
            if ((int)(hv_CalcAccuracy) != 0)
            {
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "accuracy", 0.0);
            }
            //
            hv_AveragePrecisions.Dispose();
            hv_AveragePrecisions = new HTuple();
            //Iterate over all classes
            for (hv_ClassIdx = 0; (int)hv_ClassIdx <= (int)((new HTuple(hv_ClassIDs.TupleLength()
                )) - 1); hv_ClassIdx = (int)hv_ClassIdx + 1)
            {
                hv_ResultClassDict.Dispose();
                HOperatorSet.CreateDict(out hv_ResultClassDict);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_ResultClassDict, "class_name", hv_ClassNames.TupleSelect(
                        hv_ClassIdx));
                }
                hv_ClassKey.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ClassKey = "class_" + (hv_ClassIDs.TupleSelect(
                        hv_ClassIdx));
                }
                hv_RunningMeasuresClassDict.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, hv_ClassKey, out hv_RunningMeasuresClassDict);
                //
                if ((int)(hv_CalcMap) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_ResultClassDict, "ap", 0);
                    hv___Tmp_Ctrl_Dict_Init_3.Dispose();
                    HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_3);
                    HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_3, "comp", new HTuple());
                    if ((int)(((((hv_RunningMeasuresClassDict.TupleConcat(hv___Tmp_Ctrl_Dict_Init_3))).TupleTestEqualDictItem(
                        "confidences", "comp"))).TupleNot()) != 0)
                    {
                        //Iterate over confidence thresholds (for mAP)
                        hv_TP.Dispose();
                        hv_TP = new HTuple();
                        hv_FP.Dispose();
                        hv_FP = new HTuple();
                        hv_FN.Dispose();
                        hv_FN = new HTuple();
                        hv_SortIdxs.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SortIdxs = ((-(hv_RunningMeasuresClassDict.TupleGetDictTuple(
                                "confidences")))).TupleSortIndex();
                        }
                        hv_GroundTruth.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_GroundTruth = ((hv_RunningMeasuresClassDict.TupleGetDictTuple(
                                "ground_truth"))).TupleSelect(hv_SortIdxs);
                        }
                        hv_Confidences.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Confidences = ((hv_RunningMeasuresClassDict.TupleGetDictTuple(
                                "confidences"))).TupleSelect(hv_SortIdxs);
                        }
                        hv_Thresholds.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Thresholds = new HTuple();
                            hv_Thresholds[0] = 1;
                            hv_Thresholds = hv_Thresholds.TupleConcat(hv_Confidences);
                            hv_Thresholds = hv_Thresholds.TupleConcat(0);
                        }
                        //
                        for (hv_ThreshIdx = 0; (int)hv_ThreshIdx <= (int)((new HTuple(hv_Thresholds.TupleLength()
                            )) - 1); hv_ThreshIdx = (int)hv_ThreshIdx + 1)
                        {
                            hv_Threshold.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Threshold = hv_Thresholds.TupleSelect(
                                    hv_ThreshIdx);
                            }
                            hv_PredictedPositives.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PredictedPositives = hv_Confidences.TupleGreaterEqualElem(
                                    hv_Threshold);
                            }
                            if (hv_TP == null)
                                hv_TP = new HTuple();
                            hv_TP[hv_ThreshIdx] = (new HTuple(hv_PredictedPositives.TupleAnd(hv_GroundTruth))).TupleSum()
                                ;
                            if (hv_FP == null)
                                hv_FP = new HTuple();
                            hv_FP[hv_ThreshIdx] = (new HTuple(hv_PredictedPositives.TupleAnd(hv_GroundTruth.TupleNot()
                                ))).TupleSum();
                            if (hv_FN == null)
                                hv_FN = new HTuple();
                            hv_FN[hv_ThreshIdx] = (new HTuple((new HTuple(hv_PredictedPositives.TupleNot()
                                )).TupleAnd(hv_GroundTruth))).TupleSum();
                        }
                        //Calculate Precision and Recall
                        hv_DivisorPrec.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DivisorPrec = hv_FP + hv_TP;
                        }
                        hv_DivisorRec.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DivisorRec = hv_FN + hv_TP;
                        }
                        //Avoid division by zero by replacing divisor with dummy values
                        hv_InvalidIndPrec.Dispose();
                        HOperatorSet.TupleFind(hv_DivisorPrec, 0, out hv_InvalidIndPrec);
                        hv_InvalidIndRec.Dispose();
                        HOperatorSet.TupleFind(hv_DivisorRec, 0, out hv_InvalidIndRec);
                        if ((int)(new HTuple(hv_InvalidIndPrec.TupleNotEqual(-1))) != 0)
                        {
                            if (hv_DivisorPrec == null)
                                hv_DivisorPrec = new HTuple();
                            hv_DivisorPrec[hv_InvalidIndPrec] = -1;
                        }
                        if ((int)(new HTuple(hv_InvalidIndRec.TupleNotEqual(-1))) != 0)
                        {
                            if (hv_DivisorRec == null)
                                hv_DivisorRec = new HTuple();
                            hv_DivisorRec[hv_InvalidIndRec] = -1;
                        }
                        //
                        hv_Precision.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Precision = (hv_TP.TupleReal()
                                ) / hv_DivisorPrec;
                        }
                        hv_Recall.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Recall = (hv_TP.TupleReal()
                                ) / hv_DivisorRec;
                        }
                        //
                        //Fix dummy values in precision and recall
                        if ((int)(new HTuple(hv_InvalidIndPrec.TupleNotEqual(-1))) != 0)
                        {
                            if (hv_Precision == null)
                                hv_Precision = new HTuple();
                            hv_Precision[hv_InvalidIndPrec] = 1.0;
                        }
                        if ((int)(new HTuple(hv_InvalidIndRec.TupleNotEqual(-1))) != 0)
                        {
                            if (hv_Recall == null)
                                hv_Recall = new HTuple();
                            hv_Recall[hv_InvalidIndRec] = 1.0;
                        }
                        //
                        //(Optionally) smooth precision-recall curve.
                        hv_InterpolatedPrecision.Dispose();
                        hv_InterpolatedPrecision = new HTuple(hv_Precision);
                        if ((int)(hv_InterpolatePRCurves) != 0)
                        {
                            for (hv_PIdx = (new HTuple(hv_Precision.TupleLength())) - 2; (int)hv_PIdx >= 0; hv_PIdx = (int)hv_PIdx + -1)
                            {
                                if (hv_InterpolatedPrecision == null)
                                    hv_InterpolatedPrecision = new HTuple();
                                hv_InterpolatedPrecision[hv_PIdx] = ((hv_InterpolatedPrecision.TupleSelect(
                                    hv_PIdx))).TupleMax2(hv_InterpolatedPrecision.TupleSelect(hv_PIdx + 1));
                            }
                        }
                        //Approximate the area under the Precision-Recall curve.
                        hv_AreaUnderCurve.Dispose();
                        hv_AreaUnderCurve = 0;
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_AreaUnderCurve = hv_AreaUnderCurve + (((hv_Recall.TupleSelect(
                                    0)) - 0) * (hv_InterpolatedPrecision.TupleSelect(0)));
                                hv_AreaUnderCurve.Dispose();
                                hv_AreaUnderCurve = ExpTmpLocalVar_AreaUnderCurve;
                            }
                        }
                        for (hv_RecIdx = 0; (int)hv_RecIdx <= (int)((new HTuple(hv_Recall.TupleLength()
                            )) - 2); hv_RecIdx = (int)hv_RecIdx + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_AreaUnderCurve = hv_AreaUnderCurve + (((hv_Recall.TupleSelect(
                                        hv_RecIdx + 1)) - (hv_Recall.TupleSelect(hv_RecIdx))) * (hv_InterpolatedPrecision.TupleSelect(
                                        hv_RecIdx)));
                                    hv_AreaUnderCurve.Dispose();
                                    hv_AreaUnderCurve = ExpTmpLocalVar_AreaUnderCurve;
                                }
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_AreaUnderCurve = hv_AreaUnderCurve + ((1 - (hv_Recall.TupleSelect(
                                    hv_RecIdx))) * (hv_InterpolatedPrecision.TupleSelect(hv_RecIdx)));
                                hv_AreaUnderCurve.Dispose();
                                hv_AreaUnderCurve = ExpTmpLocalVar_AreaUnderCurve;
                            }
                        }
                        HOperatorSet.SetDictTuple(hv_ResultClassDict, "ap", hv_AreaUnderCurve);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_ap", (hv_EvaluationResult.TupleGetDictTuple(
                                "mean_ap")) + hv_AreaUnderCurve);
                        }
                    }
                    hv___Tmp_Ctrl_Dict_Init_3.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv___Tmp_Ctrl_Dict_Init_3 = HTuple.TupleConstant(
                            "HNULL");
                    }
                }
                //Record precision, recall and f_score for min_confidence threshold
                if ((int)((new HTuple(hv_CalcPrecision.TupleOr(hv_CalcRecall))).TupleOr(hv_CalcFScore)) != 0)
                {
                    hv_TP.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasuresClassDict, "tp", out hv_TP);
                    hv_FP.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasuresClassDict, "fp", out hv_FP);
                    hv_FN.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasuresClassDict, "fn", out hv_FN);
                    hv_DivisorPrec.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DivisorPrec = hv_FP + hv_TP;
                    }
                    hv_DivisorRec.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DivisorRec = hv_FN + hv_TP;
                    }
                    hv_DivisorFscore.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DivisorFscore = ((2 * hv_TP) + hv_FP) + hv_FN;
                    }
                    //
                    //Avoid division by zero for edge cases
                    if ((int)(new HTuple(hv_DivisorPrec.TupleEqual(0))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_ResultClassDict, "precision", 1.0);
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_ResultClassDict, "precision", (hv_TP.TupleReal()
                                ) / hv_DivisorPrec);
                        }
                    }
                    if ((int)(new HTuple(hv_DivisorRec.TupleEqual(0))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_ResultClassDict, "recall", 1.0);
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_ResultClassDict, "recall", (hv_TP.TupleReal()
                                ) / hv_DivisorRec);
                        }
                    }
                    if ((int)(new HTuple(hv_DivisorFscore.TupleEqual(0))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_ResultClassDict, "f_score", 1.0);
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_ResultClassDict, "f_score", (2.0 * hv_TP) / hv_DivisorFscore);
                        }
                    }
                    //
                    //Store sum of all valid class values to calculate average below
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_precision", (hv_EvaluationResult.TupleGetDictTuple(
                            "mean_precision")) + (hv_ResultClassDict.TupleGetDictTuple("precision")));
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_recall", (hv_EvaluationResult.TupleGetDictTuple(
                            "mean_recall")) + (hv_ResultClassDict.TupleGetDictTuple("recall")));
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_f_score", (hv_EvaluationResult.TupleGetDictTuple(
                            "mean_f_score")) + (hv_ResultClassDict.TupleGetDictTuple("f_score")));
                    }
                }
                //Calculate and store per-class accuracy
                if ((int)(hv_CalcAccuracy) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_ResultClassDict, "accuracy", 0);
                    hv_NSamples.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NSamples = new HTuple(((hv_RunningMeasures.TupleGetDictTuple(
                            "image_ids"))).TupleLength());
                    }
                    if ((int)(new HTuple(hv_NSamples.TupleGreater(0))) != 0)
                    {
                        hv_FP.Dispose();
                        HOperatorSet.GetDictTuple(hv_RunningMeasuresClassDict, "fp", out hv_FP);
                        hv_FN.Dispose();
                        HOperatorSet.GetDictTuple(hv_RunningMeasuresClassDict, "fn", out hv_FN);
                        hv_CorrectPredictions.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CorrectPredictions = (hv_NSamples - hv_FP) - hv_FN;
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_ResultClassDict, "accuracy", (hv_CorrectPredictions.TupleReal()
                                ) / hv_NSamples);
                        }
                    }
                }
                //Store values
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_EvaluationResult.TupleGetDictTuple("classes"),
                        hv_ClassIDs.TupleSelect(hv_ClassIdx), hv_ResultClassDict);
                }
            }
            //Calculate and store overall accuracy
            if ((int)(hv_CalcAccuracy) != 0)
            {
                hv_NSamples.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NSamples = new HTuple(((hv_RunningMeasures.TupleGetDictTuple(
                        "image_ids"))).TupleLength());
                }
                if ((int)(new HTuple(hv_NSamples.TupleGreater(0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvaluationResult, "accuracy", (((hv_RunningMeasures.TupleGetDictTuple(
                            "correct_predictions"))).TupleReal()) / hv_NSamples);
                    }
                }
            }
            //Calculate and store mAP over thresholds in 'EvalParams.confidence_threshold'
            if ((int)(hv_CalcMap) != 0)
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_ap", (hv_EvaluationResult.TupleGetDictTuple(
                        "mean_ap")) / (new HTuple(hv_ClassIDs.TupleLength())));
                }
            }
            //Calculate and store mean precision, mean recall and mean f_score over all classes
            if ((int)((new HTuple(hv_CalcPrecision.TupleOr(hv_CalcRecall))).TupleOr(hv_CalcFScore)) != 0)
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_precision", (hv_EvaluationResult.TupleGetDictTuple(
                        "mean_precision")) / (new HTuple(hv_ClassIDs.TupleLength())));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_recall", (hv_EvaluationResult.TupleGetDictTuple(
                        "mean_recall")) / (new HTuple(hv_ClassIDs.TupleLength())));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_f_score", (hv_EvaluationResult.TupleGetDictTuple(
                        "mean_f_score")) / (new HTuple(hv_ClassIDs.TupleLength())));
                }
            }
            //

            hv_ClassIDs.Dispose();
            hv_ClassNames.Dispose();
            hv_MinConfidence.Dispose();
            hv_InterpolatePRCurves.Dispose();
            hv_KeyExists.Dispose();
            hv_CalcPrecision.Dispose();
            hv_CalcRecall.Dispose();
            hv_CalcFScore.Dispose();
            hv_CalcMap.Dispose();
            hv_CalcAccuracy.Dispose();
            hv_AveragePrecisions.Dispose();
            hv_ClassIdx.Dispose();
            hv_ResultClassDict.Dispose();
            hv_ClassKey.Dispose();
            hv_RunningMeasuresClassDict.Dispose();
            hv_TP.Dispose();
            hv_FP.Dispose();
            hv_FN.Dispose();
            hv_SortIdxs.Dispose();
            hv_GroundTruth.Dispose();
            hv_Confidences.Dispose();
            hv_Thresholds.Dispose();
            hv_ThreshIdx.Dispose();
            hv_Threshold.Dispose();
            hv_PredictedPositives.Dispose();
            hv_DivisorPrec.Dispose();
            hv_DivisorRec.Dispose();
            hv_InvalidIndPrec.Dispose();
            hv_InvalidIndRec.Dispose();
            hv_Precision.Dispose();
            hv_Recall.Dispose();
            hv_InterpolatedPrecision.Dispose();
            hv_PIdx.Dispose();
            hv_AreaUnderCurve.Dispose();
            hv_RecIdx.Dispose();
            hv_DivisorFscore.Dispose();
            hv_NSamples.Dispose();
            hv_CorrectPredictions.Dispose();
            hv___Tmp_Ctrl_Dict_Init_1.Dispose();
            hv___Tmp_Ctrl_Dict_Init_3.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_ClassIDs.Dispose();
            hv_ClassNames.Dispose();
            hv_MinConfidence.Dispose();
            hv_InterpolatePRCurves.Dispose();
            hv_KeyExists.Dispose();
            hv_CalcPrecision.Dispose();
            hv_CalcRecall.Dispose();
            hv_CalcFScore.Dispose();
            hv_CalcMap.Dispose();
            hv_CalcAccuracy.Dispose();
            hv_AveragePrecisions.Dispose();
            hv_ClassIdx.Dispose();
            hv_ResultClassDict.Dispose();
            hv_ClassKey.Dispose();
            hv_RunningMeasuresClassDict.Dispose();
            hv_TP.Dispose();
            hv_FP.Dispose();
            hv_FN.Dispose();
            hv_SortIdxs.Dispose();
            hv_GroundTruth.Dispose();
            hv_Confidences.Dispose();
            hv_Thresholds.Dispose();
            hv_ThreshIdx.Dispose();
            hv_Threshold.Dispose();
            hv_PredictedPositives.Dispose();
            hv_DivisorPrec.Dispose();
            hv_DivisorRec.Dispose();
            hv_InvalidIndPrec.Dispose();
            hv_InvalidIndRec.Dispose();
            hv_Precision.Dispose();
            hv_Recall.Dispose();
            hv_InterpolatedPrecision.Dispose();
            hv_PIdx.Dispose();
            hv_AreaUnderCurve.Dispose();
            hv_RecIdx.Dispose();
            hv_DivisorFscore.Dispose();
            hv_NSamples.Dispose();
            hv_CorrectPredictions.Dispose();
            hv___Tmp_Ctrl_Dict_Init_1.Dispose();
            hv___Tmp_Ctrl_Dict_Init_3.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: OCR / Deep OCR
    // Short Description: Computes the ocr_detection relevant evaluation measures. 
    private void calculate_ocr_detection_measures(HTuple hv_DetectionEvaluationResult,
        out HTuple hv_EvaluationResult)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_Keys = new HTuple(), hv_Matches = new HTuple();
        HTuple hv_Key = new HTuple(), hv_WordEval = new HTuple();
        HTuple hv_NumAll = new HTuple(), hv_NumTPFP = new HTuple();
        HTuple hv_Divisor = new HTuple(), hv___Tmp_Ctrl_Type = new HTuple();
        // Initialize local and output iconic variables 
        hv_EvaluationResult = new HTuple();
        try
        {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_Keys.Dispose();
                HOperatorSet.GetDictParam(((hv_DetectionEvaluationResult.TupleGetDictTuple(
                    "max_num_detections_all"))).TupleGetDictTuple("area_all"), "keys", new HTuple(),
                    out hv_Keys);
            }
            //Use the first matching key in order to compute the measures.
            hv_Matches.Dispose();
            HOperatorSet.TupleRegexpSelect(hv_Keys, "detailed_evaluation_iou_.*", out hv_Matches);
            hv_Key.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_Key = hv_Matches.TupleSelect(
                    0);
            }
            hv_WordEval.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_WordEval = ((((((hv_DetectionEvaluationResult.TupleGetDictTuple(
                    "max_num_detections_all"))).TupleGetDictTuple("area_all"))).TupleGetDictTuple(
                    hv_Key))).TupleGetDictTuple("class_0");
            }
            hv_EvaluationResult.Dispose();
            HOperatorSet.CreateDict(out hv_EvaluationResult);
            //Recall
            hv_NumAll.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_NumAll = (hv_WordEval.TupleGetDictTuple(
                    "num_tp")) + (hv_WordEval.TupleGetDictTuple("num_fn"));
            }
            if ((int)(new HTuple(hv_NumAll.TupleGreater(0))) != 0)
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "recall", (hv_WordEval.TupleGetDictTuple(
                        "num_tp")) / (hv_NumAll.TupleReal()));
                }
            }
            else
            {
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "recall", 0.0);
            }
            //Precision
            hv_NumTPFP.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_NumTPFP = (hv_WordEval.TupleGetDictTuple(
                    "num_tp")) + (hv_WordEval.TupleGetDictTuple("num_fp"));
            }
            if ((int)(new HTuple(hv_NumTPFP.TupleGreater(0))) != 0)
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "precision", (hv_WordEval.TupleGetDictTuple(
                        "num_tp")) / (hv_NumTPFP.TupleReal()));
                }
            }
            else
            {
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "precision", 0.0);
            }
            //F-Score
            hv_Divisor.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_Divisor = (hv_EvaluationResult.TupleGetDictTuple(
                    "precision")) + (hv_EvaluationResult.TupleGetDictTuple("recall"));
            }
            if ((int)(new HTuple(hv_Divisor.TupleNotEqual(0))) != 0)
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "f_score", ((2 * (hv_EvaluationResult.TupleGetDictTuple(
                        "precision"))) * (hv_EvaluationResult.TupleGetDictTuple("recall"))) / hv_Divisor);
                }
            }
            else
            {
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "f_score", 0.0);
            }
            //SoAP
            hv_Matches.Dispose();
            HOperatorSet.TupleRegexpSelect(hv_Keys, "soap_tp_iou_.*", out hv_Matches);
            if ((int)(new HTuple((new HTuple(hv_Matches.TupleLength())).TupleGreater(0))) != 0)
            {
                hv_Key.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Key = hv_Matches.TupleSelect(
                        0);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv___Tmp_Ctrl_Type.Dispose();
                    HOperatorSet.GetDictParam(((((hv_DetectionEvaluationResult.TupleGetDictTuple(
                        "max_num_detections_all"))).TupleGetDictTuple("area_all"))).TupleGetDictTuple(
                        hv_Key), "key_data_type", "class_0", out hv___Tmp_Ctrl_Type);
                }
                if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictObject(((((((hv_DetectionEvaluationResult.TupleGetDictTuple(
                            "max_num_detections_all"))).TupleGetDictTuple("area_all"))).TupleGetDictTuple(
                            hv_Key))).TupleGetDictObject("class_0"), hv_EvaluationResult, "soap");
                    }
                }
                else
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvaluationResult, "soap", ((((((hv_DetectionEvaluationResult.TupleGetDictTuple(
                            "max_num_detections_all"))).TupleGetDictTuple("area_all"))).TupleGetDictTuple(
                            hv_Key))).TupleGetDictTuple("class_0"));
                    }
                }
            }

            hv_Keys.Dispose();
            hv_Matches.Dispose();
            hv_Key.Dispose();
            hv_WordEval.Dispose();
            hv_NumAll.Dispose();
            hv_NumTPFP.Dispose();
            hv_Divisor.Dispose();
            hv___Tmp_Ctrl_Type.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_Keys.Dispose();
            hv_Matches.Dispose();
            hv_Key.Dispose();
            hv_WordEval.Dispose();
            hv_NumAll.Dispose();
            hv_NumTPFP.Dispose();
            hv_Divisor.Dispose();
            hv___Tmp_Ctrl_Type.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: OCR / Deep OCR
    // Short Description: Calculate OCR recognition measures based on RunningMeasures. 
    private void calculate_ocr_recognition_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
        out HTuple hv_EvaluationResult)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_Equal = new HTuple();
        // Initialize local and output iconic variables 
        hv_EvaluationResult = new HTuple();
        try
        {
            //
            //This procedure calculates the final summarizing OCR recognition measures based on the running measures.
            //
            //
            //Initialize output dictionary and get necessary evaluation parameters.
            hv_EvaluationResult.Dispose();
            HOperatorSet.CreateDict(out hv_EvaluationResult);
            //
            //Compute Accuracy
            hv_Equal.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_Equal = ((hv_RunningMeasures.TupleGetDictTuple(
                    "words_ground_truth"))).TupleEqualElem(hv_RunningMeasures.TupleGetDictTuple(
                    "words_prediction"));
            }
            if ((int)(new HTuple((new HTuple(hv_Equal.TupleLength())).TupleGreater(0))) != 0)
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "accuracy", ((hv_Equal.TupleSum()
                        ) / ((new HTuple(hv_Equal.TupleLength())).TupleReal())) * 100);
                }
            }
            else
            {
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "accuracy", 0);
            }

            hv_Equal.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_Equal.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Classification
    // Short Description: Calculate out-of-distribution detection measures based on RunningMeasures. 
    private void calculate_ood_detection_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
        HTuple hv_EvaluationResult)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_CalcOODConfusionMatrix = new HTuple();
        HTuple hv_CalcOODPrecision = new HTuple(), hv_CalcOODRecall = new HTuple();
        HTuple hv_CalcOODFScore = new HTuple(), hv_CalcOODFPR = new HTuple();
        HTuple hv_CalcOODScoreHistogram = new HTuple(), hv_CalcOODScoreThresholds = new HTuple();
        HTuple hv_Measures = new HTuple(), hv_M = new HTuple();
        HTuple hv_OODPredictionsID = new HTuple(), hv_OODScoresID = new HTuple();
        HTuple hv_OODPredictionsOOD = new HTuple(), hv_OODScoresOOD = new HTuple();
        HTuple hv_NumIDSamples = new HTuple(), hv_NumOODSamples = new HTuple();
        HTuple hv_OODConfusionMatrix = new HTuple(), hv_Rows = new HTuple();
        HTuple hv_Columns = new HTuple(), hv_Value = new HTuple();
        HTuple hv_NumTruePositives = new HTuple(), hv_NumFalsePositives = new HTuple();
        HTuple hv_NumFalseNegatives = new HTuple(), hv_NumPredictedPositives = new HTuple();
        HTuple hv_HistoIDXValues = new HTuple(), hv_HistoIDYValues = new HTuple();
        HTuple hv_HistoOODXValues = new HTuple(), hv_HistoOODYValues = new HTuple();
        HTuple hv_ScoreHistogram = new HTuple(), hv_ModelThresholdExists = new HTuple();
        HTuple hv_NoFPThreshold = new HTuple(), hv_NoFNThreshold = new HTuple();
        HTuple hv_OODScores = new HTuple(), hv_MinErrorThreshold = new HTuple();
        HTuple hv_OODScoresSortIndices = new HTuple(), hv_OODScoresSorted = new HTuple();
        HTuple hv_TmpID = new HTuple(), hv_TmpIDSorted = new HTuple();
        HTuple hv_TrueNegativesPerScore = new HTuple(), hv_FPRate = new HTuple();
        HTuple hv_TmpOOD = new HTuple(), hv_TmpOODSorted = new HTuple();
        HTuple hv_FalseNegativesPerScore = new HTuple(), hv_FNRate = new HTuple();
        HTuple hv_FprFnrSum = new HTuple(), hv_MinFprFnRSum = new HTuple();
        HTuple hv_ThresholdIndex = new HTuple(), hv___Tmp_Ctrl_Dict_Init_0 = new HTuple();
        HTuple hv___Tmp_Ctrl_Dict_Init_1 = new HTuple(), hv___Tmp_Ctrl_Dict_Init_3 = new HTuple();
        HTuple hv___Tmp_Ctrl_Type = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            //
            //This procedure calculates the final summarizing out-of-distribution detection measures based on the running measures.
            //
            //Set default values.
            hv_CalcOODConfusionMatrix.Dispose();
            hv_CalcOODConfusionMatrix = 0;
            hv_CalcOODPrecision.Dispose();
            hv_CalcOODPrecision = 0;
            hv_CalcOODRecall.Dispose();
            hv_CalcOODRecall = 0;
            hv_CalcOODFScore.Dispose();
            hv_CalcOODFScore = 0;
            hv_CalcOODFPR.Dispose();
            hv_CalcOODFPR = 0;
            hv_CalcOODScoreHistogram.Dispose();
            hv_CalcOODScoreHistogram = 0;
            hv_CalcOODScoreThresholds.Dispose();
            hv_CalcOODScoreThresholds = 0;
            //
            //Check which measures are to be calculated.
            hv_Measures.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
            for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
            {
                if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual("ood_confusion_matrix"))) != 0)
                {
                    hv_CalcOODConfusionMatrix.Dispose();
                    hv_CalcOODConfusionMatrix = 1;
                }
                else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                    "ood_precision"))) != 0)
                {
                    hv_CalcOODPrecision.Dispose();
                    hv_CalcOODPrecision = 1;
                }
                else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                    "ood_recall"))) != 0)
                {
                    hv_CalcOODRecall.Dispose();
                    hv_CalcOODRecall = 1;
                }
                else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                    "ood_f_score"))) != 0)
                {
                    hv_CalcOODPrecision.Dispose();
                    hv_CalcOODPrecision = 1;
                    hv_CalcOODRecall.Dispose();
                    hv_CalcOODRecall = 1;
                    hv_CalcOODFScore.Dispose();
                    hv_CalcOODFScore = 1;
                }
                else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                    "ood_false_positive_rate"))) != 0)
                {
                    hv_CalcOODFPR.Dispose();
                    hv_CalcOODFPR = 1;
                }
                else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                    "ood_score_histogram"))) != 0)
                {
                    hv_CalcOODScoreHistogram.Dispose();
                    hv_CalcOODScoreHistogram = 1;
                    hv_CalcOODScoreThresholds.Dispose();
                    hv_CalcOODScoreThresholds = 1;
                }
                else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                    "ood_thresholds"))) != 0)
                {
                    hv_CalcOODScoreThresholds.Dispose();
                    hv_CalcOODScoreThresholds = 1;
                }
                else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                    "all"))) != 0)
                {
                    hv_CalcOODConfusionMatrix.Dispose();
                    hv_CalcOODConfusionMatrix = 1;
                    hv_CalcOODScoreHistogram.Dispose();
                    hv_CalcOODScoreHistogram = 1;
                    hv_CalcOODScoreThresholds.Dispose();
                    hv_CalcOODScoreThresholds = 1;
                    hv_CalcOODPrecision.Dispose();
                    hv_CalcOODPrecision = 1;
                    hv_CalcOODRecall.Dispose();
                    hv_CalcOODRecall = 1;
                    hv_CalcOODFScore.Dispose();
                    hv_CalcOODFScore = 1;
                    hv_CalcOODFPR.Dispose();
                    hv_CalcOODFPR = 1;
                }
            }
            //
            if ((int)((new HTuple((new HTuple(hv_CalcOODPrecision.TupleOr(hv_CalcOODRecall))).TupleOr(
                hv_CalcOODFScore))).TupleOr(hv_CalcOODFPR)) != 0)
            {
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_0);
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "ood_measures", hv___Tmp_Ctrl_Dict_Init_0);
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv___Tmp_Ctrl_Dict_Init_0 = HTuple.TupleConstant(
                        "HNULL");
                }
            }
            //
            hv_OODPredictionsID.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_OODPredictionsID = hv_RunningMeasures.TupleGetDictTuple(
                    "ood_predictions");
            }
            hv_OODScoresID.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_OODScoresID = hv_RunningMeasures.TupleGetDictTuple(
                    "ood_scores");
            }
            hv_OODPredictionsOOD.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_OODPredictionsOOD = ((hv_RunningMeasures.TupleGetDictTuple(
                    "evaluated_ood_samples"))).TupleGetDictTuple("ood_predictions");
            }
            hv_OODScoresOOD.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_OODScoresOOD = ((hv_RunningMeasures.TupleGetDictTuple(
                    "evaluated_ood_samples"))).TupleGetDictTuple("ood_scores");
            }
            //Set OOD ground truths, predictions and scores for the evaluated samples in EvaluationResult.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                HOperatorSet.SetDictTuple(hv_EvaluationResult.TupleGetDictTuple("evaluated_samples"),
                    "ood_predictions", hv_OODPredictionsID);
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                HOperatorSet.SetDictTuple(hv_EvaluationResult.TupleGetDictTuple("evaluated_samples"),
                    "ood_scores", hv_OODScoresID);
            }
            hv___Tmp_Ctrl_Dict_Init_1.Dispose();
            HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_1);
            HOperatorSet.SetDictTuple(hv_EvaluationResult, "evaluated_ood_samples", hv___Tmp_Ctrl_Dict_Init_1);
            hv___Tmp_Ctrl_Dict_Init_1.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv___Tmp_Ctrl_Dict_Init_1 = HTuple.TupleConstant(
                    "HNULL");
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv___Tmp_Ctrl_Type.Dispose();
                HOperatorSet.GetDictParam(hv_RunningMeasures.TupleGetDictTuple("evaluated_ood_samples"),
                    "key_data_type", "image_ids", out hv___Tmp_Ctrl_Type);
            }
            if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictObject(((hv_RunningMeasures.TupleGetDictTuple("evaluated_ood_samples"))).TupleGetDictObject(
                        "image_ids"), hv_EvaluationResult.TupleGetDictTuple("evaluated_ood_samples"),
                        "image_ids");
                }
            }
            else
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_EvaluationResult.TupleGetDictTuple("evaluated_ood_samples"),
                        "image_ids", ((hv_RunningMeasures.TupleGetDictTuple("evaluated_ood_samples"))).TupleGetDictTuple(
                        "image_ids"));
                }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                HOperatorSet.SetDictTuple(hv_EvaluationResult.TupleGetDictTuple("evaluated_ood_samples"),
                    "ood_predictions", hv_OODPredictionsOOD);
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                HOperatorSet.SetDictTuple(hv_EvaluationResult.TupleGetDictTuple("evaluated_ood_samples"),
                    "ood_scores", hv_OODScoresOOD);
            }
            //
            hv_NumIDSamples.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_NumIDSamples = new HTuple(hv_OODScoresID.TupleLength()
                    );
            }
            hv_NumOODSamples.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_NumOODSamples = new HTuple(hv_OODScoresOOD.TupleLength()
                    );
            }
            //
            //Calculate OOD confusion matrix.
            if ((int)(hv_CalcOODConfusionMatrix) != 0)
            {
                //Ground truth and predictions are inverted as the matrix sorts by 'class_ids' which do not exist in this case.
                //Instead we want "class 1" - OOD - to be on the left column, s.t. TP are in the upper left corner.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_OODConfusionMatrix.Dispose();
                    gen_confusion_matrix((((HTuple.TupleGenConst(hv_NumIDSamples, 0)).TupleConcat(
                        HTuple.TupleGenConst(hv_NumOODSamples, 1)))).TupleNot(), ((hv_OODPredictionsID.TupleConcat(
                        hv_OODPredictionsOOD))).TupleNot(), "display_matrix", "none", new HTuple(),
                        out hv_OODConfusionMatrix);
                }
                hv_Rows.Dispose(); hv_Columns.Dispose();
                HOperatorSet.GetSizeMatrix(hv_OODConfusionMatrix, out hv_Rows, out hv_Columns);
                if ((int)((new HTuple((new HTuple(hv_NumIDSamples.TupleEqual(0))).TupleOr(
                    new HTuple(hv_NumOODSamples.TupleEqual(0))))).TupleAnd((new HTuple(hv_Rows.TupleLess(
                    2))).TupleOr(new HTuple(hv_Columns.TupleLess(2))))) != 0)
                {
                    //Patch matrix to 2x2 in case only in-distribution or
                    //only out-of-distribution data is used for evaluation.
                    hv_Value.Dispose();
                    HOperatorSet.GetValueMatrix(hv_OODConfusionMatrix, 0, 0, out hv_Value);
                    hv_OODConfusionMatrix.Dispose();
                    HOperatorSet.CreateMatrix(2, 2, 0, out hv_OODConfusionMatrix);
                    if ((int)(new HTuple(hv_NumIDSamples.TupleEqual(0))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetValueMatrix(hv_OODConfusionMatrix, 1, 0, hv_NumOODSamples - hv_Value);
                        }
                        HOperatorSet.SetValueMatrix(hv_OODConfusionMatrix, 0, 0, hv_Value);
                    }
                    if ((int)(new HTuple(hv_NumOODSamples.TupleEqual(0))) != 0)
                    {
                        HOperatorSet.SetValueMatrix(hv_OODConfusionMatrix, 1, 1, hv_Value);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetValueMatrix(hv_OODConfusionMatrix, 0, 1, hv_NumIDSamples - hv_Value);
                        }
                    }
                }
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "ood_confusion_matrix", hv_OODConfusionMatrix);
            }
            //
            //Compute the number of true positives. Append zero to the tuple in case it is empty.
            hv_NumTruePositives.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_NumTruePositives = ((hv_OODPredictionsOOD.TupleConcat(
                    0))).TupleSum();
            }
            //Compute the number of false positives. Append zero to the tuple in case it is empty.
            hv_NumFalsePositives.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_NumFalsePositives = ((hv_OODPredictionsID.TupleConcat(
                    0))).TupleSum();
            }
            //Compute the number of false negatives. Append !zero to the tuple in case it is empty.
            hv_NumFalseNegatives.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_NumFalseNegatives = (new HTuple(((hv_OODPredictionsOOD.TupleConcat(
                    1))).TupleNot())).TupleSum();
            }
            //
            //Calculate OOD detection precision.
            if ((int)(hv_CalcOODPrecision) != 0)
            {
                hv_NumPredictedPositives.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumPredictedPositives = hv_NumTruePositives + hv_NumFalsePositives;
                }
                if ((int)((new HTuple(hv_NumPredictedPositives.TupleGreater(0))).TupleAnd(
                    new HTuple(hv_NumOODSamples.TupleGreater(0)))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvaluationResult.TupleGetDictTuple("ood_measures"),
                            "ood_precision", (hv_NumTruePositives.TupleReal()) / hv_NumPredictedPositives);
                    }
                }
                else
                {
                    //No valid precision value can be computed.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvaluationResult.TupleGetDictTuple("ood_measures"),
                            "ood_precision", -1.0);
                    }
                }
            }
            //
            //Calculate OOD detection recall.
            if ((int)(hv_CalcOODRecall) != 0)
            {
                //Compute the number of true and false positives. Append zero to the tuples in case they are empty.
                if ((int)(new HTuple(hv_NumOODSamples.TupleGreater(0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvaluationResult.TupleGetDictTuple("ood_measures"),
                            "ood_recall", (hv_NumTruePositives.TupleReal()) / hv_NumOODSamples);
                    }
                }
                else
                {
                    //No valid recall value can be computed.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvaluationResult.TupleGetDictTuple("ood_measures"),
                            "ood_recall", -1.0);
                    }
                }
            }
            //
            //Calculate OOD detection F-Score.
            if ((int)(hv_CalcOODFScore) != 0)
            {
                if ((int)(new HTuple(hv_NumOODSamples.TupleGreater(0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvaluationResult.TupleGetDictTuple("ood_measures"),
                            "ood_f_score", (2 * hv_NumTruePositives) / (((2.0 * hv_NumTruePositives) + hv_NumFalsePositives) + hv_NumFalseNegatives));
                    }
                }
                else
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvaluationResult.TupleGetDictTuple("ood_measures"),
                            "ood_f_score", -1.0);
                    }
                }
            }
            //
            //Calculate OOD false-positive-rate.
            if ((int)(hv_CalcOODFPR) != 0)
            {
                if ((int)(new HTuple(hv_NumIDSamples.TupleGreater(0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvaluationResult.TupleGetDictTuple("ood_measures"),
                            "ood_false_positive_rate", (hv_NumFalsePositives.TupleReal()) / hv_NumIDSamples);
                    }
                }
                else
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvaluationResult.TupleGetDictTuple("ood_measures"),
                            "ood_false_positive_rate", -1.0);
                    }
                }
            }
            //
            //Calculate histograms.
            if ((int)(hv_CalcOODScoreHistogram.TupleOr(hv_CalcOODScoreThresholds)) != 0)
            {
                //Calculate histogram for in-distribution images.
                hv_HistoIDXValues.Dispose();
                hv_HistoIDXValues = new HTuple();
                hv_HistoIDYValues.Dispose();
                hv_HistoIDYValues = new HTuple();
                if ((int)(new HTuple(hv_NumIDSamples.TupleNotEqual(0))) != 0)
                {
                    hv_HistoIDXValues.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_HistoIDXValues = hv_OODScoresID.TupleSort()
                            ;
                    }
                    hv_HistoIDYValues.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_HistoIDYValues = ((HTuple.TupleGenSequence(
                            new HTuple(hv_OODScoresID.TupleLength()), 1, -1)).TupleReal()) / hv_NumIDSamples;
                    }
                }
                //
                //Calculate histogram for out-of-distribution images.
                hv_HistoOODXValues.Dispose();
                hv_HistoOODXValues = new HTuple();
                hv_HistoOODYValues.Dispose();
                hv_HistoOODYValues = new HTuple();
                if ((int)(new HTuple(hv_NumOODSamples.TupleNotEqual(0))) != 0)
                {
                    hv_HistoOODXValues.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_HistoOODXValues = hv_OODScoresOOD.TupleSort()
                            ;
                    }
                    hv_HistoOODYValues.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_HistoOODYValues = ((HTuple.TupleGenSequence(
                            1, new HTuple(hv_OODScoresOOD.TupleLength()), 1)).TupleReal()) / hv_NumOODSamples;
                    }
                }
                //
                //Create dictionary for the score histogram.
                hv_ScoreHistogram.Dispose();
                HOperatorSet.CreateDict(out hv_ScoreHistogram);
                HOperatorSet.SetDictTuple(hv_ScoreHistogram, "id_x", hv_HistoIDXValues);
                HOperatorSet.SetDictTuple(hv_ScoreHistogram, "id_y", hv_HistoIDYValues);
                HOperatorSet.SetDictTuple(hv_ScoreHistogram, "ood_x", hv_HistoOODXValues);
                HOperatorSet.SetDictTuple(hv_ScoreHistogram, "ood_y", hv_HistoOODYValues);
                //
                //Set the score histogram in the results dictionary.
                if ((int)(hv_CalcOODScoreHistogram) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "ood_score_histogram", hv_ScoreHistogram);
                }
                //
                hv___Tmp_Ctrl_Dict_Init_3.Dispose();
                HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_3);
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "ood_thresholds", hv___Tmp_Ctrl_Dict_Init_3);
                hv___Tmp_Ctrl_Dict_Init_3.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv___Tmp_Ctrl_Dict_Init_3 = HTuple.TupleConstant(
                        "HNULL");
                }
                hv_ModelThresholdExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "ood_threshold", out hv_ModelThresholdExists);
                if ((int)(hv_ModelThresholdExists) != 0)
                {
                    hv___Tmp_Ctrl_Type.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_data_type", "ood_threshold",
                        out hv___Tmp_Ctrl_Type);
                    if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictObject(hv_EvalParams.TupleGetDictObject("ood_threshold"),
                                hv_EvaluationResult.TupleGetDictTuple("ood_thresholds"), "current_model_threshold");
                        }
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_EvaluationResult.TupleGetDictTuple("ood_thresholds"),
                                "current_model_threshold", hv_EvalParams.TupleGetDictTuple("ood_threshold"));
                        }
                    }
                }
                else
                {
                    throw new HalconException("Cannot find OOD threshold within model.");
                }
                //
                //Calculate suggested thresholds
                if ((int)(new HTuple(hv_HistoIDXValues.TupleNotEqual(new HTuple()))) != 0)
                {
                    //We multiply it, otherwise 1 sample would still be a FP
                    hv_NoFPThreshold.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NoFPThreshold = (hv_HistoIDXValues.TupleMax()
                            ) * 1.000001;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvaluationResult.TupleGetDictTuple("ood_thresholds"),
                            "no_fp_threshold", hv_NoFPThreshold);
                    }
                }
                //
                if ((int)(new HTuple(hv_HistoOODXValues.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_NoFNThreshold.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NoFNThreshold = hv_HistoOODXValues.TupleMin()
                            ;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvaluationResult.TupleGetDictTuple("ood_thresholds"),
                            "no_fn_threshold", hv_NoFNThreshold);
                    }
                }
                //
                if ((int)((new HTuple(hv_HistoOODXValues.TupleNotEqual(new HTuple()))).TupleAnd(
                    new HTuple(hv_HistoIDXValues.TupleNotEqual(new HTuple())))) != 0)
                {
                    hv_OODScores.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_OODScores = new HTuple();
                        hv_OODScores = hv_OODScores.TupleConcat(hv_HistoIDXValues, hv_HistoOODXValues);
                    }
                    //Get minimum and maximum values of the OOD scores.
                    if ((int)(new HTuple(hv_NoFPThreshold.TupleLessEqual(hv_NoFNThreshold))) != 0)
                    {
                        //In this case the ID and OOD samples can be perfectly separated
                        //by a threshold.
                        hv_MinErrorThreshold.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MinErrorThreshold = (hv_NoFPThreshold + hv_NoFNThreshold) / 2.0;
                        }
                    }
                    else
                    {
                        //In this case there will be false positives or false negatives
                        //for any threshold.
                        //
                        //Sort the OOD scores.
                        hv_OODScoresSortIndices.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_OODScoresSortIndices = hv_OODScores.TupleSortIndex()
                                ;
                        }
                        hv_OODScoresSorted.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_OODScoresSorted = hv_OODScores.TupleSelect(
                                hv_OODScoresSortIndices);
                        }
                        //
                        //Compute the false positive rates.
                        hv_TmpID.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TmpID = new HTuple();
                            hv_TmpID = hv_TmpID.TupleConcat(HTuple.TupleGenConst(
                                new HTuple(hv_HistoIDXValues.TupleLength()), 1.0));
                            hv_TmpID = hv_TmpID.TupleConcat(HTuple.TupleGenConst(
                                new HTuple(hv_HistoOODXValues.TupleLength()), 0.0));
                        }
                        hv_TmpIDSorted.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TmpIDSorted = hv_TmpID.TupleSelect(
                                hv_OODScoresSortIndices);
                        }
                        hv_TrueNegativesPerScore.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TrueNegativesPerScore = (hv_TmpIDSorted.TupleCumul()
                                ) - hv_TmpIDSorted;
                        }
                        hv_FPRate.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FPRate = 1.0 - (hv_TrueNegativesPerScore / (new HTuple(hv_HistoIDXValues.TupleLength()
                                )));
                        }
                        //
                        //Compute the false negative rates.
                        hv_TmpOOD.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TmpOOD = new HTuple();
                            hv_TmpOOD = hv_TmpOOD.TupleConcat(HTuple.TupleGenConst(
                                new HTuple(hv_HistoIDXValues.TupleLength()), 0.0));
                            hv_TmpOOD = hv_TmpOOD.TupleConcat(HTuple.TupleGenConst(
                                new HTuple(hv_HistoOODXValues.TupleLength()), 1.0));
                        }
                        hv_TmpOODSorted.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TmpOODSorted = hv_TmpOOD.TupleSelect(
                                hv_OODScoresSortIndices);
                        }
                        hv_FalseNegativesPerScore.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FalseNegativesPerScore = (hv_TmpOODSorted.TupleCumul()
                                ) - hv_TmpOODSorted;
                        }
                        hv_FNRate.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FNRate = hv_FalseNegativesPerScore / (new HTuple(hv_HistoOODXValues.TupleLength()
                                ));
                        }
                        //
                        //Get the threshold for which the sum of the false positive
                        //and false negative rates is the lowest.
                        hv_FprFnrSum.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FprFnrSum = hv_FPRate + hv_FNRate;
                        }
                        hv_MinFprFnRSum.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MinFprFnRSum = hv_FprFnrSum.TupleMin()
                                ;
                        }
                        hv_ThresholdIndex.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ThresholdIndex = hv_FprFnrSum.TupleFindFirst(
                                hv_MinFprFnRSum);
                        }
                        hv_MinErrorThreshold.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MinErrorThreshold = hv_OODScoresSorted.TupleSelect(
                                hv_ThresholdIndex);
                        }
                        //
                        //In some cases MinErrorThreshold may be smaller than NoFNThreshold.
                        //We set it to at least that value.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_MinErrorThreshold = hv_MinErrorThreshold.TupleMax2(
                                    hv_NoFNThreshold);
                                hv_MinErrorThreshold.Dispose();
                                hv_MinErrorThreshold = ExpTmpLocalVar_MinErrorThreshold;
                            }
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvaluationResult.TupleGetDictTuple("ood_thresholds"),
                            "min_error_threshold", hv_MinErrorThreshold);
                    }
                }
                //
            }

            hv_CalcOODConfusionMatrix.Dispose();
            hv_CalcOODPrecision.Dispose();
            hv_CalcOODRecall.Dispose();
            hv_CalcOODFScore.Dispose();
            hv_CalcOODFPR.Dispose();
            hv_CalcOODScoreHistogram.Dispose();
            hv_CalcOODScoreThresholds.Dispose();
            hv_Measures.Dispose();
            hv_M.Dispose();
            hv_OODPredictionsID.Dispose();
            hv_OODScoresID.Dispose();
            hv_OODPredictionsOOD.Dispose();
            hv_OODScoresOOD.Dispose();
            hv_NumIDSamples.Dispose();
            hv_NumOODSamples.Dispose();
            hv_OODConfusionMatrix.Dispose();
            hv_Rows.Dispose();
            hv_Columns.Dispose();
            hv_Value.Dispose();
            hv_NumTruePositives.Dispose();
            hv_NumFalsePositives.Dispose();
            hv_NumFalseNegatives.Dispose();
            hv_NumPredictedPositives.Dispose();
            hv_HistoIDXValues.Dispose();
            hv_HistoIDYValues.Dispose();
            hv_HistoOODXValues.Dispose();
            hv_HistoOODYValues.Dispose();
            hv_ScoreHistogram.Dispose();
            hv_ModelThresholdExists.Dispose();
            hv_NoFPThreshold.Dispose();
            hv_NoFNThreshold.Dispose();
            hv_OODScores.Dispose();
            hv_MinErrorThreshold.Dispose();
            hv_OODScoresSortIndices.Dispose();
            hv_OODScoresSorted.Dispose();
            hv_TmpID.Dispose();
            hv_TmpIDSorted.Dispose();
            hv_TrueNegativesPerScore.Dispose();
            hv_FPRate.Dispose();
            hv_TmpOOD.Dispose();
            hv_TmpOODSorted.Dispose();
            hv_FalseNegativesPerScore.Dispose();
            hv_FNRate.Dispose();
            hv_FprFnrSum.Dispose();
            hv_MinFprFnRSum.Dispose();
            hv_ThresholdIndex.Dispose();
            hv___Tmp_Ctrl_Dict_Init_0.Dispose();
            hv___Tmp_Ctrl_Dict_Init_1.Dispose();
            hv___Tmp_Ctrl_Dict_Init_3.Dispose();
            hv___Tmp_Ctrl_Type.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_CalcOODConfusionMatrix.Dispose();
            hv_CalcOODPrecision.Dispose();
            hv_CalcOODRecall.Dispose();
            hv_CalcOODFScore.Dispose();
            hv_CalcOODFPR.Dispose();
            hv_CalcOODScoreHistogram.Dispose();
            hv_CalcOODScoreThresholds.Dispose();
            hv_Measures.Dispose();
            hv_M.Dispose();
            hv_OODPredictionsID.Dispose();
            hv_OODScoresID.Dispose();
            hv_OODPredictionsOOD.Dispose();
            hv_OODScoresOOD.Dispose();
            hv_NumIDSamples.Dispose();
            hv_NumOODSamples.Dispose();
            hv_OODConfusionMatrix.Dispose();
            hv_Rows.Dispose();
            hv_Columns.Dispose();
            hv_Value.Dispose();
            hv_NumTruePositives.Dispose();
            hv_NumFalsePositives.Dispose();
            hv_NumFalseNegatives.Dispose();
            hv_NumPredictedPositives.Dispose();
            hv_HistoIDXValues.Dispose();
            hv_HistoIDYValues.Dispose();
            hv_HistoOODXValues.Dispose();
            hv_HistoOODYValues.Dispose();
            hv_ScoreHistogram.Dispose();
            hv_ModelThresholdExists.Dispose();
            hv_NoFPThreshold.Dispose();
            hv_NoFNThreshold.Dispose();
            hv_OODScores.Dispose();
            hv_MinErrorThreshold.Dispose();
            hv_OODScoresSortIndices.Dispose();
            hv_OODScoresSorted.Dispose();
            hv_TmpID.Dispose();
            hv_TmpIDSorted.Dispose();
            hv_TrueNegativesPerScore.Dispose();
            hv_FPRate.Dispose();
            hv_TmpOOD.Dispose();
            hv_TmpOODSorted.Dispose();
            hv_FalseNegativesPerScore.Dispose();
            hv_FNRate.Dispose();
            hv_FprFnrSum.Dispose();
            hv_MinFprFnRSum.Dispose();
            hv_ThresholdIndex.Dispose();
            hv___Tmp_Ctrl_Dict_Init_0.Dispose();
            hv___Tmp_Ctrl_Dict_Init_1.Dispose();
            hv___Tmp_Ctrl_Dict_Init_3.Dispose();
            hv___Tmp_Ctrl_Type.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
    // Short Description: Calculate pixel measures based on RunningMeasures. 
    private void calculate_pixel_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
        out HTuple hv_EvaluationResult)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_CalcClassPixelAccuracy = new HTuple();
        HTuple hv_CalcPixelAccuracy = new HTuple(), hv_CalcPixelConfusionMatrix = new HTuple();
        HTuple hv_CalcMeanAccuracy = new HTuple(), hv_CalcMeanPrecision = new HTuple();
        HTuple hv_CalcMeanIou = new HTuple(), hv_CalcClassIou = new HTuple();
        HTuple hv_CalcFWIou = new HTuple(), hv_Measures = new HTuple();
        HTuple hv_EvaluationType = new HTuple(), hv_PixelMeasures = new HTuple();
        HTuple hv_M = new HTuple(), hv_ConfMatrix = new HTuple();
        HTuple hv_TPMat = new HTuple(), hv_TP = new HTuple(), hv_SumRowMat = new HTuple();
        HTuple hv_RowSum = new HTuple(), hv_FP = new HTuple();
        HTuple hv_SumColMat = new HTuple(), hv_ColSum = new HTuple();
        HTuple hv_FN = new HTuple(), hv_IgnoreClassIDs = new HTuple();
        HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
        HTuple hv_FPIgnore = new HTuple(), hv_GT = new HTuple();
        HTuple hv_ClsIdxValid = new HTuple(), hv_ClassPixelAccuracy = new HTuple();
        HTuple hv_MeanAccuracy = new HTuple(), hv_PixelAccuracy = new HTuple();
        HTuple hv_PD = new HTuple(), hv_PDIdxValid = new HTuple();
        HTuple hv_ClassPixelPrecision = new HTuple(), hv_MeanPrecision = new HTuple();
        HTuple hv_ClassIoU = new HTuple(), hv_MeanIoU = new HTuple();
        HTuple hv_FWIoU = new HTuple(), hv_FwWeights = new HTuple();
        // Initialize local and output iconic variables 
        hv_EvaluationResult = new HTuple();
        try
        {
            //
            //This procedure calculates the pixel-wise measures based on the values in running measures.
            //
            //Set default values.
            hv_CalcClassPixelAccuracy.Dispose();
            hv_CalcClassPixelAccuracy = 0;
            hv_CalcPixelAccuracy.Dispose();
            hv_CalcPixelAccuracy = 0;
            hv_CalcPixelConfusionMatrix.Dispose();
            hv_CalcPixelConfusionMatrix = 0;
            hv_CalcMeanAccuracy.Dispose();
            hv_CalcMeanAccuracy = 0;
            hv_CalcMeanPrecision.Dispose();
            hv_CalcMeanPrecision = 0;
            hv_CalcMeanIou.Dispose();
            hv_CalcMeanIou = 0;
            hv_CalcClassIou.Dispose();
            hv_CalcClassIou = 0;
            hv_CalcFWIou.Dispose();
            hv_CalcFWIou = 0;
            hv_EvaluationResult.Dispose();
            HOperatorSet.CreateDict(out hv_EvaluationResult);
            //
            //Check which measures are to be calculated.
            hv_Measures.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
            hv_EvaluationType.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
            hv_PixelMeasures.Dispose();
            get_requested_pixel_measures(hv_Measures, hv_EvaluationType, out hv_PixelMeasures);
            if ((int)(new HTuple((new HTuple(hv_PixelMeasures.TupleLength())).TupleEqual(
                0))) != 0)
            {

                hv_CalcClassPixelAccuracy.Dispose();
                hv_CalcPixelAccuracy.Dispose();
                hv_CalcPixelConfusionMatrix.Dispose();
                hv_CalcMeanAccuracy.Dispose();
                hv_CalcMeanPrecision.Dispose();
                hv_CalcMeanIou.Dispose();
                hv_CalcClassIou.Dispose();
                hv_CalcFWIou.Dispose();
                hv_Measures.Dispose();
                hv_EvaluationType.Dispose();
                hv_PixelMeasures.Dispose();
                hv_M.Dispose();
                hv_ConfMatrix.Dispose();
                hv_TPMat.Dispose();
                hv_TP.Dispose();
                hv_SumRowMat.Dispose();
                hv_RowSum.Dispose();
                hv_FP.Dispose();
                hv_SumColMat.Dispose();
                hv_ColSum.Dispose();
                hv_FN.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_FPIgnore.Dispose();
                hv_GT.Dispose();
                hv_ClsIdxValid.Dispose();
                hv_ClassPixelAccuracy.Dispose();
                hv_MeanAccuracy.Dispose();
                hv_PixelAccuracy.Dispose();
                hv_PD.Dispose();
                hv_PDIdxValid.Dispose();
                hv_ClassPixelPrecision.Dispose();
                hv_MeanPrecision.Dispose();
                hv_ClassIoU.Dispose();
                hv_MeanIoU.Dispose();
                hv_FWIoU.Dispose();
                hv_FwWeights.Dispose();

                return;
            }
            //
            for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_PixelMeasures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
            {
                if ((int)(new HTuple(((hv_PixelMeasures.TupleSelect(hv_M))).TupleEqual("pixel_accuracy"))) != 0)
                {
                    hv_CalcPixelAccuracy.Dispose();
                    hv_CalcPixelAccuracy = 1;
                }
                else if ((int)(new HTuple(((hv_PixelMeasures.TupleSelect(hv_M))).TupleEqual(
                    "class_pixel_accuracy"))) != 0)
                {
                    hv_CalcClassPixelAccuracy.Dispose();
                    hv_CalcClassPixelAccuracy = 1;
                }
                else if ((int)(new HTuple(((hv_PixelMeasures.TupleSelect(hv_M))).TupleEqual(
                    "pixel_confusion_matrix"))) != 0)
                {
                    hv_CalcPixelConfusionMatrix.Dispose();
                    hv_CalcPixelConfusionMatrix = 1;
                }
                else if ((int)(new HTuple(((hv_PixelMeasures.TupleSelect(hv_M))).TupleEqual(
                    "mean_accuracy"))) != 0)
                {
                    hv_CalcMeanAccuracy.Dispose();
                    hv_CalcMeanAccuracy = 1;
                }
                else if ((int)(new HTuple(((hv_PixelMeasures.TupleSelect(hv_M))).TupleEqual(
                    "mean_precision"))) != 0)
                {
                    hv_CalcMeanPrecision.Dispose();
                    hv_CalcMeanPrecision = 1;
                }
                else if ((int)(new HTuple(((hv_PixelMeasures.TupleSelect(hv_M))).TupleEqual(
                    "mean_iou"))) != 0)
                {
                    hv_CalcMeanIou.Dispose();
                    hv_CalcMeanIou = 1;
                }
                else if ((int)(new HTuple(((hv_PixelMeasures.TupleSelect(hv_M))).TupleEqual(
                    "class_iou"))) != 0)
                {
                    hv_CalcClassIou.Dispose();
                    hv_CalcClassIou = 1;
                }
                else if ((int)(new HTuple(((hv_PixelMeasures.TupleSelect(hv_M))).TupleEqual(
                    "frequency_weighted_iou"))) != 0)
                {
                    hv_CalcFWIou.Dispose();
                    hv_CalcFWIou = 1;
                }
                else
                {
                    throw new HalconException("Unknown pixel measure: " + (hv_PixelMeasures.TupleSelect(
                        hv_M)));
                }
            }
            //
            //Depending on the running measure values (ConfusionMatrix or TP/FP/FN),
            //we first calculate TP/FP/FN from the ConfusionMatrix.
            if ((int)(hv_CalcPixelConfusionMatrix) != 0)
            {
                //Get the running measures.
                hv_ConfMatrix.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix", out hv_ConfMatrix);
                //Get the per-class true positives as the diagonal of the matrix.
                hv_TPMat.Dispose();
                HOperatorSet.GetDiagonalMatrix(hv_ConfMatrix, 0, out hv_TPMat);
                hv_TP.Dispose();
                HOperatorSet.GetFullMatrix(hv_TPMat, out hv_TP);
                //For the confusion matrix, the row determines the predicted class-IDs,
                //the column determines the ground truth class-IDs.
                //Get the per-class false positives (FP) as the sum over the rows minus the diagonal (TP).
                hv_SumRowMat.Dispose();
                HOperatorSet.SumMatrix(hv_ConfMatrix, "rows", out hv_SumRowMat);
                hv_RowSum.Dispose();
                HOperatorSet.GetFullMatrix(hv_SumRowMat, out hv_RowSum);
                hv_FP.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_FP = hv_RowSum - hv_TP;
                }
                //Get the per-class false negatives (FN) as the sum over the columns minus the diagonal (TP).
                hv_SumColMat.Dispose();
                HOperatorSet.SumMatrix(hv_ConfMatrix, "columns", out hv_SumColMat);
                hv_ColSum.Dispose();
                HOperatorSet.GetFullMatrix(hv_SumColMat, out hv_ColSum);
                hv_FN.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_FN = hv_ColSum - hv_TP;
                }
                //We do not want to count the false positives (FP) in the ignore region.
                //The false negatives (FN) are not affected, since the model does not predict the ignore class.
                hv_IgnoreClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "ignore_class_ids", out hv_IgnoreClassIDs);
                if ((int)(new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    //The ignore class corresponds to the last row/column in the confusion matrix.
                    hv_Rows.Dispose(); hv_Columns.Dispose();
                    HOperatorSet.GetSizeMatrix(hv_ConfMatrix, out hv_Rows, out hv_Columns);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FPIgnore.Dispose();
                        HOperatorSet.GetValueMatrix(hv_ConfMatrix, HTuple.TupleGenSequence(0, hv_Rows - 1, 1),
                            HTuple.TupleGenConst(hv_Rows, hv_Columns - 1), out hv_FPIgnore);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_FP = hv_FP - hv_FPIgnore;
                            hv_FP.Dispose();
                            hv_FP = ExpTmpLocalVar_FP;
                        }
                    }
                    //Remove last entries of TP, FP, FN (those related to the ignore class).
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TP = hv_TP.TupleSelectRange(
                                0, (new HTuple(hv_TP.TupleLength())) - 2);
                            hv_TP.Dispose();
                            hv_TP = ExpTmpLocalVar_TP;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_FP = hv_FP.TupleSelectRange(
                                0, (new HTuple(hv_FP.TupleLength())) - 2);
                            hv_FP.Dispose();
                            hv_FP = ExpTmpLocalVar_FP;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_FN = hv_FN.TupleSelectRange(
                                0, (new HTuple(hv_FN.TupleLength())) - 2);
                            hv_FN.Dispose();
                            hv_FN = ExpTmpLocalVar_FN;
                        }
                    }
                    //Remove last row/column from confusion matrix.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.GetSubMatrix(hv_ConfMatrix, 0, 0, hv_Rows - 1, hv_Columns - 1,
                            out ExpTmpOutVar_0);
                        hv_ConfMatrix.Dispose();
                        hv_ConfMatrix = ExpTmpOutVar_0;
                    }
                }
                //Paste the confusion matrix to the output.
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "pixel_confusion_matrix",
                    hv_ConfMatrix);
            }
            else
            {
                //Get the running measure values.
                hv_TP.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "tp", out hv_TP);
                hv_FP.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "fp", out hv_FP);
                hv_FN.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "fn", out hv_FN);
            }
            //
            //It might be the case, that some of the classes are not present in the set of validation images.
            //--> Exclude these classes (they are indirectly present as they reduce the number of TP for other classes).
            hv_GT.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_GT = hv_TP + hv_FN;
            }
            hv_ClsIdxValid.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_ClsIdxValid = ((hv_GT.TupleGreaterElem(
                    0))).TupleFind(1);
            }
            //
            //Mean Accuracy, Class Pixel Accuracy.
            //-> If one of 'mean_accuracy', 'class_pixel_accuracy' is specified, we give back both of them
            //   as they have to be calculated anyway (to the most part).
            if ((int)(hv_CalcClassPixelAccuracy.TupleOr(hv_CalcMeanAccuracy)) != 0)
            {
                //Compute pixel accuracy per class (although we might only use it for the overall pixel accuracy).
                hv_ClassPixelAccuracy.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ClassPixelAccuracy = HTuple.TupleGenConst(
                        new HTuple(hv_GT.TupleLength()), -1);
                }
                hv_MeanAccuracy.Dispose();
                hv_MeanAccuracy = -1;
                if ((int)(new HTuple(((hv_ClsIdxValid.TupleSelect(0))).TupleGreater(-1))) != 0)
                {
                    if (hv_ClassPixelAccuracy == null)
                        hv_ClassPixelAccuracy = new HTuple();
                    hv_ClassPixelAccuracy[hv_ClsIdxValid] = (((hv_TP.TupleSelect(hv_ClsIdxValid))).TupleReal()
                        ) / (hv_GT.TupleSelect(hv_ClsIdxValid));
                    hv_MeanAccuracy.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MeanAccuracy = ((hv_ClassPixelAccuracy.TupleSelect(
                            hv_ClsIdxValid))).TupleMean();
                    }
                }
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "class_pixel_accuracy", hv_ClassPixelAccuracy);
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_accuracy", hv_MeanAccuracy);
            }
            //Pixel Accuracy.
            if ((int)(hv_CalcPixelAccuracy) != 0)
            {
                //Compute pixel accuracy as the total ratio of pixels that have been correctly predicted.
                hv_PixelAccuracy.Dispose();
                hv_PixelAccuracy = -1;
                if ((int)(new HTuple(((hv_ClsIdxValid.TupleSelect(0))).TupleGreater(-1))) != 0)
                {
                    hv_PixelAccuracy.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_PixelAccuracy = (((((hv_TP.TupleSelect(
                            hv_ClsIdxValid))).TupleSum())).TupleReal()) / (((hv_GT.TupleSelect(hv_ClsIdxValid))).TupleSum()
                            );
                    }
                }
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "pixel_accuracy", hv_PixelAccuracy);
            }
            //Mean Precision.
            //-> Also includes precisions for each of the classes which are
            //   used to calculate the mean precision.
            if ((int)(hv_CalcMeanPrecision) != 0)
            {
                //Compute pixel-level precision averaged over all classes.
                hv_PD.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PD = hv_TP + hv_FP;
                }
                hv_PDIdxValid.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PDIdxValid = ((hv_PD.TupleGreaterElem(
                        0.0))).TupleFind(1);
                }
                hv_ClassPixelPrecision.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ClassPixelPrecision = HTuple.TupleGenConst(
                        new HTuple(hv_PD.TupleLength()), -1);
                }
                hv_MeanPrecision.Dispose();
                hv_MeanPrecision = -1;
                if ((int)(new HTuple(((hv_PDIdxValid.TupleSelect(0))).TupleGreater(-1))) != 0)
                {
                    if (hv_ClassPixelPrecision == null)
                        hv_ClassPixelPrecision = new HTuple();
                    hv_ClassPixelPrecision[hv_PDIdxValid] = (((hv_TP.TupleSelect(hv_PDIdxValid))).TupleReal()
                        ) / (hv_PD.TupleSelect(hv_PDIdxValid));
                    hv_MeanPrecision.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MeanPrecision = ((hv_ClassPixelPrecision.TupleSelect(
                            hv_PDIdxValid))).TupleMean();
                    }
                }
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_precision", hv_MeanPrecision);
            }
            //Mean IoU, class IoU, frequency weighted IoU:
            //-> If the measures 'class_iou', 'mean_iou' or 'frequency_weighted_iou' is specified,
            //   we return all three of them as they have to be calculated anyway (to the most part).
            if ((int)((new HTuple(hv_CalcMeanIou.TupleOr(hv_CalcClassIou))).TupleOr(hv_CalcFWIou)) != 0)
            {
                hv_ClassIoU.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ClassIoU = HTuple.TupleGenConst(
                        new HTuple(hv_GT.TupleLength()), -1);
                }
                hv_MeanIoU.Dispose();
                hv_MeanIoU = -1;
                hv_FWIoU.Dispose();
                hv_FWIoU = -1;
                if ((int)(new HTuple(((hv_ClsIdxValid.TupleSelect(0))).TupleGreater(-1))) != 0)
                {
                    if (hv_ClassIoU == null)
                        hv_ClassIoU = new HTuple();
                    hv_ClassIoU[hv_ClsIdxValid] = (((hv_TP.TupleSelect(hv_ClsIdxValid))).TupleReal()
                        ) / ((hv_GT.TupleSelect(hv_ClsIdxValid)) + (hv_FP.TupleSelect(hv_ClsIdxValid)));
                    hv_MeanIoU.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MeanIoU = ((hv_ClassIoU.TupleSelect(
                            hv_ClsIdxValid))).TupleMean();
                    }
                    hv_FwWeights.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FwWeights = (hv_GT.TupleReal()
                            ) / (hv_GT.TupleSum());
                    }
                    hv_FWIoU.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FWIoU = (((hv_FwWeights.TupleSelect(
                            hv_ClsIdxValid)) * (hv_ClassIoU.TupleSelect(hv_ClsIdxValid)))).TupleSum()
                            ;
                    }
                }
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "class_iou", hv_ClassIoU);
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_iou", hv_MeanIoU);
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "frequency_weighted_iou",
                    hv_FWIoU);
            }
            //

            hv_CalcClassPixelAccuracy.Dispose();
            hv_CalcPixelAccuracy.Dispose();
            hv_CalcPixelConfusionMatrix.Dispose();
            hv_CalcMeanAccuracy.Dispose();
            hv_CalcMeanPrecision.Dispose();
            hv_CalcMeanIou.Dispose();
            hv_CalcClassIou.Dispose();
            hv_CalcFWIou.Dispose();
            hv_Measures.Dispose();
            hv_EvaluationType.Dispose();
            hv_PixelMeasures.Dispose();
            hv_M.Dispose();
            hv_ConfMatrix.Dispose();
            hv_TPMat.Dispose();
            hv_TP.Dispose();
            hv_SumRowMat.Dispose();
            hv_RowSum.Dispose();
            hv_FP.Dispose();
            hv_SumColMat.Dispose();
            hv_ColSum.Dispose();
            hv_FN.Dispose();
            hv_IgnoreClassIDs.Dispose();
            hv_Rows.Dispose();
            hv_Columns.Dispose();
            hv_FPIgnore.Dispose();
            hv_GT.Dispose();
            hv_ClsIdxValid.Dispose();
            hv_ClassPixelAccuracy.Dispose();
            hv_MeanAccuracy.Dispose();
            hv_PixelAccuracy.Dispose();
            hv_PD.Dispose();
            hv_PDIdxValid.Dispose();
            hv_ClassPixelPrecision.Dispose();
            hv_MeanPrecision.Dispose();
            hv_ClassIoU.Dispose();
            hv_MeanIoU.Dispose();
            hv_FWIoU.Dispose();
            hv_FwWeights.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_CalcClassPixelAccuracy.Dispose();
            hv_CalcPixelAccuracy.Dispose();
            hv_CalcPixelConfusionMatrix.Dispose();
            hv_CalcMeanAccuracy.Dispose();
            hv_CalcMeanPrecision.Dispose();
            hv_CalcMeanIou.Dispose();
            hv_CalcClassIou.Dispose();
            hv_CalcFWIou.Dispose();
            hv_Measures.Dispose();
            hv_EvaluationType.Dispose();
            hv_PixelMeasures.Dispose();
            hv_M.Dispose();
            hv_ConfMatrix.Dispose();
            hv_TPMat.Dispose();
            hv_TP.Dispose();
            hv_SumRowMat.Dispose();
            hv_RowSum.Dispose();
            hv_FP.Dispose();
            hv_SumColMat.Dispose();
            hv_ColSum.Dispose();
            hv_FN.Dispose();
            hv_IgnoreClassIDs.Dispose();
            hv_Rows.Dispose();
            hv_Columns.Dispose();
            hv_FPIgnore.Dispose();
            hv_GT.Dispose();
            hv_ClsIdxValid.Dispose();
            hv_ClassPixelAccuracy.Dispose();
            hv_MeanAccuracy.Dispose();
            hv_PixelAccuracy.Dispose();
            hv_PD.Dispose();
            hv_PDIdxValid.Dispose();
            hv_ClassPixelPrecision.Dispose();
            hv_MeanPrecision.Dispose();
            hv_ClassIoU.Dispose();
            hv_MeanIoU.Dispose();
            hv_FWIoU.Dispose();
            hv_FwWeights.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Model
    // Short Description: Calculate region measures based on running measure values. 
    private void calculate_region_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
        out HTuple hv_EvaluationResult)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_CalcMeanPRO = new HTuple(), hv_Measures = new HTuple();
        HTuple hv_M = new HTuple(), hv_ClsIdxValid = new HTuple();
        HTuple hv_ClassPRO = new HTuple(), hv_MeanPRO = new HTuple();
        // Initialize local and output iconic variables 
        hv_EvaluationResult = new HTuple();
        try
        {
            //
            //This procedure calculates the region measures based on the
            //values in running measures.
            //
            //Set default values.
            hv_CalcMeanPRO.Dispose();
            hv_CalcMeanPRO = 0;
            hv_EvaluationResult.Dispose();
            HOperatorSet.CreateDict(out hv_EvaluationResult);
            //
            //Check which measures are to be calculated.
            hv_Measures.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
            for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
            {
                if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual("mean_pro"))) != 0)
                {
                    hv_CalcMeanPRO.Dispose();
                    hv_CalcMeanPRO = 1;
                }
                else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                    "all"))) != 0)
                {
                    hv_CalcMeanPRO.Dispose();
                    hv_CalcMeanPRO = 1;
                }
            }
            //
            if ((int)(hv_CalcMeanPRO) != 0)
            {
                //It might be the case, that some of the classes are not present
                //in the set of evaluation images and are excluded.
                hv_ClsIdxValid.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ClsIdxValid = ((((hv_RunningMeasures.TupleGetDictTuple(
                        "num_gt_regions"))).TupleGreaterElem(0))).TupleFind(1);
                }
                //
                //Compute per-region-overlap averaged over the valid classes.
                hv_ClassPRO.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ClassPRO = HTuple.TupleGenConst(
                        new HTuple(((hv_RunningMeasures.TupleGetDictTuple("num_gt_regions"))).TupleLength()
                        ), -1);
                }
                hv_MeanPRO.Dispose();
                hv_MeanPRO = -1;
                if ((int)(new HTuple(((hv_ClsIdxValid.TupleSelect(0))).TupleGreater(-1))) != 0)
                {
                    if (hv_ClassPRO == null)
                        hv_ClassPRO = new HTuple();
                    hv_ClassPRO[hv_ClsIdxValid] = (((hv_RunningMeasures.TupleGetDictTuple("gt_overlap"))).TupleSelect(
                        hv_ClsIdxValid)) / (((((hv_RunningMeasures.TupleGetDictTuple("num_gt_regions"))).TupleSelect(
                        hv_ClsIdxValid))).TupleReal());
                    hv_MeanPRO.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MeanPRO = ((hv_ClassPRO.TupleSelect(
                            hv_ClsIdxValid))).TupleMean();
                    }
                }
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_pro", hv_MeanPRO);
            }
            //

            hv_CalcMeanPRO.Dispose();
            hv_Measures.Dispose();
            hv_M.Dispose();
            hv_ClsIdxValid.Dispose();
            hv_ClassPRO.Dispose();
            hv_MeanPRO.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_CalcMeanPRO.Dispose();
            hv_Measures.Dispose();
            hv_M.Dispose();
            hv_ClsIdxValid.Dispose();
            hv_ClassPRO.Dispose();
            hv_MeanPRO.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: 3D Matching / 3D Gripping Point Detection
    // Short Description: Calculate 3D gripping point measures based on RunningMeasures. 
    private void calculate_running_gripping_point_measures(HTuple hv_RunningMeasures,
        HTuple hv_EvalParams, out HTuple hv_EvaluationResult)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_Positives = new HTuple(), hv_GT = new HTuple();
        HTuple hv_Precision = new HTuple(), hv_Recall = new HTuple();
        HTuple hv_SumPrecisionRecall = new HTuple(), hv_FScore = new HTuple();
        // Initialize local and output iconic variables 
        hv_EvaluationResult = new HTuple();
        try
        {
            hv_EvaluationResult.Dispose();
            HOperatorSet.CreateDict(out hv_EvaluationResult);
            if ((int)(new HTuple((new HTuple((new HTuple(((hv_EvalParams.TupleGetDictTuple(
                "measures"))).TupleRegexpSelect("gripping_point_.*|all"))).TupleLength()
                )).TupleGreater(0))) != 0)
            {
                hv_Positives.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Positives = (hv_RunningMeasures.TupleGetDictTuple(
                        "gp_tp")) + (hv_RunningMeasures.TupleGetDictTuple("gp_fp"));
                }
                hv_GT.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_GT = (hv_RunningMeasures.TupleGetDictTuple(
                        "gp_tp")) + (hv_RunningMeasures.TupleGetDictTuple("gp_fn"));
                }
                if ((int)(new HTuple(hv_Positives.TupleGreater(0.0))) != 0)
                {
                    hv_Precision.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Precision = (hv_RunningMeasures.TupleGetDictTuple(
                            "gp_tp")) / hv_Positives;
                    }
                }
                else
                {
                    hv_Precision.Dispose();
                    hv_Precision = 0.0;
                }
                if ((int)(new HTuple(hv_GT.TupleGreater(0.0))) != 0)
                {
                    hv_Recall.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Recall = (hv_RunningMeasures.TupleGetDictTuple(
                            "gp_tp")) / hv_GT;
                    }
                }
                else
                {
                    hv_Recall.Dispose();
                    hv_Recall = 0.0;
                }
                hv_SumPrecisionRecall.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SumPrecisionRecall = hv_Precision + hv_Recall;
                }
                if ((int)(new HTuple(hv_SumPrecisionRecall.TupleGreater(0.0))) != 0)
                {
                    hv_FScore.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FScore = ((2 * hv_Precision) * hv_Recall) / hv_SumPrecisionRecall;
                    }
                }
                else
                {
                    hv_FScore.Dispose();
                    hv_FScore = 0.0;
                }
                if ((int)(new HTuple((new HTuple((new HTuple(((hv_EvalParams.TupleGetDictTuple(
                    "measures"))).TupleRegexpSelect("gripping_point_precision|all"))).TupleLength()
                    )).TupleGreater(0))) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "gripping_point_precision",
                        hv_Precision);
                }
                if ((int)(new HTuple((new HTuple((new HTuple(((hv_EvalParams.TupleGetDictTuple(
                    "measures"))).TupleRegexpSelect("gripping_point_recall|all"))).TupleLength()
                    )).TupleGreater(0))) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "gripping_point_recall",
                        hv_Recall);
                }
                if ((int)(new HTuple((new HTuple((new HTuple(((hv_EvalParams.TupleGetDictTuple(
                    "measures"))).TupleRegexpSelect("gripping_point_f_score|all"))).TupleLength()
                    )).TupleGreater(0))) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "gripping_point_f_score",
                        hv_FScore);
                }
            }

            hv_Positives.Dispose();
            hv_GT.Dispose();
            hv_Precision.Dispose();
            hv_Recall.Dispose();
            hv_SumPrecisionRecall.Dispose();
            hv_FScore.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_Positives.Dispose();
            hv_GT.Dispose();
            hv_Precision.Dispose();
            hv_Recall.Dispose();
            hv_SumPrecisionRecall.Dispose();
            hv_FScore.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: 3D Matching / 3D Gripping Point Detection
    // Short Description: Initialize and check parameter for the generation of 3D gripping points and poses. 
    public void check_dl_3d_gripping_points_and_poses_params(HTuple hv_DLGrippingPointParams)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_HasMinAreaSize = new HTuple(), hv_HasSortingDir = new HTuple();
        HTuple hv_SortingDirectionRaw = new HTuple(), hv_LenSortingDirectionRaw = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            hv_HasMinAreaSize.Dispose();
            HOperatorSet.GetDictParam(hv_DLGrippingPointParams, "key_exists", "min_area_size",
                out hv_HasMinAreaSize);
            if ((int)(hv_HasMinAreaSize) != 0)
            {
                if ((int)(new HTuple(((hv_DLGrippingPointParams.TupleGetDictTuple("min_area_size"))).TupleLessEqual(
                    0))) != 0)
                {
                    throw new HalconException("DLGrippingPointParams.min_area_size has to be at least 1.");
                }
            }
            else
            {
                HOperatorSet.SetDictTuple(hv_DLGrippingPointParams, "min_area_size", 1);
            }
            //
            hv_HasSortingDir.Dispose();
            HOperatorSet.GetDictParam(hv_DLGrippingPointParams, "key_exists", "sorting_direction",
                out hv_HasSortingDir);
            if ((int)(hv_HasSortingDir) != 0)
            {
                if ((int)(new HTuple((new HTuple(((hv_DLGrippingPointParams.TupleGetDictTuple(
                    "sorting_direction"))).TupleLength())).TupleNotEqual(3))) != 0)
                {
                    throw new HalconException("DLGrippingPointParams.sorting_direction has to be a 3D-vector.");
                }
                hv_SortingDirectionRaw.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SortingDirectionRaw = hv_DLGrippingPointParams.TupleGetDictTuple(
                        "sorting_direction");
                }
                hv_LenSortingDirectionRaw.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_LenSortingDirectionRaw = ((((hv_SortingDirectionRaw * hv_SortingDirectionRaw)).TupleSum()
                        )).TupleSqrt();
                }
                if ((int)(new HTuple(hv_LenSortingDirectionRaw.TupleLess(1.0e-06))) != 0)
                {
                    throw new HalconException("DLGrippingPointParams.sorting_direction must not be the zero-vector.");
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_DLGrippingPointParams, "sorting_direction",
                        hv_SortingDirectionRaw / hv_LenSortingDirectionRaw);
                }
            }
            else
            {
                HOperatorSet.SetDictTuple(hv_DLGrippingPointParams, "sorting_direction",
                    ((new HTuple(0.0)).TupleConcat(0.0)).TupleConcat(0.1));
            }

            hv_HasMinAreaSize.Dispose();
            hv_HasSortingDir.Dispose();
            hv_SortingDirectionRaw.Dispose();
            hv_LenSortingDirectionRaw.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_HasMinAreaSize.Dispose();
            hv_HasSortingDir.Dispose();
            hv_SortingDirectionRaw.Dispose();
            hv_LenSortingDirectionRaw.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
    // Short Description: Check if scores of a Global Context Anomaly Detection model have been normalized 
    public void check_dl_gc_anomaly_scores_normalization(HTuple hv_DLModelHandle,
        HTuple hv_GenParam)
    {



        // Local iconic variables 

        HObject ho_Weights = null, ho_Bias = null;

        // Local control variables 

        HTuple hv_DLModelIsConverted = new HTuple();
        HTuple hv_Networks = new HTuple(), hv_HasLocalNetwork = new HTuple();
        HTuple hv_HasGlobalNetwork = new HTuple(), hv_NormalizationLayers = new HTuple();
        HTuple hv_Index = new HTuple(), hv_LayerName = new HTuple();
        HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
        HTuple hv_WeightsValues = new HTuple(), hv_HasDefaultWeights = new HTuple();
        HTuple hv_BiasValues = new HTuple(), hv_HasDefaultBias = new HTuple();
        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Weights);
        HOperatorSet.GenEmptyObj(out ho_Bias);
        try
        {
            //This procedure checks if all gc anomaly scores have been normalized.
            //
            //Make sure GenParam is an empty tuple.
            if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
            {
                throw new HalconException("The parameter GenParam must be an empty tuple.");
            }
            //
            //For models using an AI accelerator interface for inference, the
            //weights of internal layers are no longer available. They are
            //removed to reduce the memory footprint of the model. Therefore
            //we have no means to check if the gc anomaly scores have been
            //normalized, and thus we assume that this is already the case.
            hv_DLModelIsConverted.Dispose();
            HOperatorSet.GetDlModelParam(hv_DLModelHandle, "precision_is_converted", out hv_DLModelIsConverted);
            if ((int)(new HTuple(hv_DLModelIsConverted.TupleEqual("true"))) != 0)
            {
                ho_Weights.Dispose();
                ho_Bias.Dispose();

                hv_DLModelIsConverted.Dispose();
                hv_Networks.Dispose();
                hv_HasLocalNetwork.Dispose();
                hv_HasGlobalNetwork.Dispose();
                hv_NormalizationLayers.Dispose();
                hv_Index.Dispose();
                hv_LayerName.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_WeightsValues.Dispose();
                hv_HasDefaultWeights.Dispose();
                hv_BiasValues.Dispose();
                hv_HasDefaultBias.Dispose();

                return;
            }
            //
            //Find networks to be normalized.
            hv_Networks.Dispose();
            HOperatorSet.GetDlModelParam(hv_DLModelHandle, "gc_anomaly_networks", out hv_Networks);
            hv_HasLocalNetwork.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_HasLocalNetwork = new HTuple(((hv_Networks.TupleFind(
                    "local"))).TupleNotEqual(-1));
            }
            hv_HasGlobalNetwork.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_HasGlobalNetwork = new HTuple(((hv_Networks.TupleFind(
                    "global"))).TupleNotEqual(-1));
            }
            hv_NormalizationLayers.Dispose();
            hv_NormalizationLayers = new HTuple();
            if ((int)(hv_HasLocalNetwork) != 0)
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_NormalizationLayers = hv_NormalizationLayers.TupleConcat(
                            "local_normalization");
                        hv_NormalizationLayers.Dispose();
                        hv_NormalizationLayers = ExpTmpLocalVar_NormalizationLayers;
                    }
                }
            }
            if ((int)(hv_HasGlobalNetwork) != 0)
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_NormalizationLayers = hv_NormalizationLayers.TupleConcat(
                            "global_normalization");
                        hv_NormalizationLayers.Dispose();
                        hv_NormalizationLayers = ExpTmpLocalVar_NormalizationLayers;
                    }
                }
            }
            //
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_NormalizationLayers.TupleLength()
                )) - 1); hv_Index = (int)hv_Index + 1)
            {
                hv_LayerName.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_LayerName = hv_NormalizationLayers.TupleSelect(
                        hv_Index);
                }
                ho_Weights.Dispose();
                HOperatorSet.GetDlModelLayerWeights(out ho_Weights, hv_DLModelHandle, hv_LayerName,
                    "weights");
                hv_Rows.Dispose(); hv_Columns.Dispose();
                HOperatorSet.GetRegionPoints(ho_Weights, out hv_Rows, out hv_Columns);
                hv_WeightsValues.Dispose();
                HOperatorSet.GetGrayval(ho_Weights, hv_Rows, hv_Columns, out hv_WeightsValues);
                //Calculate if weights are equal since some floating point arithmetic
                //is involved in their creation.
                hv_HasDefaultWeights.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HasDefaultWeights = new HTuple(((((((new HTuple(hv_WeightsValues.TupleLength()
                        )) * hv_WeightsValues) - HTuple.TupleGenConst(new HTuple(hv_WeightsValues.TupleLength()
                        ), 1.0))).TupleAbs())).TupleLess((new HTuple(hv_WeightsValues.TupleLength()
                        )) * 1e-6));
                }
                //
                ho_Bias.Dispose();
                HOperatorSet.GetDlModelLayerWeights(out ho_Bias, hv_DLModelHandle, hv_LayerName,
                    "bias");
                hv_Rows.Dispose(); hv_Columns.Dispose();
                HOperatorSet.GetRegionPoints(ho_Bias, out hv_Rows, out hv_Columns);
                hv_BiasValues.Dispose();
                HOperatorSet.GetGrayval(ho_Bias, hv_Rows, hv_Columns, out hv_BiasValues);
                //The bias is set directly, hence an equality check is sufficient.
                hv_HasDefaultBias.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HasDefaultBias = new HTuple(hv_BiasValues.TupleEqual(
                        HTuple.TupleGenConst(new HTuple(hv_BiasValues.TupleLength()), 0.0)));
                }
                //
                if ((int)(hv_HasDefaultWeights.TupleAnd(hv_HasDefaultBias)) != 0)
                {
                    throw new HalconException(new HTuple("For a model of type gc_anomaly_detection, the anomaly scores must be normalized first."));
                }
            }
            //
            ho_Weights.Dispose();
            ho_Bias.Dispose();

            hv_DLModelIsConverted.Dispose();
            hv_Networks.Dispose();
            hv_HasLocalNetwork.Dispose();
            hv_HasGlobalNetwork.Dispose();
            hv_NormalizationLayers.Dispose();
            hv_Index.Dispose();
            hv_LayerName.Dispose();
            hv_Rows.Dispose();
            hv_Columns.Dispose();
            hv_WeightsValues.Dispose();
            hv_HasDefaultWeights.Dispose();
            hv_BiasValues.Dispose();
            hv_HasDefaultBias.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_Weights.Dispose();
            ho_Bias.Dispose();

            hv_DLModelIsConverted.Dispose();
            hv_Networks.Dispose();
            hv_HasLocalNetwork.Dispose();
            hv_HasGlobalNetwork.Dispose();
            hv_NormalizationLayers.Dispose();
            hv_Index.Dispose();
            hv_LayerName.Dispose();
            hv_Rows.Dispose();
            hv_Columns.Dispose();
            hv_WeightsValues.Dispose();
            hv_HasDefaultWeights.Dispose();
            hv_BiasValues.Dispose();
            hv_HasDefaultBias.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Multi-Label Classification
    // Short Description: Sets flags for the requested multi-label classification measures. 
    private void check_multi_label_classification_measures(HTuple hv_EvalParams, out HTuple hv_CalcPrecision,
        out HTuple hv_CalcRecall, out HTuple hv_CalcFScore, out HTuple hv_CalcMap, out HTuple hv_CalcAccuracy)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_Measures = new HTuple(), hv_M = new HTuple();
        // Initialize local and output iconic variables 
        hv_CalcPrecision = new HTuple();
        hv_CalcRecall = new HTuple();
        hv_CalcFScore = new HTuple();
        hv_CalcMap = new HTuple();
        hv_CalcAccuracy = new HTuple();
        try
        {
            hv_Measures.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_Measures = hv_EvalParams.TupleGetDictTuple(
                    "measures");
            }
            //
            hv_CalcPrecision.Dispose();
            hv_CalcPrecision = 0;
            hv_CalcRecall.Dispose();
            hv_CalcRecall = 0;
            hv_CalcFScore.Dispose();
            hv_CalcFScore = 0;
            hv_CalcAccuracy.Dispose();
            hv_CalcAccuracy = 0;
            hv_CalcMap.Dispose();
            hv_CalcMap = 0;
            //
            for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
            {
                if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual("precision"))) != 0)
                {
                    hv_CalcPrecision.Dispose();
                    hv_CalcPrecision = 1;
                }
                else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                    "recall"))) != 0)
                {
                    hv_CalcRecall.Dispose();
                    hv_CalcRecall = 1;
                }
                else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                    "f_score"))) != 0)
                {
                    hv_CalcFScore.Dispose();
                    hv_CalcFScore = 1;
                }
                else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                    "accuracy"))) != 0)
                {
                    hv_CalcAccuracy.Dispose();
                    hv_CalcAccuracy = 1;
                }
                else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                    "mean_ap"))) != 0)
                {
                    hv_CalcMap.Dispose();
                    hv_CalcMap = 1;
                }
                else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                    "all"))) != 0)
                {
                    hv_CalcPrecision.Dispose();
                    hv_CalcPrecision = 1;
                    hv_CalcRecall.Dispose();
                    hv_CalcRecall = 1;
                    hv_CalcFScore.Dispose();
                    hv_CalcFScore = 1;
                    hv_CalcAccuracy.Dispose();
                    hv_CalcAccuracy = 1;
                    hv_CalcMap.Dispose();
                    hv_CalcMap = 1;
                    hv_CalcAccuracy.Dispose();
                    hv_CalcAccuracy = 1;
                }
                else
                {
                    throw new HalconException("Unknown multi-label classification measure: " + (hv_Measures.TupleSelect(
                        hv_M)));
                }
            }

            hv_Measures.Dispose();
            hv_M.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_Measures.Dispose();
            hv_M.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Classification
    // Short Description: Calculate top-K error. 
    private void compute_top_k_error(HTuple hv_ImageLabelIDs, HTuple hv_TopKPredictions,
        HTuple hv_K, out HTuple hv_TopKError)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_NumMatches = new HTuple(), hv_Index = new HTuple();
        HTuple hv_Predictions = new HTuple(), hv_PredictedClasses = new HTuple();
        // Initialize local and output iconic variables 
        hv_TopKError = new HTuple();
        try
        {
            //
            //This procedure calculates the top-K error out of the given predictions and labels.
            //
            hv_NumMatches.Dispose();
            hv_NumMatches = 0;
            //
            //Loop through all selected ground truth labels.
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ImageLabelIDs.TupleLength()
                )) - 1); hv_Index = (int)hv_Index + 1)
            {
                //Get the K best results.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Predictions.Dispose();
                    HOperatorSet.GetDictTuple(hv_TopKPredictions.TupleSelect(hv_Index), "predictions",
                        out hv_Predictions);
                }
                hv_PredictedClasses.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PredictedClasses = hv_Predictions.TupleSelectRange(
                        0, hv_K - 1);
                }
                //Count how often the ground truth label
                //and K predicted classes match.
                if ((int)(new HTuple(((hv_PredictedClasses.TupleFind(hv_ImageLabelIDs.TupleSelect(
                    hv_Index)))).TupleNotEqual(-1))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_NumMatches = hv_NumMatches + 1;
                            hv_NumMatches.Dispose();
                            hv_NumMatches = ExpTmpLocalVar_NumMatches;
                        }
                    }
                }
            }
            hv_TopKError.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_TopKError = 1.0 - ((hv_NumMatches.TupleReal()
                    ) / (new HTuple(hv_ImageLabelIDs.TupleLength())));
            }
            //

            hv_NumMatches.Dispose();
            hv_Index.Dispose();
            hv_Predictions.Dispose();
            hv_PredictedClasses.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_NumMatches.Dispose();
            hv_Index.Dispose();
            hv_Predictions.Dispose();
            hv_PredictedClasses.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: 3D Matching / 3D Gripping Point Detection
    // Short Description: Compute a pose from a 3D point and orientation. 
    private void convert_dl_3d_gripping_point_to_pose(HTuple hv_X, HTuple hv_Y, HTuple hv_Z,
        HTuple hv_NX, HTuple hv_NY, HTuple hv_NZ, out HTuple hv_Pose)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_Normal = new HTuple(), hv_Abs = new HTuple();
        HTuple hv_Indices = new HTuple(), hv_ToolInCamY = new HTuple();
        HTuple hv_ToolInCamX = new HTuple(), hv_ToolInCamHRot = new HTuple();
        HTuple hv_ToolInCamPoseRot = new HTuple(), hv_HomMat3D = new HTuple();
        HTuple hv_Qx = new HTuple(), hv_Qy = new HTuple(), hv_Qz = new HTuple();
        // Initialize local and output iconic variables 
        hv_Pose = new HTuple();
        try
        {
            //Check for invalid points.
            if ((int)((new HTuple((new HTuple((new HTuple(hv_X.TupleEqual(0.0))).TupleAnd(
                new HTuple(hv_Y.TupleEqual(0.0))))).TupleAnd(new HTuple(hv_Z.TupleEqual(
                0.0))))).TupleOr((new HTuple((new HTuple(hv_NX.TupleEqual(0.0))).TupleAnd(
                new HTuple(hv_NY.TupleEqual(0.0))))).TupleAnd(new HTuple(hv_NZ.TupleEqual(
                0.0))))) != 0)
            {
                hv_Pose.Dispose();
                hv_Pose = new HTuple();

                hv_Normal.Dispose();
                hv_Abs.Dispose();
                hv_Indices.Dispose();
                hv_ToolInCamY.Dispose();
                hv_ToolInCamX.Dispose();
                hv_ToolInCamHRot.Dispose();
                hv_ToolInCamPoseRot.Dispose();
                hv_HomMat3D.Dispose();
                hv_Qx.Dispose();
                hv_Qy.Dispose();
                hv_Qz.Dispose();

                return;
            }
            //
            //Get rotation.
            hv_Normal.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_Normal = new HTuple();
                hv_Normal = hv_Normal.TupleConcat(hv_NX, hv_NY, hv_NZ);
            }
            hv_Abs.Dispose();
            HOperatorSet.TupleFabs(hv_Normal, out hv_Abs);
            hv_Indices.Dispose();
            HOperatorSet.TupleSortIndex(hv_Abs, out hv_Indices);
            if (hv_ToolInCamY == null)
                hv_ToolInCamY = new HTuple();
            hv_ToolInCamY[hv_Indices.TupleSelect(0)] = 0.0;
            if (hv_ToolInCamY == null)
                hv_ToolInCamY = new HTuple();
            hv_ToolInCamY[hv_Indices.TupleSelect(1)] = -(hv_Normal.TupleSelect(hv_Indices.TupleSelect(
                2)));
            if (hv_ToolInCamY == null)
                hv_ToolInCamY = new HTuple();
            hv_ToolInCamY[hv_Indices.TupleSelect(2)] = hv_Normal.TupleSelect(hv_Indices.TupleSelect(
                1));
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                {
                    HTuple
                      ExpTmpLocalVar_ToolInCamY = hv_ToolInCamY / (((((hv_ToolInCamY * hv_ToolInCamY)).TupleSum()
                        )).TupleSqrt());
                    hv_ToolInCamY.Dispose();
                    hv_ToolInCamY = ExpTmpLocalVar_ToolInCamY;
                }
            }
            hv_ToolInCamX.Dispose();
            tuple_vector_cross_product(hv_ToolInCamY, hv_Normal, out hv_ToolInCamX);
            hv_ToolInCamHRot.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_ToolInCamHRot = new HTuple();
                hv_ToolInCamHRot = hv_ToolInCamHRot.TupleConcat(hv_ToolInCamX.TupleSelect(
                    0));
                hv_ToolInCamHRot = hv_ToolInCamHRot.TupleConcat(hv_ToolInCamY.TupleSelect(
                    0));
                hv_ToolInCamHRot = hv_ToolInCamHRot.TupleConcat(hv_Normal.TupleSelect(
                    0));
                hv_ToolInCamHRot = hv_ToolInCamHRot.TupleConcat(0.0);
                hv_ToolInCamHRot = hv_ToolInCamHRot.TupleConcat(hv_ToolInCamX.TupleSelect(
                    1));
                hv_ToolInCamHRot = hv_ToolInCamHRot.TupleConcat(hv_ToolInCamY.TupleSelect(
                    1));
                hv_ToolInCamHRot = hv_ToolInCamHRot.TupleConcat(hv_Normal.TupleSelect(
                    1));
                hv_ToolInCamHRot = hv_ToolInCamHRot.TupleConcat(0.0);
                hv_ToolInCamHRot = hv_ToolInCamHRot.TupleConcat(hv_ToolInCamX.TupleSelect(
                    2));
                hv_ToolInCamHRot = hv_ToolInCamHRot.TupleConcat(hv_ToolInCamY.TupleSelect(
                    2));
                hv_ToolInCamHRot = hv_ToolInCamHRot.TupleConcat(hv_Normal.TupleSelect(
                    2));
                hv_ToolInCamHRot = hv_ToolInCamHRot.TupleConcat(0.0);
            }
            hv_ToolInCamPoseRot.Dispose();
            HOperatorSet.HomMat3dToPose(hv_ToolInCamHRot, out hv_ToolInCamPoseRot);
            if (hv_ToolInCamPoseRot == null)
                hv_ToolInCamPoseRot = new HTuple();
            hv_ToolInCamPoseRot[5] = 0.0;
            hv_HomMat3D.Dispose();
            HOperatorSet.PoseToHomMat3d(hv_ToolInCamPoseRot, out hv_HomMat3D);
            //
            //Get translation.
            hv_Qx.Dispose(); hv_Qy.Dispose(); hv_Qz.Dispose();
            HOperatorSet.AffineTransPoint3d(hv_HomMat3D, 0, 0, 0, out hv_Qx, out hv_Qy,
                out hv_Qz);
            hv_Pose.Dispose();
            hv_Pose = new HTuple(hv_ToolInCamPoseRot);
            if (hv_Pose == null)
                hv_Pose = new HTuple();
            hv_Pose[0] = hv_X - hv_Qx;
            if (hv_Pose == null)
                hv_Pose = new HTuple();
            hv_Pose[1] = hv_Y - hv_Qy;
            if (hv_Pose == null)
                hv_Pose = new HTuple();
            hv_Pose[2] = hv_Z - hv_Qz;

            hv_Normal.Dispose();
            hv_Abs.Dispose();
            hv_Indices.Dispose();
            hv_ToolInCamY.Dispose();
            hv_ToolInCamX.Dispose();
            hv_ToolInCamHRot.Dispose();
            hv_ToolInCamPoseRot.Dispose();
            hv_HomMat3D.Dispose();
            hv_Qx.Dispose();
            hv_Qy.Dispose();
            hv_Qz.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_Normal.Dispose();
            hv_Abs.Dispose();
            hv_Indices.Dispose();
            hv_ToolInCamY.Dispose();
            hv_ToolInCamX.Dispose();
            hv_ToolInCamHRot.Dispose();
            hv_ToolInCamPoseRot.Dispose();
            hv_HomMat3D.Dispose();
            hv_Qx.Dispose();
            hv_Qy.Dispose();
            hv_Qz.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: OCR / Deep OCR
    // Short Description: This procedure converts Deep OCR Detection results to an Object Detection results. 
    public void convert_ocr_detection_result_to_object_detection(HTuple hv_OcrResults,
        out HTuple hv_DetectionResults)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_Index = new HTuple(), hv_OcrResult = new HTuple();
        HTuple hv_RequiredKeysExist = new HTuple(), hv_DetectionResult = new HTuple();
        HTuple hv___Tmp_Ctrl_Type = new HTuple();
        // Initialize local and output iconic variables 
        hv_DetectionResults = new HTuple();
        try
        {
            //
            //Convert Deep OCR Detection results
            //to Object Detection results.
            //
            //Create DetectionResults Dict
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_DetectionResults.Dispose();
                HOperatorSet.TupleGenConst(new HTuple(hv_OcrResults.TupleLength()), HTuple.TupleConstant(
                    "HNULL"), out hv_DetectionResults);
            }
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_OcrResults.TupleLength()
                )) - 1); hv_Index = (int)hv_Index + 1)
            {
                hv_OcrResult.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_OcrResult = hv_OcrResults.TupleSelect(
                        hv_Index);
                }
                //Check if input is valid
                hv_RequiredKeysExist.Dispose();
                HOperatorSet.GetDictParam(hv_OcrResult, "key_exists", "words", out hv_RequiredKeysExist);
                if ((int)(new HTuple(((hv_RequiredKeysExist.TupleSum())).TupleNotEqual(new HTuple(hv_RequiredKeysExist.TupleLength()
                    )))) != 0)
                {
                    throw new HalconException(("The item at Index " + hv_Index) + " is not a valid Deep OCR Detection Result");
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RequiredKeysExist.Dispose();
                    HOperatorSet.GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_exists",
                        ((((new HTuple("row")).TupleConcat("col")).TupleConcat("phi")).TupleConcat(
                        "length1")).TupleConcat("length2"), out hv_RequiredKeysExist);
                }
                if ((int)(new HTuple(((hv_RequiredKeysExist.TupleSum())).TupleNotEqual(new HTuple(hv_RequiredKeysExist.TupleLength()
                    )))) != 0)
                {
                    throw new HalconException(("The item at Index " + hv_Index) + " is not a valid Deep OCR Detection Result");
                }
                //Convert ocr detection result to object detection
                hv_DetectionResult.Dispose();
                HOperatorSet.CreateDict(out hv_DetectionResult);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv___Tmp_Ctrl_Type.Dispose();
                    HOperatorSet.GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type",
                        "row", out hv___Tmp_Ctrl_Type);
                }
                if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictObject(((hv_OcrResult.TupleGetDictTuple("words"))).TupleGetDictObject(
                            "row"), hv_DetectionResult, "bbox_row");
                    }
                }
                else
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_DetectionResult, "bbox_row", ((hv_OcrResult.TupleGetDictTuple(
                            "words"))).TupleGetDictTuple("row"));
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv___Tmp_Ctrl_Type.Dispose();
                    HOperatorSet.GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type",
                        "col", out hv___Tmp_Ctrl_Type);
                }
                if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictObject(((hv_OcrResult.TupleGetDictTuple("words"))).TupleGetDictObject(
                            "col"), hv_DetectionResult, "bbox_col");
                    }
                }
                else
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_DetectionResult, "bbox_col", ((hv_OcrResult.TupleGetDictTuple(
                            "words"))).TupleGetDictTuple("col"));
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv___Tmp_Ctrl_Type.Dispose();
                    HOperatorSet.GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type",
                        "phi", out hv___Tmp_Ctrl_Type);
                }
                if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictObject(((hv_OcrResult.TupleGetDictTuple("words"))).TupleGetDictObject(
                            "phi"), hv_DetectionResult, "bbox_phi");
                    }
                }
                else
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_DetectionResult, "bbox_phi", ((hv_OcrResult.TupleGetDictTuple(
                            "words"))).TupleGetDictTuple("phi"));
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv___Tmp_Ctrl_Type.Dispose();
                    HOperatorSet.GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type",
                        "length1", out hv___Tmp_Ctrl_Type);
                }
                if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictObject(((hv_OcrResult.TupleGetDictTuple("words"))).TupleGetDictObject(
                            "length1"), hv_DetectionResult, "bbox_length1");
                    }
                }
                else
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_DetectionResult, "bbox_length1", ((hv_OcrResult.TupleGetDictTuple(
                            "words"))).TupleGetDictTuple("length1"));
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv___Tmp_Ctrl_Type.Dispose();
                    HOperatorSet.GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type",
                        "length2", out hv___Tmp_Ctrl_Type);
                }
                if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictObject(((hv_OcrResult.TupleGetDictTuple("words"))).TupleGetDictObject(
                            "length2"), hv_DetectionResult, "bbox_length2");
                    }
                }
                else
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_DetectionResult, "bbox_length2", ((hv_OcrResult.TupleGetDictTuple(
                            "words"))).TupleGetDictTuple("length2"));
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_DetectionResult, "bbox_confidence", HTuple.TupleGenConst(
                        new HTuple(((hv_DetectionResult.TupleGetDictTuple("bbox_row"))).TupleLength()
                        ), 1.0));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_DetectionResult, "bbox_class_id", HTuple.TupleGenConst(
                        new HTuple(((hv_DetectionResult.TupleGetDictTuple("bbox_row"))).TupleLength()
                        ), 0));
                }
                if (hv_DetectionResults == null)
                    hv_DetectionResults = new HTuple();
                hv_DetectionResults[hv_Index] = hv_DetectionResult;
            }



            hv_Index.Dispose();
            hv_OcrResult.Dispose();
            hv_RequiredKeysExist.Dispose();
            hv_DetectionResult.Dispose();
            hv___Tmp_Ctrl_Type.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_Index.Dispose();
            hv_OcrResult.Dispose();
            hv_RequiredKeysExist.Dispose();
            hv_DetectionResult.Dispose();
            hv___Tmp_Ctrl_Type.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Model
    // Short Description: Generate a dictionary EvalParams, which contains default values for evaluation parameters. 
    public void create_evaluation_default_param(HTuple hv_EvaluationType, HTuple hv_ClassIDsModel,
        out HTuple hv_EvalParams)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_AvailableEvaluationTypes = new HTuple();
        HTuple hv_EvaluationTypesStr = new HTuple(), hv_Indices = new HTuple();
        HTuple hv_EvaluateInstances = new HTuple(), hv_Measures = new HTuple();
        HTuple hv_GrippingPointParams = new HTuple(), hv_AreaRanges = new HTuple();
        HTuple hv_AllocationBlockLength = new HTuple();
        HTuple hv_ClassIDsModel_COPY_INP_TMP = new HTuple(hv_ClassIDsModel);

        // Initialize local and output iconic variables 
        hv_EvalParams = new HTuple();
        try
        {
            //
            //This procedure generates a dictionary EvalParams,
            //which contains default values for evaluation parameters.
            //Depending on the evaluation type, the corresponding default parameters and values are set.
            //The class IDs that the model can predict must be given via ClassIDsModel.
            //
            //Check inputs.
            hv_AvailableEvaluationTypes.Dispose();
            hv_AvailableEvaluationTypes = new HTuple();
            hv_AvailableEvaluationTypes[0] = "3d_gripping_point_detection";
            hv_AvailableEvaluationTypes[1] = "anomaly_detection";
            hv_AvailableEvaluationTypes[2] = "classification";
            hv_AvailableEvaluationTypes[3] = "multi_label_classification";
            hv_AvailableEvaluationTypes[4] = "detection";
            hv_AvailableEvaluationTypes[5] = "gc_anomaly_detection";
            hv_AvailableEvaluationTypes[6] = "ocr_detection";
            hv_AvailableEvaluationTypes[7] = "ocr_recognition";
            hv_AvailableEvaluationTypes[8] = "segmentation";
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_EvaluationTypesStr.Dispose();
                HOperatorSet.TupleGenConst((2 * (new HTuple(hv_AvailableEvaluationTypes.TupleLength()
                    ))) - 1, new HTuple("','"), out hv_EvaluationTypesStr);
            }
            if (hv_EvaluationTypesStr == null)
                hv_EvaluationTypesStr = new HTuple();
            hv_EvaluationTypesStr[HTuple.TupleGenSequence(0, new HTuple(hv_EvaluationTypesStr.TupleLength()
                ), 2)] = hv_AvailableEvaluationTypes;
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                {
                    HTuple
                      ExpTmpLocalVar_EvaluationTypesStr = hv_EvaluationTypesStr.TupleSum()
                        ;
                    hv_EvaluationTypesStr.Dispose();
                    hv_EvaluationTypesStr = ExpTmpLocalVar_EvaluationTypesStr;
                }
            }
            hv_Indices.Dispose();
            HOperatorSet.TupleFind(hv_AvailableEvaluationTypes, hv_EvaluationType, out hv_Indices);
            if ((int)((new HTuple(hv_Indices.TupleEqual(-1))).TupleOr(new HTuple(hv_Indices.TupleEqual(
                new HTuple())))) != 0)
            {
                throw new HalconException(((("Unknown evaluation_type: " + hv_EvaluationType) + ". Choose one of ['") + hv_EvaluationTypesStr) + "']");
            }
            //
            if ((int)(new HTuple((new HTuple(hv_ClassIDsModel_COPY_INP_TMP.TupleLength()
                )).TupleLess(1))) != 0)
            {
                if ((int)(new HTuple(hv_EvaluationType.TupleEqual("ocr_detection"))) != 0)
                {
                    hv_ClassIDsModel_COPY_INP_TMP.Dispose();
                    hv_ClassIDsModel_COPY_INP_TMP = 0;
                }
                else
                {
                    throw new HalconException("ClassIDsModel should have at least one entry");
                }
            }
            //
            //Initialize EvalParams.
            hv_EvalParams.Dispose();
            HOperatorSet.CreateDict(out hv_EvalParams);
            HOperatorSet.SetDictTuple(hv_EvalParams, "evaluation_type", hv_EvaluationType);
            //
            //Set the class IDs.
            HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids", hv_ClassIDsModel_COPY_INP_TMP);
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                HOperatorSet.SetDictTuple(hv_EvalParams, "num_classes", new HTuple(hv_ClassIDsModel_COPY_INP_TMP.TupleLength()
                    ));
            }
            //
            //Set specific parameters depending on the evaluation type.
            hv_EvaluateInstances.Dispose();
            hv_EvaluateInstances = 0;
            if ((int)(new HTuple(hv_EvaluationType.TupleEqual("3d_gripping_point_detection"))) != 0)
            {
                //
                //Set default 3D Gripping Point Detection measures.
                hv_Measures.Dispose();
                hv_Measures = new HTuple();
                hv_Measures[0] = "mean_pro";
                hv_Measures[1] = "mean_precision";
                hv_Measures[2] = "mean_iou";
                //
                //There are no ignored classes for this model type.
                HOperatorSet.SetDictTuple(hv_EvalParams, "ignore_class_ids", new HTuple());
                //
                //Set default 3D gripping point generation parameters.
                hv_GrippingPointParams.Dispose();
                HOperatorSet.CreateDict(out hv_GrippingPointParams);
                check_dl_3d_gripping_points_and_poses_params(hv_GrippingPointParams);
                HOperatorSet.SetDictTuple(hv_EvalParams, "gripping_point_params", hv_GrippingPointParams);
            }
            else if ((int)((new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))).TupleOr(
                new HTuple(hv_EvaluationType.TupleEqual("gc_anomaly_detection")))) != 0)
            {
                //
                //Set default image level measures.
                hv_Measures.Dispose();
                hv_Measures = "anomaly_score_histogram";
            }
            else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
            {
                //
                //Set default classification measures.
                hv_Measures.Dispose();
                hv_Measures = "top1_error";
                //
                //Per default all classes are used for evaluation.
                HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids_to_evaluate", "global");
            }
            else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("multi_label_classification"))) != 0)
            {
                //
                //Set default detection measures.
                hv_Measures.Dispose();
                hv_Measures = "mean_ap";
                //Interpolate the precision-recall curves per default.
                HOperatorSet.SetDictTuple(hv_EvalParams, "interpolate_pr_curves", 1);
                //
            }
            else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("detection"))) != 0)
            {
                //
                //Set default detection measures.
                hv_Measures.Dispose();
                hv_Measures = "mean_ap";
                //
                //Set detection-specific default values.
                hv_EvaluateInstances.Dispose();
                hv_EvaluateInstances = 1;
                HOperatorSet.SetDictTuple(hv_EvalParams, "instance_type", "rectangle1");
                //Generate ten IoU-thresholds from 0.5 to 0.95 in steps of 0.05.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_EvalParams, "iou_threshold", HTuple.TupleGenSequence(
                        0.5, 0.96, 0.05));
                }
                //Set maximal number of detections to -1, i.e. all results per image will be evaluated.
                HOperatorSet.SetDictTuple(hv_EvalParams, "max_num_detections", -1);
                //Set default area range named 'all', thus areas from 0 to a value larger than all likely occurring values.
                hv_AreaRanges.Dispose();
                HOperatorSet.CreateDict(out hv_AreaRanges);
                HOperatorSet.SetDictTuple(hv_AreaRanges, "name", "all");
                HOperatorSet.SetDictTuple(hv_AreaRanges, "min", 0);
                HOperatorSet.SetDictTuple(hv_AreaRanges, "max", 2e8);
                HOperatorSet.SetDictTuple(hv_EvalParams, "area_ranges", hv_AreaRanges);
                //Some tuples are changing their length during the evaluation. As this slows down the
                //evaluation process they are allocated in blocks of AllocationBlockLength.
                hv_AllocationBlockLength.Dispose();
                hv_AllocationBlockLength = 200;
                HOperatorSet.SetDictTuple(hv_EvalParams, "allocation_block_length", hv_AllocationBlockLength);
                //Detailed evaluation is not switched on per default, as it slows down the evaluation-process.
                HOperatorSet.SetDictTuple(hv_EvalParams, "detailed_evaluation", 0);
                //Interpolate the precision-recall curves per default.
                HOperatorSet.SetDictTuple(hv_EvalParams, "interpolate_pr_curves", 1);
            }
            else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
            {
                //
                //Set default pixel measures.
                hv_Measures.Dispose();
                hv_Measures = new HTuple();
                hv_Measures[0] = "pixel_accuracy";
                hv_Measures[1] = "mean_accuracy";
                hv_Measures[2] = "mean_iou";
                //
                //Per default there are no ignored classes.
                HOperatorSet.SetDictTuple(hv_EvalParams, "ignore_class_ids", new HTuple());
            }
            else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("ocr_recognition"))) != 0)
            {
                //
                //Set default OCR recognition measures
                hv_Measures.Dispose();
                hv_Measures = "accuracy";
            }
            else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("ocr_detection"))) != 0)
            {
                //
                //Set default ocr_detection measures.
                hv_Measures.Dispose();
                hv_Measures = "f_score";
                HOperatorSet.SetDictTuple(hv_EvalParams, "detailed_evaluation", 1);
                HOperatorSet.SetDictTuple(hv_EvalParams, "iou_threshold", 0.5);
                HOperatorSet.SetDictTuple(hv_EvalParams, "max_num_detections", -1);
                HOperatorSet.SetDictTuple(hv_EvalParams, "instance_type", "rectangle2");
                HOperatorSet.SetDictTuple(hv_EvalParams, "allocation_block_length", 100);
                //
                //Configure area constraints.
                hv_AreaRanges.Dispose();
                HOperatorSet.CreateDict(out hv_AreaRanges);
                HOperatorSet.SetDictTuple(hv_AreaRanges, "name", "all");
                HOperatorSet.SetDictTuple(hv_AreaRanges, "min", 0);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_AreaRanges, "max", HTuple.TupleConstant("H_INT_MAX"));
                }
                HOperatorSet.SetDictTuple(hv_EvalParams, "area_ranges", hv_AreaRanges);
            }
            //
            HOperatorSet.SetDictTuple(hv_EvalParams, "evaluate_instances", hv_EvaluateInstances);
            HOperatorSet.SetDictTuple(hv_EvalParams, "measures", hv_Measures);
            //

            hv_ClassIDsModel_COPY_INP_TMP.Dispose();
            hv_AvailableEvaluationTypes.Dispose();
            hv_EvaluationTypesStr.Dispose();
            hv_Indices.Dispose();
            hv_EvaluateInstances.Dispose();
            hv_Measures.Dispose();
            hv_GrippingPointParams.Dispose();
            hv_AreaRanges.Dispose();
            hv_AllocationBlockLength.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_ClassIDsModel_COPY_INP_TMP.Dispose();
            hv_AvailableEvaluationTypes.Dispose();
            hv_EvaluationTypesStr.Dispose();
            hv_Indices.Dispose();
            hv_EvaluateInstances.Dispose();
            hv_Measures.Dispose();
            hv_GrippingPointParams.Dispose();
            hv_AreaRanges.Dispose();
            hv_AllocationBlockLength.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Develop
    // Short Description: Resize a graphics window with a given maximum extent such that it preserves the aspect ratio of a given width and height 
    public void dev_resize_window_fit_size(HTuple hv_Row, HTuple hv_Column, HTuple hv_Width,
        HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_MinWidth = new HTuple(), hv_MaxWidth = new HTuple();
        HTuple hv_MinHeight = new HTuple(), hv_MaxHeight = new HTuple();
        HTuple hv_ResizeFactor = new HTuple(), hv_TempWidth = new HTuple();
        HTuple hv_TempHeight = new HTuple(), hv_WindowWidth = new HTuple();
        HTuple hv_WindowHeight = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            //This procedure adjusts the size of the current window
            //such that it fits into the limits specified by WidthLimit
            //and HeightLimit, but also maintains the correct aspect ratio
            //given by Width and Height.
            //
            //If it is impossible to match the minimum and maximum extent requirements
            //at the same time (f.e. if the image is very long but narrow),
            //the maximum value gets a higher priority.
            //
            //Parse input tuple WidthLimit
            if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
                0))).TupleOr(new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
            {
                hv_MinWidth.Dispose();
                hv_MinWidth = 500;
                hv_MaxWidth.Dispose();
                hv_MaxWidth = 800;
            }
            else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
                1))) != 0)
            {
                hv_MinWidth.Dispose();
                hv_MinWidth = 0;
                hv_MaxWidth.Dispose();
                hv_MaxWidth = new HTuple(hv_WidthLimit);
            }
            else
            {
                hv_MinWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MinWidth = hv_WidthLimit.TupleSelect(
                        0);
                }
                hv_MaxWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MaxWidth = hv_WidthLimit.TupleSelect(
                        1);
                }
            }
            //Parse input tuple HeightLimit
            if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
                0))).TupleOr(new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
            {
                hv_MinHeight.Dispose();
                hv_MinHeight = 400;
                hv_MaxHeight.Dispose();
                hv_MaxHeight = 600;
            }
            else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
                1))) != 0)
            {
                hv_MinHeight.Dispose();
                hv_MinHeight = 0;
                hv_MaxHeight.Dispose();
                hv_MaxHeight = new HTuple(hv_HeightLimit);
            }
            else
            {
                hv_MinHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MinHeight = hv_HeightLimit.TupleSelect(
                        0);
                }
                hv_MaxHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MaxHeight = hv_HeightLimit.TupleSelect(
                        1);
                }
            }
            //
            //Test, if window size has to be changed.
            hv_ResizeFactor.Dispose();
            hv_ResizeFactor = 1;
            //First, expand window to the minimum extents (if necessary).
            if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_Width))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
                hv_Height)))) != 0)
            {
                hv_ResizeFactor.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ResizeFactor = (((((hv_MinWidth.TupleReal()
                        ) / hv_Width)).TupleConcat((hv_MinHeight.TupleReal()) / hv_Height))).TupleMax()
                        ;
                }
            }
            hv_TempWidth.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_TempWidth = hv_Width * hv_ResizeFactor;
            }
            hv_TempHeight.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_TempHeight = hv_Height * hv_ResizeFactor;
            }
            //Then, shrink window to maximum extents (if necessary).
            if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
                hv_TempHeight)))) != 0)
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ResizeFactor = hv_ResizeFactor * ((((((hv_MaxWidth.TupleReal()
                            ) / hv_TempWidth)).TupleConcat((hv_MaxHeight.TupleReal()) / hv_TempHeight))).TupleMin()
                            );
                        hv_ResizeFactor.Dispose();
                        hv_ResizeFactor = ExpTmpLocalVar_ResizeFactor;
                    }
                }
            }
            hv_WindowWidth.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_WindowWidth = hv_Width * hv_ResizeFactor;
            }
            hv_WindowHeight.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_WindowHeight = hv_Height * hv_ResizeFactor;
            }
            //Resize window
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_Row, hv_Column,
                    hv_WindowWidth, hv_WindowHeight);
            }
            if (HDevWindowStack.IsOpen())
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height - 1, hv_Width - 1);
                }
            }

            hv_MinWidth.Dispose();
            hv_MaxWidth.Dispose();
            hv_MinHeight.Dispose();
            hv_MaxHeight.Dispose();
            hv_ResizeFactor.Dispose();
            hv_TempWidth.Dispose();
            hv_TempHeight.Dispose();
            hv_WindowWidth.Dispose();
            hv_WindowHeight.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_MinWidth.Dispose();
            hv_MaxWidth.Dispose();
            hv_MinHeight.Dispose();
            hv_MaxHeight.Dispose();
            hv_ResizeFactor.Dispose();
            hv_TempWidth.Dispose();
            hv_TempHeight.Dispose();
            hv_WindowWidth.Dispose();
            hv_WindowHeight.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Develop
    // Short Description: Switch dev_update_pc, dev_update_var, and dev_update_window to 'off'. 
    public void dev_update_off()
    {

        // Initialize local and output iconic variables 
        //This procedure sets different update settings to 'off'.
        //This is useful to get the best performance and reduce overhead.
        //
        // dev_update_pc(...); only in hdevelop
        // dev_update_var(...); only in hdevelop
        // dev_update_window(...); only in hdevelop


        return;
    }

    // Chapter: System / Operating System
    // Short Description: Estimate the remaining time for a task given the current progress. 
    public void estimate_progress(HTuple hv_SecondsStart, HTuple hv_ProgressMin, HTuple hv_ProgressCurrent,
        HTuple hv_ProgressMax, out HTuple hv_SecondsElapsed, out HTuple hv_SecondsRemaining,
        out HTuple hv_ProgressPercent, out HTuple hv_ProgressPerSecond)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_SecondsNow = new HTuple(), hv_Epsilon = new HTuple();
        HTuple hv_ProgressRemaining = new HTuple();
        // Initialize local and output iconic variables 
        hv_SecondsElapsed = new HTuple();
        hv_SecondsRemaining = new HTuple();
        hv_ProgressPercent = new HTuple();
        hv_ProgressPerSecond = new HTuple();
        try
        {
            //
            //This procedure estimates the remaining time in seconds,
            //given a start time and a progress value.
            //
            //Get current time.
            hv_SecondsNow.Dispose();
            HOperatorSet.CountSeconds(out hv_SecondsNow);
            //
            //Get elapsed time span.
            hv_SecondsElapsed.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_SecondsElapsed = hv_SecondsNow - hv_SecondsStart;
            }
            //
            //A very small additive constant to avoid division by zero.
            hv_Epsilon.Dispose();
            hv_Epsilon = 1e-6;
            //
            //Estimate remaining time based on elapsed time.
            hv_ProgressRemaining.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_ProgressRemaining = hv_ProgressMax - hv_ProgressCurrent;
            }
            hv_ProgressPerSecond.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_ProgressPerSecond = (((hv_ProgressCurrent - hv_ProgressMin)).TupleReal()
                    ) / ((hv_SecondsElapsed.TupleReal()) + hv_Epsilon);
            }
            hv_SecondsRemaining.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_SecondsRemaining = hv_ProgressRemaining / (hv_ProgressPerSecond + hv_Epsilon);
            }
            //
            //Get current progress in percent.
            hv_ProgressPercent.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_ProgressPercent = (100 * (((hv_ProgressCurrent - hv_ProgressMin)).TupleReal()
                    )) / ((((hv_ProgressMax - hv_ProgressMin)).TupleReal()) + hv_Epsilon);
            }

            hv_SecondsNow.Dispose();
            hv_Epsilon.Dispose();
            hv_ProgressRemaining.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_SecondsNow.Dispose();
            hv_Epsilon.Dispose();
            hv_ProgressRemaining.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Model
    // Short Description: Evaluate the model given by DLModelHandle on the selected samples of DLDataset. 
    public void evaluate_dl_model(HTuple hv_DLDataset, HTuple hv_DLModelHandle, HTuple hv_SampleSelectMethod,
        HTuple hv_SampleSelectValues, HTuple hv_GenParam, out HTuple hv_EvaluationResult,
        out HTuple hv_EvalParams)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_ModelType = new HTuple(), hv_ClassIDs = new HTuple();
        HTuple hv_ClassNames = new HTuple(), hv_Alphabet = new HTuple();
        HTuple hv_BatchSize = new HTuple(), hv_OODAvailable = new HTuple();
        HTuple hv_InstanceTypeModel = new HTuple(), hv_Exception = new HTuple();
        HTuple hv_IsInstanceSegmentation = new HTuple(), hv_InstanceType = new HTuple();
        HTuple hv_ModelIgnoreClassIDs = new HTuple(), hv_ShowProgress = new HTuple();
        HTuple hv_GenParamKeys = new HTuple(), hv_OptionalKeyNames = new HTuple();
        HTuple hv_GenParamIndex = new HTuple(), hv_IoUThreshold = new HTuple();
        HTuple hv_MaxNumDetections = new HTuple(), hv_AreaRanges = new HTuple();
        HTuple hv_DetailedEvaluation = new HTuple(), hv_AllocationBlockLength = new HTuple();
        HTuple hv_InterpolatePRCurves = new HTuple(), hv_IgnoreClassIDs = new HTuple();
        HTuple hv_AllIgnoreClassIDs = new HTuple(), hv_EvaluateClassIDs = new HTuple();
        HTuple hv_ClassesToEvaluate = new HTuple(), hv_KeyExists = new HTuple();
        HTuple hv_ClassIDsToEvaluate = new HTuple(), hv_AnomalyClassificationThresholds = new HTuple();
        HTuple hv_EvaluateMask = new HTuple(), hv_Value = new HTuple();
        HTuple hv_Measures = new HTuple(), hv_IgnoreDirection = new HTuple();
        HTuple hv_MinConfidence = new HTuple(), hv_OODMeasureRequested = new HTuple();
        HTuple hv_OODEvaluationPossible = new HTuple(), hv_FoundIndex = new HTuple();
        HTuple hv_AllMeasuresRequested = new HTuple(), hv_OODThreshold = new HTuple();
        HTuple hv_ClassInfoExists = new HTuple(), hv_DatasetClassIDs = new HTuple();
        HTuple hv_ClassIDsToClassNames = new HTuple(), hv_EvaluateClassNames = new HTuple();
        HTuple hv_DLSamples = new HTuple(), hv_SampleIndices = new HTuple();
        HTuple hv_NumSamples = new HTuple(), hv_NumBatches = new HTuple();
        HTuple hv_OODSamplesAvailable = new HTuple(), hv_NumOODSamples = new HTuple();
        HTuple hv_NumOODBatches = new HTuple(), hv_TotalNumBatches = new HTuple();
        HTuple hv_RunningMeasures = new HTuple(), hv_Outputs = new HTuple();
        HTuple hv_EvalGCAnomalyNetworks = new HTuple(), hv_ModelGCAnomalyNetworks = new HTuple();
        HTuple hv_DefaultRequested = new HTuple(), hv_EvalAnomalyNetworkIndex = new HTuple();
        HTuple hv_EvalGCAnomalyNetwork = new HTuple(), hv_FindIndex = new HTuple();
        HTuple hv_Progress = new HTuple(), hv_TaskInfo = new HTuple();
        HTuple hv_SecondsStart = new HTuple(), hv_BatchIndex = new HTuple();
        HTuple hv_BatchStart = new HTuple(), hv_BatchEnd = new HTuple();
        HTuple hv_SamplesIndicesBatch = new HTuple(), hv_DLSamplesBatch = new HTuple();
        HTuple hv_DLResultsBatch = new HTuple(), hv_SecondsElapsed = new HTuple();
        HTuple hv_SecondsRemaining = new HTuple(), hv_ProgressPercent = new HTuple();
        HTuple hv_ProgressPerSecond = new HTuple(), hv_TimeElapsedString = new HTuple();
        HTuple hv_TimeRemainingString = new HTuple(), hv_SampleIndex = new HTuple();
        HTuple hv_DLSample = new HTuple(), hv_DictPath = new HTuple();
        HTuple hv_DLSampleProc = new HTuple(), hv_PreprocessedSampleIsOod = new HTuple();
        // Initialize local and output iconic variables 
        hv_EvaluationResult = new HTuple();
        hv_EvalParams = new HTuple();
        try
        {
            //This procedure applies the model given by DLModelHandle on the selected samples
            //of DLDataset and evaluates the results against the ground truth annotations
            //to calculate evaluation measures.
            //
            //Input:
            // - DLDataset.
            // - DLModelHandle.
            // - SampleSelectMethod: Method by which the samples are selected.
            // - SampleSelectValues: Identifier used to retrieve the samples from the DLDataset
            //                       for the corresponding selection method.
            // - GenParam: Parameters of the evaluation that should be changed from the default.
            //
            //Output:
            // - EvaluationResult: Dictionary containing the output measures.
            // - EvalParams: Dictionary with the used evaluation parameters.
            //
            //** Initialization: ***
            //
            hv_ModelType.Dispose();
            HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
            if ((int)((new HTuple((new HTuple((new HTuple((new HTuple((new HTuple((new HTuple((new HTuple((new HTuple(hv_ModelType.TupleNotEqual(
                "3d_gripping_point_detection"))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual(
                "anomaly_detection"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual(
                "classification"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual("multi_label_classification"))))).TupleAnd(
                new HTuple(hv_ModelType.TupleNotEqual("detection"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual(
                "gc_anomaly_detection"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual(
                "ocr_detection"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual("ocr_recognition"))))).TupleAnd(
                new HTuple(hv_ModelType.TupleNotEqual("segmentation")))) != 0)
            {
                throw new HalconException(("Current model type is not supported: \"" + hv_ModelType) + "\"");
            }
            //
            //Check if model has been normalized, if required by model type.
            if ((int)(new HTuple(hv_ModelType.TupleEqual("gc_anomaly_detection"))) != 0)
            {
                check_dl_gc_anomaly_scores_normalization(hv_DLModelHandle, new HTuple());
            }
            //
            //Get the class IDs as set in the model.
            if ((int)(new HTuple(hv_ModelType.TupleEqual("3d_gripping_point_detection"))) != 0)
            {
                //Only the gripping_map class is evaluated.
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_ids", out hv_ClassIDs);
                hv_ClassNames.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_names", out hv_ClassNames);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ClassIDs = hv_ClassIDs.TupleSelect(
                            hv_ClassNames.TupleFind("gripping_map"));
                        hv_ClassIDs.Dispose();
                        hv_ClassIDs = ExpTmpLocalVar_ClassIDs;
                    }
                }
            }
            else if ((int)((new HTuple(hv_ModelType.TupleEqual("anomaly_detection"))).TupleOr(
                new HTuple(hv_ModelType.TupleEqual("gc_anomaly_detection")))) != 0)
            {
                //Default for anomaly detection and Global Context Anomaly Detection is 0,1.
                hv_ClassIDs.Dispose();
                hv_ClassIDs = new HTuple();
                hv_ClassIDs[0] = 0;
                hv_ClassIDs[1] = 1;
            }
            else if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_recognition"))) != 0)
            {
                //No Class IDs in case of ocr_recognition models
                hv_Alphabet.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "alphabet", out hv_Alphabet);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ClassIDs.Dispose();
                    HOperatorSet.TupleGenSequence(0, new HTuple(hv_Alphabet.TupleLength()), 1,
                        out hv_ClassIDs);
                }
            }
            else if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_detection"))) != 0)
            {
                //Default for ocr_detection. Only evaluate word.
                //0: word, 1: char, 2: ignore
                hv_ClassIDs.Dispose();
                hv_ClassIDs = 0;
            }
            else
            {
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_ids", out hv_ClassIDs);
            }
            //
            //Get the batch size as set in the model.
            hv_BatchSize.Dispose();
            HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size", out hv_BatchSize);
            //
            //Generate default parameters.
            hv_EvalParams.Dispose();
            create_evaluation_default_param(hv_ModelType, hv_ClassIDs, out hv_EvalParams);
            //Add out-of-distribution default evaluation param
            if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
            {
                hv_OODAvailable.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "ood_available", out hv_OODAvailable);
                if ((int)(new HTuple(hv_OODAvailable.TupleEqual("true"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvalParams, "measures", ((hv_EvalParams.TupleGetDictTuple(
                            "measures"))).TupleConcat((((((new HTuple("ood_confusion_matrix")).TupleConcat(
                            "ood_precision")).TupleConcat("ood_recall")).TupleConcat("ood_f_score")).TupleConcat(
                            "ood_false_positive_rate")).TupleConcat("ood_score_histogram")));
                    }
                }
            }
            //
            //Get model specific information.
            if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
            {
                try
                {
                    hv_InstanceTypeModel.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "instance_type", out hv_InstanceTypeModel);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_InstanceTypeModel.Dispose();
                    hv_InstanceTypeModel = "rectangle1";
                }
                hv_IsInstanceSegmentation.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "instance_segmentation", out hv_IsInstanceSegmentation);
                if ((int)(new HTuple(hv_IsInstanceSegmentation.TupleEqual("true"))) != 0)
                {
                    hv_InstanceType.Dispose();
                    hv_InstanceType = "mask";
                }
                else
                {
                    hv_InstanceType.Dispose();
                    hv_InstanceType = new HTuple(hv_InstanceTypeModel);
                }
                //Note, these are the defaults. If the user specifies
                //'evaluate_mask' as false, the evaluation will use
                //the instance type of the model (InstanceTypeModel).
            }
            else if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
            {
                hv_ModelIgnoreClassIDs.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "ignore_class_ids", out hv_ModelIgnoreClassIDs);
            }
            //
            //By default we do not show the progress of evaluation.
            hv_ShowProgress.Dispose();
            hv_ShowProgress = 0;
            //
            //Set user specified parameters.
            if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
            {
                hv_GenParamKeys.Dispose();
                HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamKeys);
                hv_OptionalKeyNames.Dispose();
                hv_OptionalKeyNames = new HTuple();
                hv_OptionalKeyNames[0] = "measures";
                hv_OptionalKeyNames[1] = "evaluation_type";
                hv_OptionalKeyNames[2] = "class_ids";
                hv_OptionalKeyNames[3] = "num_classes";
                hv_OptionalKeyNames[4] = "evaluate_instances";
                hv_OptionalKeyNames[5] = "gc_anomaly_networks";
                hv_OptionalKeyNames[6] = "gripping_point_params";
                for (hv_GenParamIndex = 0; (int)hv_GenParamIndex <= (int)((new HTuple(hv_GenParamKeys.TupleLength()
                    )) - 1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
                {
                    if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "show_progress"))) != 0)
                    {
                        //Show the progress of the evaluation.
                        hv_ShowProgress.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "show_progress", out hv_ShowProgress);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ShowProgress = (new HTuple(hv_ShowProgress.TupleEqual(
                                    "true"))).TupleOr(new HTuple(hv_ShowProgress.TupleEqual(1)));
                                hv_ShowProgress.Dispose();
                                hv_ShowProgress = ExpTmpLocalVar_ShowProgress;
                            }
                        }
                    }
                    else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "iou_threshold"))).TupleAnd((new HTuple(hv_ModelType.TupleEqual("detection"))).TupleOr(
                        new HTuple(hv_ModelType.TupleEqual("ocr_detection"))))) != 0)
                    {
                        //Set IoU threshold.
                        hv_IoUThreshold.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "iou_threshold", out hv_IoUThreshold);
                        HOperatorSet.SetDictTuple(hv_EvalParams, "iou_threshold", hv_IoUThreshold);
                    }
                    else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "max_num_detections"))).TupleAnd((new HTuple(hv_ModelType.TupleEqual(
                        "detection"))).TupleOr(new HTuple(hv_ModelType.TupleEqual("ocr_detection"))))) != 0)
                    {
                        //Set maximal number detections.
                        hv_MaxNumDetections.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "max_num_detections", out hv_MaxNumDetections);
                        HOperatorSet.SetDictTuple(hv_EvalParams, "max_num_detections", hv_MaxNumDetections);
                    }
                    else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "area_ranges"))).TupleAnd((new HTuple(hv_ModelType.TupleEqual("detection"))).TupleOr(
                        new HTuple(hv_ModelType.TupleEqual("ocr_detection"))))) != 0)
                    {
                        //Set area ranges.
                        hv_AreaRanges.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "area_ranges", out hv_AreaRanges);
                        HOperatorSet.SetDictTuple(hv_EvalParams, "area_ranges", hv_AreaRanges);
                    }
                    else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "detailed_evaluation"))).TupleAnd((new HTuple(hv_ModelType.TupleEqual(
                        "detection"))).TupleOr(new HTuple(hv_ModelType.TupleEqual("ocr_detection"))))) != 0)
                    {
                        //Set detailed evaluation.
                        hv_DetailedEvaluation.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "detailed_evaluation", out hv_DetailedEvaluation);
                        HOperatorSet.SetDictTuple(hv_EvalParams, "detailed_evaluation", hv_DetailedEvaluation);
                    }
                    else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "allocation_block_length"))).TupleAnd((new HTuple(hv_ModelType.TupleEqual(
                        "detection"))).TupleOr(new HTuple(hv_ModelType.TupleEqual("ocr_detection"))))) != 0)
                    {
                        //Set length of blocks that are allocated during evaluation.
                        hv_AllocationBlockLength.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "allocation_block_length", out hv_AllocationBlockLength);
                        HOperatorSet.SetDictTuple(hv_EvalParams, "allocation_block_length", hv_AllocationBlockLength);
                    }
                    else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "interpolate_pr_curves"))).TupleAnd((new HTuple((new HTuple(hv_ModelType.TupleEqual(
                        "detection"))).TupleOr(new HTuple(hv_ModelType.TupleEqual("ocr_detection"))))).TupleOr(
                        new HTuple(hv_ModelType.TupleEqual("multi_label_classification"))))) != 0)
                    {
                        //Set interpolation of precision-recall curves.
                        hv_InterpolatePRCurves.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "interpolate_pr_curves", out hv_InterpolatePRCurves);
                        HOperatorSet.SetDictTuple(hv_EvalParams, "interpolate_pr_curves", hv_InterpolatePRCurves);
                    }
                    else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "ignore_class_ids"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual("segmentation")))) != 0)
                    {
                        //Set ignore class IDs.
                        hv_IgnoreClassIDs.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "ignore_class_ids", out hv_IgnoreClassIDs);
                        //Merge the specified ignore class IDs with the model ignore class IDs.
                        hv_AllIgnoreClassIDs.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AllIgnoreClassIDs = ((((hv_ModelIgnoreClassIDs.TupleConcat(
                                hv_IgnoreClassIDs))).TupleSort())).TupleUniq();
                        }
                        HOperatorSet.SetDictTuple(hv_EvalParams, "ignore_class_ids", hv_AllIgnoreClassIDs);
                        //Remove the ignore class IDs from the model class IDs.
                        hv_EvaluateClassIDs.Dispose();
                        HOperatorSet.TupleDifference(hv_ClassIDs, hv_IgnoreClassIDs, out hv_EvaluateClassIDs);
                        HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids", hv_EvaluateClassIDs);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_EvalParams, "num_classes", new HTuple(hv_EvaluateClassIDs.TupleLength()
                                ));
                        }
                    }
                    else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "class_names_to_evaluate"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual(
                        "classification")))) != 0)
                    {
                        //Class names to be used in evaluation.
                        //To transform the names to IDs later, one has to remember the class names.
                        hv_ClassesToEvaluate.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "class_names_to_evaluate", out hv_ClassesToEvaluate);
                        hv_ClassNames.Dispose();
                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_names", out hv_ClassNames);
                        HOperatorSet.SetDictTuple(hv_EvalParams, "class_names_to_evaluate", hv_ClassesToEvaluate);
                        HOperatorSet.SetDictTuple(hv_EvalParams, "class_names", hv_ClassNames);
                        hv_KeyExists.Dispose();
                        HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_ids_to_evaluate",
                            out hv_KeyExists);
                        if ((int)(hv_KeyExists) != 0)
                        {
                            //To avoid inconsistent class names/IDs, remove the older ones.
                            HOperatorSet.RemoveDictKey(hv_EvalParams, "class_ids_to_evaluate");
                        }
                    }
                    else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "class_ids_to_evaluate"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual(
                        "classification")))) != 0)
                    {
                        //Class IDs to be used in evaluation.
                        hv_ClassIDsToEvaluate.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "class_ids_to_evaluate", out hv_ClassIDsToEvaluate);
                        HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids_to_evaluate", hv_ClassIDsToEvaluate);
                        hv_KeyExists.Dispose();
                        HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_names_to_evaluate",
                            out hv_KeyExists);
                        if ((int)(hv_KeyExists) != 0)
                        {
                            //To avoid inconsistent class names/IDs, remove the older ones.
                            HOperatorSet.RemoveDictKey(hv_EvalParams, "class_names_to_evaluate");
                        }
                    }
                    else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "anomaly_classification_thresholds"))) != 0)
                    {
                        //Set anomaly classification threshold for confusion matrices.
                        hv_AnomalyClassificationThresholds.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "anomaly_classification_thresholds",
                            out hv_AnomalyClassificationThresholds);
                        HOperatorSet.SetDictTuple(hv_EvalParams, "anomaly_classification_thresholds",
                            hv_AnomalyClassificationThresholds);
                    }
                    else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "evaluate_mask"))) != 0)
                    {
                        hv_EvaluateMask.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "evaluate_mask", out hv_EvaluateMask);
                        if ((int)(hv_EvaluateMask.TupleNot()) != 0)
                        {
                            hv_InstanceType.Dispose();
                            hv_InstanceType = new HTuple(hv_InstanceTypeModel);
                        }
                    }
                    else if ((int)(new HTuple(((hv_OptionalKeyNames.TupleFind(hv_GenParamKeys.TupleSelect(
                        hv_GenParamIndex)))).TupleNotEqual(-1))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Value.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, hv_GenParamKeys.TupleSelect(hv_GenParamIndex),
                                out hv_Value);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_EvalParams, hv_GenParamKeys.TupleSelect(
                                hv_GenParamIndex), hv_Value);
                        }
                    }
                    else
                    {
                        throw new HalconException(("Unknown parameter : '" + (hv_GenParamKeys.TupleSelect(
                            hv_GenParamIndex))) + "'");
                    }
                }
            }
            //
            //Finally specify the evaluation based on all given parameters and defaults.
            HOperatorSet.SetDictTuple(hv_EvalParams, "calculate_ood_measures", 0);
            if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
            {
                if ((int)(new HTuple(hv_InstanceType.TupleEqual("mask"))) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_EvalParams, "evaluate_mask", 1);
                    hv_Measures.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvalParams, "measures", hv_Measures.TupleDifference(
                            "soap"));
                    }
                }
                else
                {
                    HOperatorSet.SetDictTuple(hv_EvalParams, "evaluate_mask", 0);
                }
                //Overwrite instance_type
                HOperatorSet.SetDictTuple(hv_EvalParams, "instance_type", hv_InstanceType);
                //For rectangle2 detection with ignore_direction set to false, we also evaluate the
                //precision of the predicted angle using the Score of Angle Precision (SoAP).
                if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
                {
                    hv_IgnoreDirection.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "ignore_direction", out hv_IgnoreDirection);
                    if ((int)(new HTuple(hv_IgnoreDirection.TupleEqual("false"))) != 0)
                    {
                        hv_Measures.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_EvalParams, "measures", hv_Measures.TupleConcat(
                                "soap"));
                        }
                    }
                }
            }
            else if ((int)(new HTuple(hv_ModelType.TupleEqual("multi_label_classification"))) != 0)
            {
                hv_MinConfidence.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "min_confidence", out hv_MinConfidence);
                HOperatorSet.SetDictTuple(hv_EvalParams, "min_confidence", hv_MinConfidence);
            }
            else if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
            {
                //Check if an OOD measure is requested.
                hv_OODMeasureRequested.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_OODMeasureRequested = ((hv_EvalParams.TupleGetDictTuple(
                        "measures"))).TupleRegexpTest("^ood_");
                }
                hv_OODEvaluationPossible.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_OODEvaluationPossible = new HTuple(hv_OODAvailable.TupleEqual(
                        "true"));
                }
                if ((int)(hv_OODMeasureRequested.TupleAnd(hv_OODEvaluationPossible.TupleNot()
                    )) != 0)
                {
                    throw new HalconException("Out-of-distribution detection measures can only be computed after 'fit_dl_out_of_distribution' has been called.");
                }
                //If all measures are requested and the prerequisites for
                //OOD detection evaluations are met, all OOD measures are
                //computed.
                hv_FoundIndex.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_FoundIndex = ((hv_EvalParams.TupleGetDictTuple(
                        "measures"))).TupleFind("all");
                }
                hv_AllMeasuresRequested.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_AllMeasuresRequested = (new HTuple(hv_FoundIndex.TupleNotEqual(
                        -1))).TupleAnd(new HTuple(hv_FoundIndex.TupleNotEqual(new HTuple())));
                }
                if ((int)(hv_OODEvaluationPossible.TupleAnd(hv_AllMeasuresRequested.TupleOr(
                    hv_OODMeasureRequested))) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_EvalParams, "calculate_ood_measures", 1);
                    //Write OOD threshold to EvalParams so it can be used for the visualization
                    //in dev_display_classification_results.
                    hv_OODThreshold.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "ood_threshold", out hv_OODThreshold);
                    HOperatorSet.SetDictTuple(hv_EvalParams, "ood_threshold", hv_OODThreshold);
                }
            }
            //
            //Set class names.
            if ((int)(new HTuple(hv_ModelType.TupleEqual("3d_gripping_point_detection"))) != 0)
            {
                HOperatorSet.SetDictTuple(hv_EvalParams, "class_names", "gripping_map");
            }
            else
            {
                //Get the class names from the dataset if present.
                hv_ClassInfoExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", (new HTuple("class_names")).TupleConcat(
                    "class_ids"), out hv_ClassInfoExists);
                if ((int)(new HTuple(((hv_ClassInfoExists.TupleSum())).TupleEqual(new HTuple(hv_ClassInfoExists.TupleLength()
                    )))) != 0)
                {
                    hv_ClassNames.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDataset, "class_names", out hv_ClassNames);
                    hv_DatasetClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDataset, "class_ids", out hv_DatasetClassIDs);
                    //Set the class names only for the class IDs that are evaluated.
                    hv_EvaluateClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_EvaluateClassIDs);
                    hv_ClassIDsToClassNames.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassIDsToClassNames = HTuple.TupleGenConst(
                            (hv_DatasetClassIDs.TupleMax()) + 1, "");
                    }
                    if (hv_ClassIDsToClassNames == null)
                        hv_ClassIDsToClassNames = new HTuple();
                    hv_ClassIDsToClassNames[hv_DatasetClassIDs] = hv_ClassNames;
                    if ((int)(new HTuple((new HTuple(hv_EvaluateClassIDs.TupleLength())).TupleEqual(
                        new HTuple(hv_ClassNames.TupleLength())))) != 0)
                    {
                        hv_EvaluateClassNames.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EvaluateClassNames = hv_ClassIDsToClassNames.TupleSelect(
                                hv_EvaluateClassIDs);
                        }
                        //Set the class names to EvalParams.
                        HOperatorSet.SetDictTuple(hv_EvalParams, "class_names", hv_EvaluateClassNames);
                    }
                }
            }
            //
            //Get indices of samples to read from the dataset.
            hv_DLSamples.Dispose();
            HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
            //
            //Check if there are samples present in the dataset.
            if ((int)(new HTuple((new HTuple(hv_DLSamples.TupleLength())).TupleEqual(0))) != 0)
            {
                throw new HalconException("The provided set of samples in the dataset must be non-empty.");
            }
            //
            //Check for empty SampleSelectValues.
            if ((int)(new HTuple((new HTuple(hv_SampleSelectValues.TupleLength())).TupleEqual(
                0))) != 0)
            {
                if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("image_ids"))) != 0)
                {
                    throw new HalconException("The provided set of samples of the 'image_ids' selection must be non-empty.");
                }
                else if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("sample_indices"))) != 0)
                {
                    throw new HalconException("The provided set of samples of the 'sample_indices' selection must be non-empty.");
                }
                else
                {
                    throw new HalconException("Provide a name for 'split' selection.");
                }
            }
            //
            //
            //Get the sample indices according to the sample selection method.
            hv_SampleIndices.Dispose();
            hv_SampleIndices = new HTuple();
            if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("split"))) != 0)
            {
                //Get the samples of the split specified.
                hv_SampleIndices.Dispose();
                find_dl_samples(hv_DLSamples, "split", hv_SampleSelectValues, "or", out hv_SampleIndices);
            }
            else if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("image_ids"))) != 0)
            {
                //Get the samples specified by 'image_ids'.
                if ((int)(new HTuple((new HTuple(hv_SampleSelectValues.TupleLength())).TupleGreater(
                    new HTuple(hv_DLSamples.TupleLength())))) != 0)
                {
                    throw new HalconException("The number of the image ids provided through 'image_id' is invalid.");
                }
                hv_SampleIndices.Dispose();
                find_dl_samples(hv_DLSamples, "image_id", hv_SampleSelectValues, "or", out hv_SampleIndices);
            }
            else if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("sample_indices"))) != 0)
            {
                //Get the samples specified by 'sample_indices'.
                if ((int)((new HTuple(((hv_SampleSelectValues.TupleMin())).TupleLess(0))).TupleOr(
                    new HTuple(((hv_SampleSelectValues.TupleMax())).TupleGreater((new HTuple(hv_DLSamples.TupleLength()
                    )) - 1)))) != 0)
                {
                    throw new HalconException("The range of the indices provided through 'sample_indices' is invalid.");
                }
                hv_SampleIndices.Dispose();
                hv_SampleIndices = new HTuple(hv_SampleSelectValues);
            }
            else
            {
                throw new HalconException(("Unknown sample selection method : '" + hv_SampleSelectMethod) + "'");
            }
            //
            //Get the number of batches.
            hv_NumSamples.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_NumSamples = new HTuple(hv_SampleIndices.TupleLength()
                    );
            }
            hv_NumBatches.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_NumBatches = ((((hv_NumSamples / (hv_BatchSize.TupleReal()
                    ))).TupleCeil())).TupleInt();
            }
            //
            //Get the number of OOD samples.
            if ((int)(hv_EvalParams.TupleGetDictTuple("calculate_ood_measures")) != 0)
            {
                hv_OODSamplesAvailable.Dispose();
                HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", "ood_samples", out hv_OODSamplesAvailable);
                if ((int)(hv_OODSamplesAvailable) != 0)
                {
                    hv_NumOODSamples.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumOODSamples = new HTuple(((hv_DLDataset.TupleGetDictTuple(
                            "ood_samples"))).TupleLength());
                    }
                }
                else
                {
                    hv_NumOODSamples.Dispose();
                    hv_NumOODSamples = 0;
                }
                hv_NumOODBatches.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumOODBatches = ((((hv_NumOODSamples / (hv_BatchSize.TupleReal()
                        ))).TupleCeil())).TupleInt();
                }
                hv_TotalNumBatches.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TotalNumBatches = hv_NumBatches + hv_NumOODBatches;
                }
            }
            else
            {
                hv_TotalNumBatches.Dispose();
                hv_TotalNumBatches = new HTuple(hv_NumBatches);
            }
            //
            //Check for empty samples selected by the selection method.
            if ((int)(new HTuple(hv_NumSamples.TupleEqual(0))) != 0)
            {
                throw new HalconException(("No samples present in the dataset that are part of the '" + hv_SampleSelectMethod) + "' selection.");
            }
            //
            //
            //** Running measures are initialized according to evaluation method.
            //
            hv_RunningMeasures.Dispose();
            init_running_evaluation_measures(hv_EvalParams, out hv_RunningMeasures);
            //
            //
            //** Apply model to each image and gather evaluation information: ***
            //
            //Use alternative outputs if requested.
            hv_Outputs.Dispose();
            hv_Outputs = new HTuple();
            //
            if ((int)((new HTuple(hv_ModelType.TupleEqual("gc_anomaly_detection"))).TupleAnd(
                new HTuple(hv_GenParam.TupleNotEqual(new HTuple())))) != 0)
            {
                //
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_GenParam, "key_exists", "gc_anomaly_networks",
                    out hv_KeyExists);
                if ((int)(hv_KeyExists) != 0)
                {
                    hv_EvalGCAnomalyNetworks.Dispose();
                    HOperatorSet.GetDictTuple(hv_GenParam, "gc_anomaly_networks", out hv_EvalGCAnomalyNetworks);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_EvalGCAnomalyNetworks = hv_EvalGCAnomalyNetworks.TupleSort()
                                ;
                            hv_EvalGCAnomalyNetworks.Dispose();
                            hv_EvalGCAnomalyNetworks = ExpTmpLocalVar_EvalGCAnomalyNetworks;
                        }
                    }
                    hv_ModelGCAnomalyNetworks.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "gc_anomaly_networks", out hv_ModelGCAnomalyNetworks);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ModelGCAnomalyNetworks = hv_ModelGCAnomalyNetworks.TupleSort()
                                ;
                            hv_ModelGCAnomalyNetworks.Dispose();
                            hv_ModelGCAnomalyNetworks = ExpTmpLocalVar_ModelGCAnomalyNetworks;
                        }
                    }
                    //
                    hv_DefaultRequested.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DefaultRequested = (new HTuple((new HTuple(hv_EvalGCAnomalyNetworks.TupleLength()
                            )).TupleEqual(0))).TupleOr(new HTuple(hv_EvalGCAnomalyNetworks.TupleEqual(
                            hv_ModelGCAnomalyNetworks)));
                    }
                    for (hv_EvalAnomalyNetworkIndex = 0; (int)hv_EvalAnomalyNetworkIndex <= (int)((new HTuple(hv_EvalGCAnomalyNetworks.TupleLength()
                        )) - 1); hv_EvalAnomalyNetworkIndex = (int)hv_EvalAnomalyNetworkIndex + 1)
                    {
                        hv_EvalGCAnomalyNetwork.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EvalGCAnomalyNetwork = hv_EvalGCAnomalyNetworks.TupleSelect(
                                hv_EvalAnomalyNetworkIndex);
                        }
                        hv_FindIndex.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FindIndex = hv_ModelGCAnomalyNetworks.TupleFind(
                                hv_EvalGCAnomalyNetwork);
                        }
                        if ((int)((new HTuple(hv_FindIndex.TupleEqual(new HTuple()))).TupleOr(
                            new HTuple(hv_FindIndex.TupleEqual(-1)))) != 0)
                        {
                            throw new HalconException(("Invalid 'gc_anomaly_networks' requested. Model does not contain a " + hv_EvalGCAnomalyNetwork) + " network.");
                        }
                        if ((int)(hv_DefaultRequested.TupleNot()) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_Outputs = hv_Outputs.TupleConcat(
                                        "anomaly_image_" + hv_EvalGCAnomalyNetwork);
                                    hv_Outputs.Dispose();
                                    hv_Outputs = ExpTmpLocalVar_Outputs;
                                }
                            }
                        }
                    }
                }
            }
            //
            //Initialize progress variables.
            if ((int)(hv_ShowProgress) != 0)
            {
                hv_Progress.Dispose();
                hv_Progress = new HTuple();
                hv_Progress[0] = "Procedure: evaluate_dl_model";
                hv_Progress[1] = "";
                hv_Progress[2] = "";
                hv_Progress[3] = "";
                if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                {
                    hv_TaskInfo.Dispose();
                    hv_TaskInfo = "Task: 1/2: Applying the model and collecting running evaluation measures";
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Progress = hv_Progress.TupleConcat(
                                hv_TaskInfo);
                            hv_Progress.Dispose();
                            hv_Progress = ExpTmpLocalVar_Progress;
                        }
                    }
                }
                hv_SecondsStart.Dispose();
                HOperatorSet.CountSeconds(out hv_SecondsStart);
                // dev_inspect_ctrl(...); only in hdevelop
            }
            //
            //Loop batchwise over the samples to be evaluated.
            HTuple end_val343 = hv_NumBatches - 1;
            HTuple step_val343 = 1;
            for (hv_BatchIndex = 0; hv_BatchIndex.Continue(end_val343, step_val343); hv_BatchIndex = hv_BatchIndex.TupleAdd(step_val343))
            {
                hv_BatchStart.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_BatchStart = hv_BatchIndex * hv_BatchSize;
                }
                hv_BatchEnd.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_BatchEnd = (((hv_BatchStart + hv_BatchSize) - 1)).TupleMin2(
                        hv_NumSamples - 1);
                }
                hv_SamplesIndicesBatch.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SamplesIndicesBatch = hv_SampleIndices.TupleSelectRange(
                        hv_BatchStart, hv_BatchEnd);
                }
                //
                //Read samples
                hv_DLSamplesBatch.Dispose();
                read_dl_samples(hv_DLDataset, hv_SamplesIndicesBatch, out hv_DLSamplesBatch);
                //
                //Apply the model.
                hv_DLResultsBatch.Dispose();
                HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_DLSamplesBatch, hv_Outputs,
                    out hv_DLResultsBatch);
                //
                //Update the running measures.
                update_running_evaluation_measures(hv_DLSamplesBatch, hv_DLResultsBatch,
                    hv_EvalParams, hv_RunningMeasures);
                //
                //Provide progress information.
                if ((int)(hv_ShowProgress) != 0)
                {
                    if ((int)((new HTuple(((hv_BatchIndex % 10)).TupleEqual(1))).TupleOr(new HTuple(hv_BatchIndex.TupleEqual(
                        hv_NumBatches - 1)))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SecondsElapsed.Dispose(); hv_SecondsRemaining.Dispose(); hv_ProgressPercent.Dispose(); hv_ProgressPerSecond.Dispose();
                            estimate_progress(hv_SecondsStart, 0, hv_BatchIndex, hv_TotalNumBatches - 1,
                                out hv_SecondsElapsed, out hv_SecondsRemaining, out hv_ProgressPercent,
                                out hv_ProgressPerSecond);
                        }
                        hv_TimeElapsedString.Dispose();
                        timespan_string(hv_SecondsElapsed, "auto", out hv_TimeElapsedString);
                        hv_TimeRemainingString.Dispose();
                        timespan_string(hv_SecondsRemaining, "top2", out hv_TimeRemainingString);
                        if (hv_Progress == null)
                            hv_Progress = new HTuple();
                        hv_Progress[1] = ("Progress: " + (hv_ProgressPercent.TupleRound())) + " %";
                        if (hv_Progress == null)
                            hv_Progress = new HTuple();
                        hv_Progress[2] = "Time elapsed: " + hv_TimeElapsedString;
                        if (hv_Progress == null)
                            hv_Progress = new HTuple();
                        hv_Progress[3] = "Time left: " + hv_TimeRemainingString;
                    }
                }
            }
            //
            //Loop batchwise over the out-of-distribution samples to be evaluated.
            if ((int)(hv_EvalParams.TupleGetDictTuple("calculate_ood_measures")) != 0)
            {
                HTuple end_val372 = hv_NumOODBatches - 1;
                HTuple step_val372 = 1;
                for (hv_BatchIndex = 0; hv_BatchIndex.Continue(end_val372, step_val372); hv_BatchIndex = hv_BatchIndex.TupleAdd(step_val372))
                {
                    hv_BatchStart.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BatchStart = hv_BatchIndex * hv_BatchSize;
                    }
                    hv_BatchEnd.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BatchEnd = (((hv_BatchStart + hv_BatchSize) - 1)).TupleMin2(
                            hv_NumOODSamples - 1);
                    }
                    //
                    //Read samples
                    hv_DLSamplesBatch.Dispose();
                    hv_DLSamplesBatch = new HTuple();
                    HTuple end_val378 = hv_BatchEnd;
                    HTuple step_val378 = 1;
                    for (hv_SampleIndex = hv_BatchStart; hv_SampleIndex.Continue(end_val378, step_val378); hv_SampleIndex = hv_SampleIndex.TupleAdd(step_val378))
                    {
                        hv_DLSample.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DLSample = ((hv_DLDataset.TupleGetDictTuple(
                                "ood_samples"))).TupleSelect(hv_SampleIndex);
                        }
                        hv_DictPath.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLSample, "dlsample_file_name", out hv_DictPath);
                        try
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DLSampleProc.Dispose();
                                HOperatorSet.ReadDict(((hv_DLDataset.TupleGetDictTuple("dlsample_dir")) + "/") + hv_DictPath,
                                    new HTuple(), new HTuple(), out hv_DLSampleProc);
                            }
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                            throw new HalconException((((("An error has occurred while reading " + (hv_DLDataset.TupleGetDictTuple(
                                "dlsample_dir"))) + "/") + hv_DictPath) + new HTuple(" , HALCON error # ")) + (hv_Exception.TupleSelect(
                                0)));
                        }
                        //Add it to the DLSampleBatch.
                        hv_PreprocessedSampleIsOod.Dispose();
                        HOperatorSet.GetDictParam(hv_DLSampleProc, "key_exists", "is_ood", out hv_PreprocessedSampleIsOod);
                        if ((int)(hv_PreprocessedSampleIsOod.TupleNot()) != 0)
                        {
                            throw new HalconException(((("The preprocessed sample at " + (hv_DLDataset.TupleGetDictTuple(
                                "dlsample_dir"))) + "/") + hv_DictPath) + " does not contain the key 'is_ood' but the corresponding sample in the DLDataset is part of DLDataset.ood_samples. To ensure proper evaluation of your out-of-distribution data please use the procedure 'add_dl_out_of_distribution_data' to add out-of-distribution samples to your dataset.");
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_DLSamplesBatch = hv_DLSamplesBatch.TupleConcat(
                                    hv_DLSampleProc);
                                hv_DLSamplesBatch.Dispose();
                                hv_DLSamplesBatch = ExpTmpLocalVar_DLSamplesBatch;
                            }
                        }
                    }
                    //
                    //Apply the model.
                    hv_DLResultsBatch.Dispose();
                    HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_DLSamplesBatch, hv_Outputs,
                        out hv_DLResultsBatch);
                    //
                    //Update the running measures.
                    update_running_ood_detection_measures(hv_DLSamplesBatch, hv_DLResultsBatch,
                        hv_EvalParams, hv_RunningMeasures);
                    //
                    //Provide progress information.
                    if ((int)(hv_ShowProgress) != 0)
                    {
                        if ((int)((new HTuple(((hv_BatchIndex % 10)).TupleEqual(1))).TupleOr(new HTuple(hv_BatchIndex.TupleEqual(
                            hv_NumOODBatches - 1)))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SecondsElapsed.Dispose(); hv_SecondsRemaining.Dispose(); hv_ProgressPercent.Dispose(); hv_ProgressPerSecond.Dispose();
                                estimate_progress(hv_SecondsStart, 0, hv_NumBatches + hv_BatchIndex,
                                    hv_TotalNumBatches - 1, out hv_SecondsElapsed, out hv_SecondsRemaining,
                                    out hv_ProgressPercent, out hv_ProgressPerSecond);
                            }
                            hv_TimeElapsedString.Dispose();
                            timespan_string(hv_SecondsElapsed, "auto", out hv_TimeElapsedString);
                            hv_TimeRemainingString.Dispose();
                            timespan_string(hv_SecondsRemaining, "top2", out hv_TimeRemainingString);
                            if (hv_Progress == null)
                                hv_Progress = new HTuple();
                            hv_Progress[1] = ("Progress: " + (hv_ProgressPercent.TupleRound())) + " %";
                            if (hv_Progress == null)
                                hv_Progress = new HTuple();
                            hv_Progress[2] = "Time elapsed: " + hv_TimeElapsedString;
                            if (hv_Progress == null)
                                hv_Progress = new HTuple();
                            hv_Progress[3] = "Time left: " + hv_TimeRemainingString;
                        }
                    }
                }
            }
            //
            //Provide progress information.
            if ((int)(hv_ShowProgress.TupleAnd(new HTuple(hv_ModelType.TupleEqual("detection")))) != 0)
            {
                hv_Progress.Dispose();
                hv_Progress = new HTuple();
                hv_Progress[0] = "Procedure: evaluate_dl_model";
                hv_Progress[1] = "";
                hv_Progress[2] = "";
                if (hv_Progress == null)
                    hv_Progress = new HTuple();
                hv_Progress[1] = "Please wait...";
                if (hv_Progress == null)
                    hv_Progress = new HTuple();
                hv_Progress[2] = "Task: 2/2: Calculating final evaluation measures";
            }
            //
            //
            //** Do the actual calculation of measures: ***
            //
            hv_EvaluationResult.Dispose();
            calculate_evaluation_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
            //
            //Close progress inspect.
            if ((int)(hv_ShowProgress) != 0)
            {
                hv_Progress.Dispose();
                hv_Progress = "Done.";
                // dev_close_inspect_ctrl(...); only in hdevelop
            }
            //

            hv_ModelType.Dispose();
            hv_ClassIDs.Dispose();
            hv_ClassNames.Dispose();
            hv_Alphabet.Dispose();
            hv_BatchSize.Dispose();
            hv_OODAvailable.Dispose();
            hv_InstanceTypeModel.Dispose();
            hv_Exception.Dispose();
            hv_IsInstanceSegmentation.Dispose();
            hv_InstanceType.Dispose();
            hv_ModelIgnoreClassIDs.Dispose();
            hv_ShowProgress.Dispose();
            hv_GenParamKeys.Dispose();
            hv_OptionalKeyNames.Dispose();
            hv_GenParamIndex.Dispose();
            hv_IoUThreshold.Dispose();
            hv_MaxNumDetections.Dispose();
            hv_AreaRanges.Dispose();
            hv_DetailedEvaluation.Dispose();
            hv_AllocationBlockLength.Dispose();
            hv_InterpolatePRCurves.Dispose();
            hv_IgnoreClassIDs.Dispose();
            hv_AllIgnoreClassIDs.Dispose();
            hv_EvaluateClassIDs.Dispose();
            hv_ClassesToEvaluate.Dispose();
            hv_KeyExists.Dispose();
            hv_ClassIDsToEvaluate.Dispose();
            hv_AnomalyClassificationThresholds.Dispose();
            hv_EvaluateMask.Dispose();
            hv_Value.Dispose();
            hv_Measures.Dispose();
            hv_IgnoreDirection.Dispose();
            hv_MinConfidence.Dispose();
            hv_OODMeasureRequested.Dispose();
            hv_OODEvaluationPossible.Dispose();
            hv_FoundIndex.Dispose();
            hv_AllMeasuresRequested.Dispose();
            hv_OODThreshold.Dispose();
            hv_ClassInfoExists.Dispose();
            hv_DatasetClassIDs.Dispose();
            hv_ClassIDsToClassNames.Dispose();
            hv_EvaluateClassNames.Dispose();
            hv_DLSamples.Dispose();
            hv_SampleIndices.Dispose();
            hv_NumSamples.Dispose();
            hv_NumBatches.Dispose();
            hv_OODSamplesAvailable.Dispose();
            hv_NumOODSamples.Dispose();
            hv_NumOODBatches.Dispose();
            hv_TotalNumBatches.Dispose();
            hv_RunningMeasures.Dispose();
            hv_Outputs.Dispose();
            hv_EvalGCAnomalyNetworks.Dispose();
            hv_ModelGCAnomalyNetworks.Dispose();
            hv_DefaultRequested.Dispose();
            hv_EvalAnomalyNetworkIndex.Dispose();
            hv_EvalGCAnomalyNetwork.Dispose();
            hv_FindIndex.Dispose();
            hv_Progress.Dispose();
            hv_TaskInfo.Dispose();
            hv_SecondsStart.Dispose();
            hv_BatchIndex.Dispose();
            hv_BatchStart.Dispose();
            hv_BatchEnd.Dispose();
            hv_SamplesIndicesBatch.Dispose();
            hv_DLSamplesBatch.Dispose();
            hv_DLResultsBatch.Dispose();
            hv_SecondsElapsed.Dispose();
            hv_SecondsRemaining.Dispose();
            hv_ProgressPercent.Dispose();
            hv_ProgressPerSecond.Dispose();
            hv_TimeElapsedString.Dispose();
            hv_TimeRemainingString.Dispose();
            hv_SampleIndex.Dispose();
            hv_DLSample.Dispose();
            hv_DictPath.Dispose();
            hv_DLSampleProc.Dispose();
            hv_PreprocessedSampleIsOod.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_ModelType.Dispose();
            hv_ClassIDs.Dispose();
            hv_ClassNames.Dispose();
            hv_Alphabet.Dispose();
            hv_BatchSize.Dispose();
            hv_OODAvailable.Dispose();
            hv_InstanceTypeModel.Dispose();
            hv_Exception.Dispose();
            hv_IsInstanceSegmentation.Dispose();
            hv_InstanceType.Dispose();
            hv_ModelIgnoreClassIDs.Dispose();
            hv_ShowProgress.Dispose();
            hv_GenParamKeys.Dispose();
            hv_OptionalKeyNames.Dispose();
            hv_GenParamIndex.Dispose();
            hv_IoUThreshold.Dispose();
            hv_MaxNumDetections.Dispose();
            hv_AreaRanges.Dispose();
            hv_DetailedEvaluation.Dispose();
            hv_AllocationBlockLength.Dispose();
            hv_InterpolatePRCurves.Dispose();
            hv_IgnoreClassIDs.Dispose();
            hv_AllIgnoreClassIDs.Dispose();
            hv_EvaluateClassIDs.Dispose();
            hv_ClassesToEvaluate.Dispose();
            hv_KeyExists.Dispose();
            hv_ClassIDsToEvaluate.Dispose();
            hv_AnomalyClassificationThresholds.Dispose();
            hv_EvaluateMask.Dispose();
            hv_Value.Dispose();
            hv_Measures.Dispose();
            hv_IgnoreDirection.Dispose();
            hv_MinConfidence.Dispose();
            hv_OODMeasureRequested.Dispose();
            hv_OODEvaluationPossible.Dispose();
            hv_FoundIndex.Dispose();
            hv_AllMeasuresRequested.Dispose();
            hv_OODThreshold.Dispose();
            hv_ClassInfoExists.Dispose();
            hv_DatasetClassIDs.Dispose();
            hv_ClassIDsToClassNames.Dispose();
            hv_EvaluateClassNames.Dispose();
            hv_DLSamples.Dispose();
            hv_SampleIndices.Dispose();
            hv_NumSamples.Dispose();
            hv_NumBatches.Dispose();
            hv_OODSamplesAvailable.Dispose();
            hv_NumOODSamples.Dispose();
            hv_NumOODBatches.Dispose();
            hv_TotalNumBatches.Dispose();
            hv_RunningMeasures.Dispose();
            hv_Outputs.Dispose();
            hv_EvalGCAnomalyNetworks.Dispose();
            hv_ModelGCAnomalyNetworks.Dispose();
            hv_DefaultRequested.Dispose();
            hv_EvalAnomalyNetworkIndex.Dispose();
            hv_EvalGCAnomalyNetwork.Dispose();
            hv_FindIndex.Dispose();
            hv_Progress.Dispose();
            hv_TaskInfo.Dispose();
            hv_SecondsStart.Dispose();
            hv_BatchIndex.Dispose();
            hv_BatchStart.Dispose();
            hv_BatchEnd.Dispose();
            hv_SamplesIndicesBatch.Dispose();
            hv_DLSamplesBatch.Dispose();
            hv_DLResultsBatch.Dispose();
            hv_SecondsElapsed.Dispose();
            hv_SecondsRemaining.Dispose();
            hv_ProgressPercent.Dispose();
            hv_ProgressPerSecond.Dispose();
            hv_TimeElapsedString.Dispose();
            hv_TimeRemainingString.Dispose();
            hv_SampleIndex.Dispose();
            hv_DLSample.Dispose();
            hv_DictPath.Dispose();
            hv_DLSampleProc.Dispose();
            hv_PreprocessedSampleIsOod.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Model
    // Short Description: Retrieve the indices of Samples that contain KeyName matching KeyValue according to the Mode set. 
    public void find_dl_samples(HTuple hv_Samples, HTuple hv_KeyName, HTuple hv_KeyValue,
        HTuple hv_Mode, out HTuple hv_SampleIndices)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_NumKeyValues = new HTuple(), hv_NumFound = new HTuple();
        HTuple hv_SampleIndex = new HTuple(), hv_Sample = new HTuple();
        HTuple hv_KeyExists = new HTuple(), hv_Tuple = new HTuple();
        HTuple hv_Hit = new HTuple(), hv_ValueIndex = new HTuple();
        HTuple hv_Value = new HTuple();
        // Initialize local and output iconic variables 
        hv_SampleIndices = new HTuple();
        try
        {
            //
            //This procedure gets the indices of the samples that contain the
            //requested KeyName matching the requested KeyValue according to the Mode.
            //If there is no match, an empty tuple [] will be returned.
            //
            //Check input parameters.
            if ((int)(new HTuple((new HTuple(hv_KeyName.TupleLength())).TupleNotEqual(1))) != 0)
            {
                throw new HalconException(new HTuple("Invalid KeyName size: ") + (new HTuple(hv_KeyName.TupleLength()
                    )));
            }
            if ((int)(new HTuple((new HTuple(hv_Mode.TupleLength())).TupleNotEqual(1))) != 0)
            {
                throw new HalconException(new HTuple("Invalid Mode size: ") + (new HTuple(hv_Mode.TupleLength()
                    )));
            }
            if ((int)((new HTuple((new HTuple(hv_Mode.TupleNotEqual("match"))).TupleAnd(
                new HTuple(hv_Mode.TupleNotEqual("or"))))).TupleAnd(new HTuple(hv_Mode.TupleNotEqual(
                "contain")))) != 0)
            {
                throw new HalconException("Invalid Mode value: " + hv_Mode);
            }
            hv_NumKeyValues.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_NumKeyValues = new HTuple(hv_KeyValue.TupleLength()
                    );
            }
            if ((int)((new HTuple(hv_Mode.TupleEqual("contain"))).TupleAnd(new HTuple(hv_NumKeyValues.TupleLess(
                1)))) != 0)
            {
                throw new HalconException("Invalid KeyValue size for contain Mode: " + hv_NumKeyValues);
            }
            //
            //Find the indices.
            hv_SampleIndices.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_SampleIndices = HTuple.TupleGenConst(
                    new HTuple(hv_Samples.TupleLength()), 0);
            }
            hv_NumFound.Dispose();
            hv_NumFound = 0;
            //
            for (hv_SampleIndex = 0; (int)hv_SampleIndex <= (int)((new HTuple(hv_Samples.TupleLength()
                )) - 1); hv_SampleIndex = (int)hv_SampleIndex + 1)
            {
                hv_Sample.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Sample = hv_Samples.TupleSelect(
                        hv_SampleIndex);
                }
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_Sample, "key_exists", hv_KeyName, out hv_KeyExists);
                if ((int)(hv_KeyExists) != 0)
                {
                    hv_Tuple.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, hv_KeyName, out hv_Tuple);
                    if ((int)(new HTuple(hv_Mode.TupleEqual("match"))) != 0)
                    {
                        //Mode 'match': Tuple must be equal KeyValue.
                        hv_Hit.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Hit = new HTuple(hv_Tuple.TupleEqual(
                                hv_KeyValue));
                        }
                    }
                    else if ((int)((new HTuple(hv_Mode.TupleEqual("or"))).TupleAnd(
                        new HTuple((new HTuple(hv_Tuple.TupleLength())).TupleEqual(1)))) != 0)
                    {
                        //Mode 'or': Tuple must have only 1 element and it has to be equal to any of KeyValues elements.
                        hv_Hit.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Hit = new HTuple(((hv_KeyValue.TupleFindFirst(
                                hv_Tuple))).TupleGreaterEqual(0));
                        }
                    }
                    else if ((int)(new HTuple(hv_Mode.TupleEqual("contain"))) != 0)
                    {
                        //Mode 'contain': Tuple must contain any of the elements in KeyValue.
                        HTuple end_val37 = hv_NumKeyValues - 1;
                        HTuple step_val37 = 1;
                        for (hv_ValueIndex = 0; hv_ValueIndex.Continue(end_val37, step_val37); hv_ValueIndex = hv_ValueIndex.TupleAdd(step_val37))
                        {
                            hv_Value.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Value = hv_KeyValue.TupleSelect(
                                    hv_ValueIndex);
                            }
                            hv_Hit.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Hit = new HTuple(((hv_Tuple.TupleFindFirst(
                                    hv_Value))).TupleGreaterEqual(0));
                            }
                            if ((int)(hv_Hit) != 0)
                            {
                                break;
                            }
                        }
                    }
                    else
                    {
                        //Unsupported configuration.
                        hv_Hit.Dispose();
                        hv_Hit = 0;
                    }
                    if ((int)(hv_Hit) != 0)
                    {
                        if (hv_SampleIndices == null)
                            hv_SampleIndices = new HTuple();
                        hv_SampleIndices[hv_NumFound] = hv_SampleIndex;
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_NumFound = hv_NumFound + 1;
                                hv_NumFound.Dispose();
                                hv_NumFound = ExpTmpLocalVar_NumFound;
                            }
                        }
                    }
                }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                {
                    HTuple
                      ExpTmpLocalVar_SampleIndices = hv_SampleIndices.TupleSelectRange(
                        0, hv_NumFound - 1);
                    hv_SampleIndices.Dispose();
                    hv_SampleIndices = ExpTmpLocalVar_SampleIndices;
                }
            }

            hv_NumKeyValues.Dispose();
            hv_NumFound.Dispose();
            hv_SampleIndex.Dispose();
            hv_Sample.Dispose();
            hv_KeyExists.Dispose();
            hv_Tuple.Dispose();
            hv_Hit.Dispose();
            hv_ValueIndex.Dispose();
            hv_Value.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_NumKeyValues.Dispose();
            hv_NumFound.Dispose();
            hv_SampleIndex.Dispose();
            hv_Sample.Dispose();
            hv_KeyExists.Dispose();
            hv_Tuple.Dispose();
            hv_Hit.Dispose();
            hv_ValueIndex.Dispose();
            hv_Value.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Classification
    // Short Description: Compute a confusion matrix, which an be visualized and/or returned. 
    public void gen_confusion_matrix(HTuple hv_GroundTruthLabels, HTuple hv_PredictedClasses,
        HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_WindowHandle, out HTuple hv_ConfusionMatrix)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_DisplayMatrix = new HTuple(), hv_ReturnMatrix = new HTuple();
        HTuple hv_DisplayColor = new HTuple(), hv_DisplayColumnWidth = new HTuple();
        HTuple hv_GenParamIndex = new HTuple(), hv_CalculateRelativeMatrix = new HTuple();
        HTuple hv_Classes = new HTuple(), hv_NumClasses = new HTuple();
        HTuple hv_AbsoluteMatrixID = new HTuple(), hv_RelativeMatrixID = new HTuple();
        HTuple hv_ColumnMatrix = new HTuple(), hv_Class = new HTuple();
        HTuple hv_ThisLabel = new HTuple(), hv_NumClassGroundTruth = new HTuple();
        HTuple hv_RowMatrix = new HTuple(), hv_PredictedClass = new HTuple();
        HTuple hv_ThisPredictedClass = new HTuple(), hv_NumMatches = new HTuple();
        HTuple hv_RelativeError = new HTuple(), hv_StringWidths = new HTuple();
        HTuple hv_StringIndex = new HTuple(), hv_String = new HTuple();
        HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
        HTuple hv_StringWidth = new HTuple(), hv_StringHeight = new HTuple();
        HTuple hv_MaxStringWidth = new HTuple(), hv_RowStart = new HTuple();
        HTuple hv_RowDistance = new HTuple(), hv_RowEnd = new HTuple();
        HTuple hv_ColumnStart = new HTuple(), hv_ColumnOffset = new HTuple();
        HTuple hv_ColumnEnd = new HTuple(), hv_Width = new HTuple();
        HTuple hv_Height = new HTuple(), hv_WidthLimit = new HTuple();
        HTuple hv_HeightLimit = new HTuple(), hv_TextRow = new HTuple();
        HTuple hv_TextColumn = new HTuple(), hv_Index = new HTuple();
        HTuple hv_Text = new HTuple(), hv_Row = new HTuple(), hv_Column = new HTuple();
        HTuple hv_AbsoluteTransposedMatrixID = new HTuple(), hv_MatrixText = new HTuple();
        HTuple hv_MatrixMaxID = new HTuple(), hv_MaxValue = new HTuple();
        HTuple hv_StringConversion = new HTuple(), hv_RelativeTransposedMatrixID = new HTuple();
        HTuple hv_TextColor = new HTuple(), hv_RelativeValues = new HTuple();
        HTuple hv_Thresholds = new HTuple(), hv_Colors = new HTuple();
        HTuple hv_Greater = new HTuple(), hv_Indices = new HTuple();
        HTuple hv_DiagonalIndex = new HTuple(), hv_Value = new HTuple();
        // Initialize local and output iconic variables 
        hv_ConfusionMatrix = new HTuple();
        try
        {
            //This procedure computes a confusion matrix.
            //Therefore, it compares the classes
            //assigned in GroundTruthLabels and PredictedClasses.
            //The resulting confusion matrix can be
            //visualized, returned, or both.
            //In each case, the output can be changed
            //via generic parameters using GenParamName and GenParamValue.
            //For the visualization, the graphics window
            //must be specified with WindowHandle.
            //
            if ((int)(new HTuple((new HTuple(hv_GroundTruthLabels.TupleLength())).TupleNotEqual(
                new HTuple(hv_PredictedClasses.TupleLength())))) != 0)
            {
                throw new HalconException("Number of ground truth labels and predicted classes must be equal.");
            }
            //
            //Set generic parameter defaults.
            hv_DisplayMatrix.Dispose();
            hv_DisplayMatrix = "absolute";
            hv_ReturnMatrix.Dispose();
            hv_ReturnMatrix = "absolute";
            hv_DisplayColor.Dispose();
            hv_DisplayColor = "true";
            hv_DisplayColumnWidth.Dispose();
            hv_DisplayColumnWidth = "minimal";
            //
            //Parse generic parameters.
            for (hv_GenParamIndex = 0; (int)hv_GenParamIndex <= (int)((new HTuple(hv_GenParamName.TupleLength()
                )) - 1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
            {
                if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "display_matrix"))) != 0)
                {
                    //Set 'display_matrix'.
                    hv_DisplayMatrix.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DisplayMatrix = hv_GenParamValue.TupleSelect(
                            hv_GenParamIndex);
                    }
                }
                else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "return_matrix"))) != 0)
                {
                    //Set 'return_matrix'.
                    hv_ReturnMatrix.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ReturnMatrix = hv_GenParamValue.TupleSelect(
                            hv_GenParamIndex);
                    }
                }
                else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "display_color"))) != 0)
                {
                    //Set 'display_color'.
                    hv_DisplayColor.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DisplayColor = hv_GenParamValue.TupleSelect(
                            hv_GenParamIndex);
                    }
                }
                else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "display_column_width"))) != 0)
                {
                    //Set 'display_column_width'.
                    hv_DisplayColumnWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DisplayColumnWidth = hv_GenParamValue.TupleSelect(
                            hv_GenParamIndex);
                    }
                }
                else
                {
                    throw new HalconException(("Unknown generic parameter: '" + (hv_GenParamName.TupleSelect(
                        hv_GenParamIndex))) + "'");
                }
            }
            //
            if ((int)((new HTuple((new HTuple(hv_DisplayMatrix.TupleEqual("relative"))).TupleOr(
                new HTuple(hv_ReturnMatrix.TupleEqual("relative"))))).TupleOr(new HTuple(hv_DisplayColor.TupleEqual(
                "true")))) != 0)
            {
                hv_CalculateRelativeMatrix.Dispose();
                hv_CalculateRelativeMatrix = 1;
            }
            else
            {
                hv_CalculateRelativeMatrix.Dispose();
                hv_CalculateRelativeMatrix = 0;
            }
            //
            //Calculate the confusion matrix with absolute values
            //and the confusion matrix with relative errors.
            //We start with an empty matrix
            //and add the number of matching labels.
            hv_Classes.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_Classes = ((hv_GroundTruthLabels.TupleSort()
                    )).TupleUniq();
            }
            hv_NumClasses.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_NumClasses = new HTuple(hv_Classes.TupleLength()
                    );
            }
            hv_AbsoluteMatrixID.Dispose();
            HOperatorSet.CreateMatrix(hv_NumClasses, hv_NumClasses, 0, out hv_AbsoluteMatrixID);
            if ((int)(hv_CalculateRelativeMatrix) != 0)
            {
                hv_RelativeMatrixID.Dispose();
                HOperatorSet.CreateMatrix(hv_NumClasses, hv_NumClasses, 0, out hv_RelativeMatrixID);
            }
            HTuple end_val55 = hv_NumClasses - 1;
            HTuple step_val55 = 1;
            for (hv_ColumnMatrix = 0; hv_ColumnMatrix.Continue(end_val55, step_val55); hv_ColumnMatrix = hv_ColumnMatrix.TupleAdd(step_val55))
            {
                hv_Class.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Class = hv_Classes.TupleSelect(
                        hv_ColumnMatrix);
                }
                hv_ThisLabel.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ThisLabel = hv_GroundTruthLabels.TupleEqualElem(
                        hv_Class);
                }
                if ((int)(hv_CalculateRelativeMatrix) != 0)
                {
                    //Obtain the number of ground truth labels per class.
                    hv_NumClassGroundTruth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumClassGroundTruth = hv_ThisLabel.TupleSum()
                            ;
                    }
                }
                HTuple end_val62 = hv_NumClasses - 1;
                HTuple step_val62 = 1;
                for (hv_RowMatrix = 0; hv_RowMatrix.Continue(end_val62, step_val62); hv_RowMatrix = hv_RowMatrix.TupleAdd(step_val62))
                {
                    //Select classes for this row/column.
                    hv_PredictedClass.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_PredictedClass = hv_Classes.TupleSelect(
                            hv_RowMatrix);
                    }
                    //Check whether the input data
                    //corresponds to these classes.
                    hv_ThisPredictedClass.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ThisPredictedClass = hv_PredictedClasses.TupleEqualElem(
                            hv_PredictedClass);
                    }
                    //Count the number of elements where the predicted class
                    //matches the ground truth label.
                    hv_NumMatches.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumMatches = ((((hv_ThisLabel + hv_ThisPredictedClass)).TupleEqualElem(
                            2))).TupleSum();
                    }
                    //Set value in matrix.
                    HOperatorSet.SetValueMatrix(hv_AbsoluteMatrixID, hv_RowMatrix, hv_ColumnMatrix,
                        hv_NumMatches);
                    if ((int)(hv_CalculateRelativeMatrix) != 0)
                    {
                        if ((int)(new HTuple(hv_NumClassGroundTruth.TupleGreater(0))) != 0)
                        {
                            hv_RelativeError.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_RelativeError = (hv_NumMatches.TupleReal()
                                    ) / hv_NumClassGroundTruth;
                            }
                        }
                        else
                        {
                            hv_RelativeError.Dispose();
                            hv_RelativeError = 0;
                        }
                        HOperatorSet.SetValueMatrix(hv_RelativeMatrixID, hv_RowMatrix, hv_ColumnMatrix,
                            hv_RelativeError);
                    }
                }
            }
            //
            //Return the result.
            if ((int)(new HTuple(hv_ReturnMatrix.TupleEqual("absolute"))) != 0)
            {
                hv_ConfusionMatrix.Dispose();
                HOperatorSet.CopyMatrix(hv_AbsoluteMatrixID, out hv_ConfusionMatrix);
            }
            else if ((int)(new HTuple(hv_ReturnMatrix.TupleEqual("relative"))) != 0)
            {
                hv_ConfusionMatrix.Dispose();
                HOperatorSet.CopyMatrix(hv_RelativeMatrixID, out hv_ConfusionMatrix);
            }
            else if ((int)(new HTuple(hv_ReturnMatrix.TupleEqual("none"))) != 0)
            {
                //No matrix is returned.
            }
            else
            {
                throw new HalconException("Unsupported mode for 'return_matrix'");
            }
            //
            //Display the matrix.
            if ((int)(new HTuple(hv_DisplayMatrix.TupleNotEqual("none"))) != 0)
            {
                //
                //Find maximal string width and set display position parameters.
                hv_StringWidths.Dispose();
                hv_StringWidths = new HTuple();
                //Get the string width of each class.
                for (hv_StringIndex = 0; (int)hv_StringIndex <= (int)((new HTuple(hv_Classes.TupleLength()
                    )) - 1); hv_StringIndex = (int)hv_StringIndex + 1)
                {
                    hv_String.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_String = hv_Classes.TupleSelect(
                            hv_StringIndex);
                    }
                    hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_StringWidth.Dispose(); hv_StringHeight.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String, out hv_Ascent,
                        out hv_Descent, out hv_StringWidth, out hv_StringHeight);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StringWidths = hv_StringWidths.TupleConcat(
                                hv_StringWidth);
                            hv_StringWidths.Dispose();
                            hv_StringWidths = ExpTmpLocalVar_StringWidths;
                        }
                    }
                }
                //The columns should have a minimum width for 4 characters.
                hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_StringWidth.Dispose(); hv_StringHeight.Dispose();
                HOperatorSet.GetStringExtents(hv_WindowHandle, "test", out hv_Ascent, out hv_Descent,
                    out hv_StringWidth, out hv_StringHeight);
                hv_MaxStringWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MaxStringWidth = ((hv_StringWidths.TupleMax()
                        )).TupleMax2(hv_StringWidth);
                }
                //Get the maximum string width
                //and resize the window accordingly.
                hv_RowStart.Dispose();
                hv_RowStart = 80;
                hv_RowDistance.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowDistance = hv_StringHeight + 10;
                }
                hv_RowEnd.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowEnd = hv_StringHeight * 7;
                }
                hv_ColumnStart.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ColumnStart = 50 + hv_MaxStringWidth;
                }
                hv_ColumnOffset.Dispose();
                hv_ColumnOffset = 20;
                hv_ColumnEnd.Dispose();
                hv_ColumnEnd = new HTuple(hv_ColumnOffset);
                //
                //Adapt the window size to fit the confusion matrix.
                if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("minimal"))) != 0)
                {
                    //Every column of the confusion matrix is as narrow as possible
                    //based to the respective string widths.
                    hv_Width.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Width = (((hv_StringWidths.TupleSum()
                            ) + (hv_ColumnOffset * hv_NumClasses)) + hv_ColumnStart) + hv_ColumnEnd;
                    }
                }
                else if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("equal"))) != 0)
                {
                    //Every column of the confusion matrix should have the same width.
                    //based on the maximum string width.
                    hv_Width.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Width = (((hv_MaxStringWidth + hv_ColumnOffset) * hv_NumClasses) + hv_ColumnStart) + hv_ColumnEnd;
                    }
                }
                else
                {
                    throw new HalconException("");
                }
                hv_Height.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Height = ((hv_RowDistance * hv_NumClasses) + hv_RowStart) + hv_RowEnd;
                }
                HDevWindowStack.SetActive(hv_WindowHandle);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                }
                //
                //Set reasonable limits for graphics window (adapt if necessary).
                hv_WidthLimit.Dispose();
                hv_WidthLimit = new HTuple();
                hv_WidthLimit[0] = 450;
                hv_WidthLimit[1] = 1920;
                hv_HeightLimit.Dispose();
                hv_HeightLimit = new HTuple();
                hv_HeightLimit[0] = 250;
                hv_HeightLimit[1] = 1080;
                if ((int)((new HTuple(hv_Width.TupleGreater(hv_WidthLimit.TupleSelect(1)))).TupleOr(
                    new HTuple(hv_Height.TupleGreater(hv_HeightLimit.TupleSelect(1))))) != 0)
                {
                    throw new HalconException("Confusion Matrix does not fit into graphics window. Please adapt font and/or size limits.");
                }
                dev_resize_window_fit_size(0, 0, hv_Width, hv_Height, hv_WidthLimit, hv_HeightLimit);
                //
                //Get display coordinates.
                //Get row coordinates for display.
                hv_TextRow.Dispose();
                hv_TextRow = new HTuple();
                HTuple end_val145 = hv_NumClasses - 1;
                HTuple step_val145 = 1;
                for (hv_ColumnMatrix = 0; hv_ColumnMatrix.Continue(end_val145, step_val145); hv_ColumnMatrix = hv_ColumnMatrix.TupleAdd(step_val145))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TextRow = hv_TextRow.TupleConcat(
                                HTuple.TupleGenSequence(0, (hv_NumClasses - 1) * hv_RowDistance, hv_RowDistance));
                            hv_TextRow.Dispose();
                            hv_TextRow = ExpTmpLocalVar_TextRow;
                        }
                    }
                }
                //Get column coordinates for display.
                hv_TextColumn.Dispose();
                hv_TextColumn = new HTuple();
                HTuple end_val150 = hv_NumClasses - 1;
                HTuple step_val150 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val150, step_val150); hv_Index = hv_Index.TupleAdd(step_val150))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TextColumn = hv_TextColumn.TupleConcat(
                                HTuple.TupleGenConst(hv_NumClasses, hv_ColumnStart));
                            hv_TextColumn.Dispose();
                            hv_TextColumn = ExpTmpLocalVar_TextColumn;
                        }
                    }
                    if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("minimal"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ColumnStart = (hv_ColumnStart + (hv_StringWidths.TupleSelect(
                                    hv_Index))) + hv_ColumnOffset;
                                hv_ColumnStart.Dispose();
                                hv_ColumnStart = ExpTmpLocalVar_ColumnStart;
                            }
                        }
                    }
                    else if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual(
                        "equal"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ColumnStart = (hv_ColumnStart + hv_MaxStringWidth) + hv_ColumnOffset;
                                hv_ColumnStart.Dispose();
                                hv_ColumnStart = ExpTmpLocalVar_ColumnStart;
                            }
                        }
                    }
                }
                //Display the confusion matrix with a margin from the top.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_TextRow = hv_TextRow + hv_RowStart;
                        hv_TextRow.Dispose();
                        hv_TextRow = ExpTmpLocalVar_TextRow;
                    }
                }
                //Display axis titles.
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Ground truth labels",
                        "window", "top", "right", "white", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Predicted classes",
                        "window", "bottom", "left", "white", "box", "false");
                }
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Classes.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_Text.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Text = hv_Classes.TupleSelect(
                            hv_Index);
                    }
                    //Display predicted class names.
                    hv_Row.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Row = hv_TextRow.TupleSelect(
                            hv_Index);
                    }
                    hv_Column.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Column = ((hv_TextColumn.TupleSelect(
                            0)) - hv_MaxStringWidth) - hv_ColumnOffset;
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                            hv_Row, hv_Column, "light gray", "box", "false");
                    }
                    //Display ground truth label names.
                    hv_Row.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Row = (hv_TextRow.TupleSelect(
                            0)) - hv_RowDistance;
                    }
                    hv_Column.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Column = hv_TextColumn.TupleSelect(
                            hv_Index * hv_NumClasses);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                            hv_Row, hv_Column, "light gray", "box", "false");
                    }
                }
                //
                //Get the confusion matrix values for display.
                if ((int)(new HTuple(hv_DisplayMatrix.TupleEqual("absolute"))) != 0)
                {
                    //Displayed matrix corresponds to the transposed returned matrix.
                    hv_AbsoluteTransposedMatrixID.Dispose();
                    HOperatorSet.TransposeMatrix(hv_AbsoluteMatrixID, out hv_AbsoluteTransposedMatrixID);
                    hv_MatrixText.Dispose();
                    HOperatorSet.GetFullMatrix(hv_AbsoluteTransposedMatrixID, out hv_MatrixText);
                    HOperatorSet.ClearMatrix(hv_AbsoluteTransposedMatrixID);
                    //Align the numbers right.
                    hv_MatrixMaxID.Dispose();
                    HOperatorSet.MaxMatrix(hv_AbsoluteMatrixID, "full", out hv_MatrixMaxID);
                    hv_MaxValue.Dispose();
                    HOperatorSet.GetFullMatrix(hv_MatrixMaxID, out hv_MaxValue);
                    HOperatorSet.ClearMatrix(hv_MatrixMaxID);
                    hv_StringConversion.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_StringConversion = (((((hv_MaxValue.TupleLog10()
                            )).TupleCeil())).TupleInt()) + ".0f";
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_MatrixText = hv_MatrixText.TupleString(
                                hv_StringConversion);
                            hv_MatrixText.Dispose();
                            hv_MatrixText = ExpTmpLocalVar_MatrixText;
                        }
                    }
                }
                else
                {
                    //Displayed matrix corresponds to the transposed returned matrix.
                    hv_RelativeTransposedMatrixID.Dispose();
                    HOperatorSet.TransposeMatrix(hv_RelativeMatrixID, out hv_RelativeTransposedMatrixID);
                    hv_MatrixText.Dispose();
                    HOperatorSet.GetFullMatrix(hv_RelativeTransposedMatrixID, out hv_MatrixText);
                    HOperatorSet.ClearMatrix(hv_RelativeTransposedMatrixID);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_MatrixText = hv_MatrixText.TupleString(
                                ".2f");
                            hv_MatrixText.Dispose();
                            hv_MatrixText = ExpTmpLocalVar_MatrixText;
                        }
                    }
                }
                //Set color for displayed confusion matrix.
                if ((int)(new HTuple(hv_DisplayColor.TupleEqual("true"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TextColor.Dispose();
                        HOperatorSet.TupleGenConst(new HTuple(hv_MatrixText.TupleLength()), "#666666",
                            out hv_TextColor);
                    }
                    //Use the relative values to adapt the color of the text.
                    hv_RelativeTransposedMatrixID.Dispose();
                    HOperatorSet.TransposeMatrix(hv_RelativeMatrixID, out hv_RelativeTransposedMatrixID);
                    hv_RelativeValues.Dispose();
                    HOperatorSet.GetFullMatrix(hv_RelativeTransposedMatrixID, out hv_RelativeValues);
                    HOperatorSet.ClearMatrix(hv_RelativeTransposedMatrixID);
                    //Set the colors and respective thresholds for the off-diagonal values.
                    hv_Thresholds.Dispose();
                    hv_Thresholds = new HTuple();
                    hv_Thresholds[0] = 0.0;
                    hv_Thresholds[1] = 0.05;
                    hv_Thresholds[2] = 0.1;
                    hv_Thresholds[3] = 0.2;
                    hv_Colors.Dispose();
                    hv_Colors = new HTuple();
                    hv_Colors[0] = "#8C4D4D";
                    hv_Colors[1] = "#B33333";
                    hv_Colors[2] = "#D91A1A";
                    hv_Colors[3] = "#FF0000";
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Thresholds.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Greater.Dispose();
                            HOperatorSet.TupleGreaterElem(hv_RelativeValues, hv_Thresholds.TupleSelect(
                                hv_Index), out hv_Greater);
                        }
                        hv_Indices.Dispose();
                        HOperatorSet.TupleFind(hv_Greater, 1, out hv_Indices);
                        if ((int)(new HTuple(hv_Indices.TupleNotEqual(-1))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HTuple ExpTmpOutVar_0;
                                HOperatorSet.TupleReplace(hv_TextColor, hv_Indices, hv_Colors.TupleSelect(
                                    hv_Index), out ExpTmpOutVar_0);
                                hv_TextColor.Dispose();
                                hv_TextColor = ExpTmpOutVar_0;
                            }
                        }
                        else
                        {
                            break;
                        }
                    }
                    //Set the colors and respective thresholds for the diagonal values.
                    hv_Thresholds.Dispose();
                    hv_Thresholds = new HTuple();
                    hv_Thresholds[0] = -0.01;
                    hv_Thresholds[1] = 0.60;
                    hv_Thresholds[2] = 0.80;
                    hv_Thresholds[3] = 0.90;
                    hv_Thresholds[4] = 0.95;
                    hv_Thresholds[5] = 0.98;
                    hv_Colors.Dispose();
                    hv_Colors = new HTuple();
                    hv_Colors[0] = "#666666";
                    hv_Colors[1] = "#508650";
                    hv_Colors[2] = "#419C41";
                    hv_Colors[3] = "#2BBD2B";
                    hv_Colors[4] = "#15DE15";
                    hv_Colors[5] = "#00FF00";
                    HTuple end_val216 = hv_NumClasses - 1;
                    HTuple step_val216 = 1;
                    for (hv_DiagonalIndex = 0; hv_DiagonalIndex.Continue(end_val216, step_val216); hv_DiagonalIndex = hv_DiagonalIndex.TupleAdd(step_val216))
                    {
                        hv_Value.Dispose();
                        HOperatorSet.GetValueMatrix(hv_RelativeMatrixID, hv_DiagonalIndex, hv_DiagonalIndex,
                            out hv_Value);
                        for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Thresholds.TupleLength()
                            )) - 1); hv_Index = (int)hv_Index + 1)
                        {
                            if ((int)(new HTuple(hv_Value.TupleGreater(hv_Thresholds.TupleSelect(
                                hv_Index)))) != 0)
                            {
                                if (hv_TextColor == null)
                                    hv_TextColor = new HTuple();
                                hv_TextColor[hv_DiagonalIndex * (hv_NumClasses + 1)] = hv_Colors.TupleSelect(
                                    hv_Index);
                            }
                            else
                            {
                                break;
                            }
                        }
                    }
                }
                else
                {
                    //Default value for the text color.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TextColor.Dispose();
                        HOperatorSet.TupleGenConst(new HTuple(hv_MatrixText.TupleLength()), "white",
                            out hv_TextColor);
                    }
                }
                //
                //Display confusion matrix.
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_MatrixText, "window",
                        hv_TextRow, hv_TextColumn, hv_TextColor, "box", "false");
                }
                //
                //Clean up.
                if ((int)(hv_CalculateRelativeMatrix) != 0)
                {
                    HOperatorSet.ClearMatrix(hv_RelativeMatrixID);
                }
                HOperatorSet.ClearMatrix(hv_AbsoluteMatrixID);
            }

            hv_DisplayMatrix.Dispose();
            hv_ReturnMatrix.Dispose();
            hv_DisplayColor.Dispose();
            hv_DisplayColumnWidth.Dispose();
            hv_GenParamIndex.Dispose();
            hv_CalculateRelativeMatrix.Dispose();
            hv_Classes.Dispose();
            hv_NumClasses.Dispose();
            hv_AbsoluteMatrixID.Dispose();
            hv_RelativeMatrixID.Dispose();
            hv_ColumnMatrix.Dispose();
            hv_Class.Dispose();
            hv_ThisLabel.Dispose();
            hv_NumClassGroundTruth.Dispose();
            hv_RowMatrix.Dispose();
            hv_PredictedClass.Dispose();
            hv_ThisPredictedClass.Dispose();
            hv_NumMatches.Dispose();
            hv_RelativeError.Dispose();
            hv_StringWidths.Dispose();
            hv_StringIndex.Dispose();
            hv_String.Dispose();
            hv_Ascent.Dispose();
            hv_Descent.Dispose();
            hv_StringWidth.Dispose();
            hv_StringHeight.Dispose();
            hv_MaxStringWidth.Dispose();
            hv_RowStart.Dispose();
            hv_RowDistance.Dispose();
            hv_RowEnd.Dispose();
            hv_ColumnStart.Dispose();
            hv_ColumnOffset.Dispose();
            hv_ColumnEnd.Dispose();
            hv_Width.Dispose();
            hv_Height.Dispose();
            hv_WidthLimit.Dispose();
            hv_HeightLimit.Dispose();
            hv_TextRow.Dispose();
            hv_TextColumn.Dispose();
            hv_Index.Dispose();
            hv_Text.Dispose();
            hv_Row.Dispose();
            hv_Column.Dispose();
            hv_AbsoluteTransposedMatrixID.Dispose();
            hv_MatrixText.Dispose();
            hv_MatrixMaxID.Dispose();
            hv_MaxValue.Dispose();
            hv_StringConversion.Dispose();
            hv_RelativeTransposedMatrixID.Dispose();
            hv_TextColor.Dispose();
            hv_RelativeValues.Dispose();
            hv_Thresholds.Dispose();
            hv_Colors.Dispose();
            hv_Greater.Dispose();
            hv_Indices.Dispose();
            hv_DiagonalIndex.Dispose();
            hv_Value.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_DisplayMatrix.Dispose();
            hv_ReturnMatrix.Dispose();
            hv_DisplayColor.Dispose();
            hv_DisplayColumnWidth.Dispose();
            hv_GenParamIndex.Dispose();
            hv_CalculateRelativeMatrix.Dispose();
            hv_Classes.Dispose();
            hv_NumClasses.Dispose();
            hv_AbsoluteMatrixID.Dispose();
            hv_RelativeMatrixID.Dispose();
            hv_ColumnMatrix.Dispose();
            hv_Class.Dispose();
            hv_ThisLabel.Dispose();
            hv_NumClassGroundTruth.Dispose();
            hv_RowMatrix.Dispose();
            hv_PredictedClass.Dispose();
            hv_ThisPredictedClass.Dispose();
            hv_NumMatches.Dispose();
            hv_RelativeError.Dispose();
            hv_StringWidths.Dispose();
            hv_StringIndex.Dispose();
            hv_String.Dispose();
            hv_Ascent.Dispose();
            hv_Descent.Dispose();
            hv_StringWidth.Dispose();
            hv_StringHeight.Dispose();
            hv_MaxStringWidth.Dispose();
            hv_RowStart.Dispose();
            hv_RowDistance.Dispose();
            hv_RowEnd.Dispose();
            hv_ColumnStart.Dispose();
            hv_ColumnOffset.Dispose();
            hv_ColumnEnd.Dispose();
            hv_Width.Dispose();
            hv_Height.Dispose();
            hv_WidthLimit.Dispose();
            hv_HeightLimit.Dispose();
            hv_TextRow.Dispose();
            hv_TextColumn.Dispose();
            hv_Index.Dispose();
            hv_Text.Dispose();
            hv_Row.Dispose();
            hv_Column.Dispose();
            hv_AbsoluteTransposedMatrixID.Dispose();
            hv_MatrixText.Dispose();
            hv_MatrixMaxID.Dispose();
            hv_MaxValue.Dispose();
            hv_StringConversion.Dispose();
            hv_RelativeTransposedMatrixID.Dispose();
            hv_TextColor.Dispose();
            hv_RelativeValues.Dispose();
            hv_Thresholds.Dispose();
            hv_Colors.Dispose();
            hv_Greater.Dispose();
            hv_Indices.Dispose();
            hv_DiagonalIndex.Dispose();
            hv_Value.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: 3D Matching / 3D Gripping Point Detection
    // Short Description: Generate gripping points for connected regions of high gripping confidence. 
    private void gen_dl_3d_gripping_point_image_coord(HObject ho_GrippingMap, out HObject ho_Regions,
        HTuple hv_MinAreaSize, out HTuple hv_Rows, out HTuple hv_Columns)
    {




        // Stack for temporary objects 
        HObject[] OTemp = new HObject[20];

        // Local iconic variables 

        HObject ho_TmpRegions, ho_FilteredRegions;
        HObject ho_ConnectedRegions, ho_SelectedRegions, ho_Skeletons;
        HObject ho_OrigRegion = null, ho_Skeleton = null, ho_SkeletonIntersection = null;
        HObject ho_Contours = null, ho_ContourRegions = null, ho_ContourSelected = null;
        HObject ho_RegionSelected = null, ho_CenterRegion = null;

        // Local control variables 

        HTuple hv_GapClosingRadius = new HTuple();
        HTuple hv_NumDilationRuns = new HTuple(), hv_NumRegions = new HTuple();
        HTuple hv_RegionIdx = new HTuple(), hv_Area = new HTuple();
        HTuple hv_Row1 = new HTuple(), hv_Column1 = new HTuple();
        HTuple hv_Radius = new HTuple(), hv_RadiusIndex = new HTuple();
        HTuple hv_Dilation = new HTuple(), hv_Rows1 = new HTuple();
        HTuple hv_Columns1 = new HTuple(), hv_RowOut = new HTuple();
        HTuple hv_Indices = new HTuple(), hv_SelectedColumns = new HTuple();
        HTuple hv_ColumnOut = new HTuple(), hv_NumContours = new HTuple();
        HTuple hv_CandidateRows = new HTuple(), hv_CandidateCols = new HTuple();
        HTuple hv_ContourIdx = new HTuple(), hv_Row = new HTuple();
        HTuple hv_Column = new HTuple(), hv_MinDistance = new HTuple();
        HTuple hv_RowCandidate = new HTuple(), hv_ColumnCandidate = new HTuple();
        HTuple hv_RowUnused = new HTuple(), hv_ColumnUnused = new HTuple();
        HTuple hv_MinDist = new HTuple(), hv_MaxDist = new HTuple();
        HTuple hv_Indices1 = new HTuple();
        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Regions);
        HOperatorSet.GenEmptyObj(out ho_TmpRegions);
        HOperatorSet.GenEmptyObj(out ho_FilteredRegions);
        HOperatorSet.GenEmptyObj(out ho_ConnectedRegions);
        HOperatorSet.GenEmptyObj(out ho_SelectedRegions);
        HOperatorSet.GenEmptyObj(out ho_Skeletons);
        HOperatorSet.GenEmptyObj(out ho_OrigRegion);
        HOperatorSet.GenEmptyObj(out ho_Skeleton);
        HOperatorSet.GenEmptyObj(out ho_SkeletonIntersection);
        HOperatorSet.GenEmptyObj(out ho_Contours);
        HOperatorSet.GenEmptyObj(out ho_ContourRegions);
        HOperatorSet.GenEmptyObj(out ho_ContourSelected);
        HOperatorSet.GenEmptyObj(out ho_RegionSelected);
        HOperatorSet.GenEmptyObj(out ho_CenterRegion);
        hv_Rows = new HTuple();
        hv_Columns = new HTuple();
        try
        {
            //
            //This procedure extracts connected regions from the gripping
            //map and generates a single gripping point near the center
            //of each of those regions.
            //
            hv_GapClosingRadius.Dispose();
            hv_GapClosingRadius = 3.5;
            hv_NumDilationRuns.Dispose();
            hv_NumDilationRuns = 5;
            //
            //Compute regions (connected components).
            ho_TmpRegions.Dispose();
            HOperatorSet.Threshold(ho_GrippingMap, out ho_TmpRegions, 0.5, 1);
            //
            //Close small gaps inside regions to get a nicer skeleton.
            ho_FilteredRegions.Dispose();
            HOperatorSet.ClosingCircle(ho_TmpRegions, out ho_FilteredRegions, hv_GapClosingRadius);
            //
            ho_ConnectedRegions.Dispose();
            HOperatorSet.Connection(ho_FilteredRegions, out ho_ConnectedRegions);
            //
            //Filter for regions smaller than RegionThreshold.
            ho_SelectedRegions.Dispose();
            HOperatorSet.SelectShape(ho_ConnectedRegions, out ho_SelectedRegions, "area",
                "and", hv_MinAreaSize, "max");
            hv_NumRegions.Dispose();
            HOperatorSet.CountObj(ho_SelectedRegions, out hv_NumRegions);
            if ((int)(new HTuple(hv_NumRegions.TupleLess(1))) != 0)
            {
                ho_Regions.Dispose();
                HOperatorSet.GenEmptyObj(out ho_Regions);
                hv_Rows.Dispose();
                hv_Rows = new HTuple();
                hv_Columns.Dispose();
                hv_Columns = new HTuple();
                ho_TmpRegions.Dispose();
                ho_FilteredRegions.Dispose();
                ho_ConnectedRegions.Dispose();
                ho_SelectedRegions.Dispose();
                ho_Skeletons.Dispose();
                ho_OrigRegion.Dispose();
                ho_Skeleton.Dispose();
                ho_SkeletonIntersection.Dispose();
                ho_Contours.Dispose();
                ho_ContourRegions.Dispose();
                ho_ContourSelected.Dispose();
                ho_RegionSelected.Dispose();
                ho_CenterRegion.Dispose();

                hv_GapClosingRadius.Dispose();
                hv_NumDilationRuns.Dispose();
                hv_NumRegions.Dispose();
                hv_RegionIdx.Dispose();
                hv_Area.Dispose();
                hv_Row1.Dispose();
                hv_Column1.Dispose();
                hv_Radius.Dispose();
                hv_RadiusIndex.Dispose();
                hv_Dilation.Dispose();
                hv_Rows1.Dispose();
                hv_Columns1.Dispose();
                hv_RowOut.Dispose();
                hv_Indices.Dispose();
                hv_SelectedColumns.Dispose();
                hv_ColumnOut.Dispose();
                hv_NumContours.Dispose();
                hv_CandidateRows.Dispose();
                hv_CandidateCols.Dispose();
                hv_ContourIdx.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_MinDistance.Dispose();
                hv_RowCandidate.Dispose();
                hv_ColumnCandidate.Dispose();
                hv_RowUnused.Dispose();
                hv_ColumnUnused.Dispose();
                hv_MinDist.Dispose();
                hv_MaxDist.Dispose();
                hv_Indices1.Dispose();

                return;
            }
            //
            //Determine gripping point based on skeleton per region.
            ho_Skeletons.Dispose();
            HOperatorSet.Skeleton(ho_SelectedRegions, out ho_Skeletons);
            hv_Rows.Dispose();
            HOperatorSet.TupleGenConst(hv_NumRegions, 0, out hv_Rows);
            hv_Columns.Dispose();
            HOperatorSet.TupleGenConst(hv_NumRegions, 0, out hv_Columns);
            ho_Regions.Dispose();
            HOperatorSet.GenEmptyObj(out ho_Regions);
            HTuple end_val31 = hv_NumRegions;
            HTuple step_val31 = 1;
            for (hv_RegionIdx = 1; hv_RegionIdx.Continue(end_val31, step_val31); hv_RegionIdx = hv_RegionIdx.TupleAdd(step_val31))
            {
                ho_OrigRegion.Dispose();
                HOperatorSet.SelectObj(ho_SelectedRegions, out ho_OrigRegion, hv_RegionIdx);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.Intersection(ho_OrigRegion, ho_TmpRegions, out ExpTmpOutVar_0
                        );
                    ho_OrigRegion.Dispose();
                    ho_OrigRegion = ExpTmpOutVar_0;
                }
                ho_Skeleton.Dispose();
                HOperatorSet.SelectObj(ho_Skeletons, out ho_Skeleton, hv_RegionIdx);
                //
                //Reduce skeleton and region produced by contours by original
                //region (if skeleton used pixels added by closing circle).
                ho_SkeletonIntersection.Dispose();
                HOperatorSet.Intersection(ho_Skeleton, ho_OrigRegion, out ho_SkeletonIntersection
                    );
                //
                //Check if skeleton lies outside valid region
                hv_Area.Dispose(); hv_Row1.Dispose(); hv_Column1.Dispose();
                HOperatorSet.AreaCenter(ho_SkeletonIntersection, out hv_Area, out hv_Row1,
                    out hv_Column1);
                if ((int)(new HTuple(hv_Area.TupleEqual(0))) != 0)
                {
                    //Skeleton outside valid region -> use simple median row pixel and
                    //fixing this row, the median column pixel. This case should be
                    //extremely rare.
                    hv_Radius.Dispose();
                    HOperatorSet.RegionFeatures(ho_OrigRegion, "outer_radius", out hv_Radius);
                    HTuple end_val47 = hv_NumDilationRuns - 1;
                    HTuple step_val47 = 1;
                    for (hv_RadiusIndex = 0; hv_RadiusIndex.Continue(end_val47, step_val47); hv_RadiusIndex = hv_RadiusIndex.TupleAdd(step_val47))
                    {
                        hv_Dilation.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Dilation = ((hv_Radius / hv_NumDilationRuns)).TupleMax2(
                                1.5);
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.DilationCircle(ho_Skeleton, out ExpTmpOutVar_0, hv_Dilation);
                            ho_Skeleton.Dispose();
                            ho_Skeleton = ExpTmpOutVar_0;
                        }
                        ho_SkeletonIntersection.Dispose();
                        HOperatorSet.Intersection(ho_Skeleton, ho_OrigRegion, out ho_SkeletonIntersection
                            );
                        hv_Area.Dispose(); hv_Row1.Dispose(); hv_Column1.Dispose();
                        HOperatorSet.AreaCenter(ho_SkeletonIntersection, out hv_Area, out hv_Row1,
                            out hv_Column1);
                        if ((int)(new HTuple(hv_Area.TupleGreater(0))) != 0)
                        {
                            break;
                        }
                    }
                    hv_Rows1.Dispose(); hv_Columns1.Dispose();
                    HOperatorSet.GetRegionPoints(ho_SkeletonIntersection, out hv_Rows1, out hv_Columns1);
                    hv_RowOut.Dispose();
                    HOperatorSet.TupleMedian(hv_Rows1, out hv_RowOut);
                    hv_Indices.Dispose();
                    HOperatorSet.TupleFind(hv_Rows1, hv_RowOut, out hv_Indices);
                    hv_SelectedColumns.Dispose();
                    HOperatorSet.TupleSelect(hv_Columns1, hv_Indices, out hv_SelectedColumns);
                    hv_ColumnOut.Dispose();
                    HOperatorSet.TupleMedian(hv_SelectedColumns, out hv_ColumnOut);
                }
                else
                {
                    //Skeleton inside valid region -> use skeleton
                    ho_Contours.Dispose();
                    HOperatorSet.GenContoursSkeletonXld(ho_SkeletonIntersection, out ho_Contours,
                        1, "filter");
                    ho_ContourRegions.Dispose();
                    HOperatorSet.GenRegionContourXld(ho_Contours, out ho_ContourRegions, "margin");
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.Intersection(ho_ContourRegions, ho_SkeletonIntersection, out ExpTmpOutVar_0
                            );
                        ho_ContourRegions.Dispose();
                        ho_ContourRegions = ExpTmpOutVar_0;
                    }
                    //
                    //From every contour select middle point as candidate.
                    hv_NumContours.Dispose();
                    HOperatorSet.CountObj(ho_Contours, out hv_NumContours);
                    hv_CandidateRows.Dispose();
                    HOperatorSet.TupleGenConst(hv_NumContours, 0, out hv_CandidateRows);
                    hv_CandidateCols.Dispose();
                    HOperatorSet.TupleGenConst(hv_NumContours, 0, out hv_CandidateCols);
                    HTuple end_val71 = hv_NumContours;
                    HTuple step_val71 = 1;
                    for (hv_ContourIdx = 1; hv_ContourIdx.Continue(end_val71, step_val71); hv_ContourIdx = hv_ContourIdx.TupleAdd(step_val71))
                    {
                        ho_ContourSelected.Dispose();
                        HOperatorSet.SelectObj(ho_Contours, out ho_ContourSelected, hv_ContourIdx);
                        ho_RegionSelected.Dispose();
                        HOperatorSet.SelectObj(ho_ContourRegions, out ho_RegionSelected, hv_ContourIdx);
                        //
                        //Select point in RegionSelected closest to middle
                        //of the contour.
                        hv_Row.Dispose(); hv_Column.Dispose();
                        HOperatorSet.GetContourXld(ho_ContourSelected, out hv_Row, out hv_Column);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_CenterRegion.Dispose();
                            HOperatorSet.GenRegionRuns(out ho_CenterRegion, hv_Row.TupleSelect((new HTuple(hv_Row.TupleLength()
                                )) / 2), hv_Column.TupleSelect((new HTuple(hv_Column.TupleLength())) / 2),
                                hv_Column.TupleSelect((new HTuple(hv_Column.TupleLength())) / 2));
                        }
                        //
                        //Make sure the selected point is always inside
                        //the region.
                        hv_MinDistance.Dispose(); hv_RowCandidate.Dispose(); hv_ColumnCandidate.Dispose(); hv_RowUnused.Dispose(); hv_ColumnUnused.Dispose();
                        HOperatorSet.DistanceRrMin(ho_RegionSelected, ho_CenterRegion, out hv_MinDistance,
                            out hv_RowCandidate, out hv_ColumnCandidate, out hv_RowUnused, out hv_ColumnUnused);
                        //
                        if (hv_CandidateRows == null)
                            hv_CandidateRows = new HTuple();
                        hv_CandidateRows[hv_ContourIdx - 1] = hv_RowCandidate;
                        if (hv_CandidateCols == null)
                            hv_CandidateCols = new HTuple();
                        hv_CandidateCols[hv_ContourIdx - 1] = hv_ColumnCandidate;
                    }
                    //
                    //Find candidate with minimum maximum distance to any
                    //point in SkeletonIntersection.
                    hv_MinDist.Dispose(); hv_MaxDist.Dispose();
                    HOperatorSet.DistancePr(ho_SkeletonIntersection, hv_CandidateRows, hv_CandidateCols,
                        out hv_MinDist, out hv_MaxDist);
                    hv_Indices1.Dispose();
                    HOperatorSet.TupleSortIndex(hv_MaxDist, out hv_Indices1);
                    hv_RowOut.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_RowOut = hv_CandidateRows.TupleSelect(
                            hv_Indices1.TupleSelect(0));
                    }
                    hv_ColumnOut.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ColumnOut = hv_CandidateCols.TupleSelect(
                            hv_Indices1.TupleSelect(0));
                    }
                }
                //
                //Collect output.
                if (hv_Rows == null)
                    hv_Rows = new HTuple();
                hv_Rows[hv_RegionIdx - 1] = hv_RowOut;
                if (hv_Columns == null)
                    hv_Columns = new HTuple();
                hv_Columns[hv_RegionIdx - 1] = hv_ColumnOut;
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_Regions, ho_OrigRegion, out ExpTmpOutVar_0);
                    ho_Regions.Dispose();
                    ho_Regions = ExpTmpOutVar_0;
                }
            }
            ho_TmpRegions.Dispose();
            ho_FilteredRegions.Dispose();
            ho_ConnectedRegions.Dispose();
            ho_SelectedRegions.Dispose();
            ho_Skeletons.Dispose();
            ho_OrigRegion.Dispose();
            ho_Skeleton.Dispose();
            ho_SkeletonIntersection.Dispose();
            ho_Contours.Dispose();
            ho_ContourRegions.Dispose();
            ho_ContourSelected.Dispose();
            ho_RegionSelected.Dispose();
            ho_CenterRegion.Dispose();

            hv_GapClosingRadius.Dispose();
            hv_NumDilationRuns.Dispose();
            hv_NumRegions.Dispose();
            hv_RegionIdx.Dispose();
            hv_Area.Dispose();
            hv_Row1.Dispose();
            hv_Column1.Dispose();
            hv_Radius.Dispose();
            hv_RadiusIndex.Dispose();
            hv_Dilation.Dispose();
            hv_Rows1.Dispose();
            hv_Columns1.Dispose();
            hv_RowOut.Dispose();
            hv_Indices.Dispose();
            hv_SelectedColumns.Dispose();
            hv_ColumnOut.Dispose();
            hv_NumContours.Dispose();
            hv_CandidateRows.Dispose();
            hv_CandidateCols.Dispose();
            hv_ContourIdx.Dispose();
            hv_Row.Dispose();
            hv_Column.Dispose();
            hv_MinDistance.Dispose();
            hv_RowCandidate.Dispose();
            hv_ColumnCandidate.Dispose();
            hv_RowUnused.Dispose();
            hv_ColumnUnused.Dispose();
            hv_MinDist.Dispose();
            hv_MaxDist.Dispose();
            hv_Indices1.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_TmpRegions.Dispose();
            ho_FilteredRegions.Dispose();
            ho_ConnectedRegions.Dispose();
            ho_SelectedRegions.Dispose();
            ho_Skeletons.Dispose();
            ho_OrigRegion.Dispose();
            ho_Skeleton.Dispose();
            ho_SkeletonIntersection.Dispose();
            ho_Contours.Dispose();
            ho_ContourRegions.Dispose();
            ho_ContourSelected.Dispose();
            ho_RegionSelected.Dispose();
            ho_CenterRegion.Dispose();

            hv_GapClosingRadius.Dispose();
            hv_NumDilationRuns.Dispose();
            hv_NumRegions.Dispose();
            hv_RegionIdx.Dispose();
            hv_Area.Dispose();
            hv_Row1.Dispose();
            hv_Column1.Dispose();
            hv_Radius.Dispose();
            hv_RadiusIndex.Dispose();
            hv_Dilation.Dispose();
            hv_Rows1.Dispose();
            hv_Columns1.Dispose();
            hv_RowOut.Dispose();
            hv_Indices.Dispose();
            hv_SelectedColumns.Dispose();
            hv_ColumnOut.Dispose();
            hv_NumContours.Dispose();
            hv_CandidateRows.Dispose();
            hv_CandidateCols.Dispose();
            hv_ContourIdx.Dispose();
            hv_Row.Dispose();
            hv_Column.Dispose();
            hv_MinDistance.Dispose();
            hv_RowCandidate.Dispose();
            hv_ColumnCandidate.Dispose();
            hv_RowUnused.Dispose();
            hv_ColumnUnused.Dispose();
            hv_MinDist.Dispose();
            hv_MaxDist.Dispose();
            hv_Indices1.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: 3D Matching / 3D Gripping Point Detection
    // Short Description: Extract gripping points based on a 3D gripping point detection model output. 
    public void gen_dl_3d_gripping_points_and_poses(HTuple hv_DLSampleBatch, HTuple hv_DLGrippingPointParams,
        HTuple hv_DLResultBatch)
    {



        // Local iconic variables 

        HObject ho_Regions = null, ho___Tmp_Obj_0 = null;

        // Local control variables 

        HTuple hv_MinAreaSize = new HTuple(), hv_SortingDirection = new HTuple();
        HTuple hv_SampleIndex = new HTuple(), hv_DLSample = new HTuple();
        HTuple hv_DLResult = new HTuple(), hv_Rows = new HTuple();
        HTuple hv_Columns = new HTuple(), hv_HasXYZ = new HTuple();
        HTuple hv_X = new HTuple(), hv_Y = new HTuple(), hv_Z = new HTuple();
        HTuple hv_NormalsXYZ = new HTuple(), hv_NX = new HTuple();
        HTuple hv_NY = new HTuple(), hv_NZ = new HTuple(), hv_DLResultUnsorted = new HTuple();
        HTuple hv_Index = new HTuple(), hv_GrippingPoint = new HTuple();
        HTuple hv_Depths = new HTuple(), hv_AscendingIndices = new HTuple();
        HTuple hv___Tmp_Ctrl_0 = new HTuple();
        HTuple hv_DLGrippingPointParams_COPY_INP_TMP = new HTuple(hv_DLGrippingPointParams);

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Regions);
        HOperatorSet.GenEmptyObj(out ho___Tmp_Obj_0);
        try
        {
            //Extracts gripping points from connected regions in the
            //'gripping_map' image of the items in DLResultBatch.
            //Stores gripping points in a dict containing
            //row, column, region and pose.
            //
            if ((int)(new HTuple((new HTuple(hv_DLGrippingPointParams_COPY_INP_TMP.TupleLength()
                )).TupleEqual(0))) != 0)
            {
                hv_DLGrippingPointParams_COPY_INP_TMP.Dispose();
                HOperatorSet.CreateDict(out hv_DLGrippingPointParams_COPY_INP_TMP);
            }
            //
            check_dl_3d_gripping_points_and_poses_params(hv_DLGrippingPointParams_COPY_INP_TMP);
            //
            hv_MinAreaSize.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_MinAreaSize = hv_DLGrippingPointParams_COPY_INP_TMP.TupleGetDictTuple(
                    "min_area_size");
            }
            hv_SortingDirection.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_SortingDirection = hv_DLGrippingPointParams_COPY_INP_TMP.TupleGetDictTuple(
                    "sorting_direction");
            }
            //
            //Preprocess the sample entries.
            for (hv_SampleIndex = 0; (int)hv_SampleIndex <= (int)((new HTuple(hv_DLSampleBatch.TupleLength()
                )) - 1); hv_SampleIndex = (int)hv_SampleIndex + 1)
            {
                hv_DLSample.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DLSample = hv_DLSampleBatch.TupleSelect(
                        hv_SampleIndex);
                }
                hv_DLResult.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DLResult = hv_DLResultBatch.TupleSelect(
                        hv_SampleIndex);
                }
                //
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_Regions.Dispose(); hv_Rows.Dispose(); hv_Columns.Dispose();
                    gen_dl_3d_gripping_point_image_coord(hv_DLResult.TupleGetDictObject("gripping_map"),
                        out ho_Regions, hv_MinAreaSize, out hv_Rows, out hv_Columns);
                }
                if ((int)(new HTuple((new HTuple(hv_Rows.TupleLength())).TupleLess(1))) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_DLResult, "gripping_points", new HTuple());
                    continue;
                }
                //
                //Convert to output.
                hv_HasXYZ.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", ((new HTuple("x")).TupleConcat(
                    "y")).TupleConcat("z"), out hv_HasXYZ);
                {
                    HTuple ExpTmpOutVar_0;
                    HOperatorSet.TupleMin(hv_HasXYZ, out ExpTmpOutVar_0);
                    hv_HasXYZ.Dispose();
                    hv_HasXYZ = ExpTmpOutVar_0;
                }
                if ((int)(hv_HasXYZ) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_X.Dispose();
                        HOperatorSet.GetGrayval(hv_DLSample.TupleGetDictObject("x"), hv_Rows, hv_Columns,
                            out hv_X);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Y.Dispose();
                        HOperatorSet.GetGrayval(hv_DLSample.TupleGetDictObject("y"), hv_Rows, hv_Columns,
                            out hv_Y);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Z.Dispose();
                        HOperatorSet.GetGrayval(hv_DLSample.TupleGetDictObject("z"), hv_Rows, hv_Columns,
                            out hv_Z);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NormalsXYZ.Dispose();
                        HOperatorSet.GetGrayval(hv_DLSample.TupleGetDictObject("normals"), hv_Rows,
                            hv_Columns, out hv_NormalsXYZ);
                    }
                    hv_NX.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NX = hv_NormalsXYZ.TupleSelect(
                            HTuple.TupleGenSequence(0, (new HTuple(hv_NormalsXYZ.TupleLength())) - 1,
                            3));
                    }
                    hv_NY.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NY = hv_NormalsXYZ.TupleSelect(
                            HTuple.TupleGenSequence(1, (new HTuple(hv_NormalsXYZ.TupleLength())) - 1,
                            3));
                    }
                    hv_NZ.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NZ = hv_NormalsXYZ.TupleSelect(
                            HTuple.TupleGenSequence(2, (new HTuple(hv_NormalsXYZ.TupleLength())) - 1,
                            3));
                    }
                }
                //
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DLResultUnsorted.Dispose();
                    HOperatorSet.TupleGenConst(new HTuple(hv_Rows.TupleLength()), HTuple.TupleConstant(
                        "HNULL"), out hv_DLResultUnsorted);
                }
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Rows.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_GrippingPoint.Dispose();
                    HOperatorSet.CreateDict(out hv_GrippingPoint);
                    if (hv_DLResultUnsorted == null)
                        hv_DLResultUnsorted = new HTuple();
                    hv_DLResultUnsorted[hv_Index] = hv_GrippingPoint;
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_GrippingPoint, "row", hv_Rows.TupleSelect(
                            hv_Index));
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_GrippingPoint, "column", hv_Columns.TupleSelect(
                            hv_Index));
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho___Tmp_Obj_0.Dispose();
                        HOperatorSet.SelectObj(ho_Regions, out ho___Tmp_Obj_0, hv_Index + 1);
                    }
                    HOperatorSet.SetDictObject(ho___Tmp_Obj_0, hv_GrippingPoint, "region");
                    if ((int)(hv_HasXYZ) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv___Tmp_Ctrl_0.Dispose();
                            convert_dl_3d_gripping_point_to_pose(hv_X.TupleSelect(hv_Index), hv_Y.TupleSelect(
                                hv_Index), hv_Z.TupleSelect(hv_Index), hv_NX.TupleSelect(hv_Index),
                                hv_NY.TupleSelect(hv_Index), hv_NZ.TupleSelect(hv_Index), out hv___Tmp_Ctrl_0);
                        }
                        HOperatorSet.SetDictTuple(hv_GrippingPoint, "pose", hv___Tmp_Ctrl_0);
                    }
                    if (hv_DLResultUnsorted == null)
                        hv_DLResultUnsorted = new HTuple();
                    hv_DLResultUnsorted[hv_Index] = hv_GrippingPoint;
                }
                //
                //Sort by ascending depth (closer objects first).
                if ((int)(hv_HasXYZ) != 0)
                {
                    hv_Depths.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Depths = ((hv_X * (hv_SortingDirection.TupleSelect(
                            0))) + (hv_Y * (hv_SortingDirection.TupleSelect(1)))) + (hv_Z * (hv_SortingDirection.TupleSelect(
                            2)));
                    }
                }
                else
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Depths.Dispose();
                        HOperatorSet.GetGrayval(hv_DLSample.TupleGetDictObject("z"), hv_Rows, hv_Columns,
                            out hv_Depths);
                    }
                }
                hv_AscendingIndices.Dispose();
                HOperatorSet.TupleSortIndex(hv_Depths, out hv_AscendingIndices);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv___Tmp_Ctrl_0.Dispose();
                    HOperatorSet.TupleGenConst(new HTuple(hv_Rows.TupleLength()), HTuple.TupleConstant(
                        "HNULL"), out hv___Tmp_Ctrl_0);
                }
                HOperatorSet.SetDictTuple(hv_DLResult, "gripping_points", hv___Tmp_Ctrl_0);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_DLResult, "gripping_points", hv_DLResultUnsorted.TupleSelect(
                        hv_AscendingIndices));
                }
            }
            ho_Regions.Dispose();
            ho___Tmp_Obj_0.Dispose();

            hv_DLGrippingPointParams_COPY_INP_TMP.Dispose();
            hv_MinAreaSize.Dispose();
            hv_SortingDirection.Dispose();
            hv_SampleIndex.Dispose();
            hv_DLSample.Dispose();
            hv_DLResult.Dispose();
            hv_Rows.Dispose();
            hv_Columns.Dispose();
            hv_HasXYZ.Dispose();
            hv_X.Dispose();
            hv_Y.Dispose();
            hv_Z.Dispose();
            hv_NormalsXYZ.Dispose();
            hv_NX.Dispose();
            hv_NY.Dispose();
            hv_NZ.Dispose();
            hv_DLResultUnsorted.Dispose();
            hv_Index.Dispose();
            hv_GrippingPoint.Dispose();
            hv_Depths.Dispose();
            hv_AscendingIndices.Dispose();
            hv___Tmp_Ctrl_0.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_Regions.Dispose();
            ho___Tmp_Obj_0.Dispose();

            hv_DLGrippingPointParams_COPY_INP_TMP.Dispose();
            hv_MinAreaSize.Dispose();
            hv_SortingDirection.Dispose();
            hv_SampleIndex.Dispose();
            hv_DLSample.Dispose();
            hv_DLResult.Dispose();
            hv_Rows.Dispose();
            hv_Columns.Dispose();
            hv_HasXYZ.Dispose();
            hv_X.Dispose();
            hv_Y.Dispose();
            hv_Z.Dispose();
            hv_NormalsXYZ.Dispose();
            hv_NX.Dispose();
            hv_NY.Dispose();
            hv_NZ.Dispose();
            hv_DLResultUnsorted.Dispose();
            hv_Index.Dispose();
            hv_GrippingPoint.Dispose();
            hv_Depths.Dispose();
            hv_AscendingIndices.Dispose();
            hv___Tmp_Ctrl_0.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Model
    // Short Description: Return all pixel measures from a specified list of measures. 
    private void get_requested_pixel_measures(HTuple hv_Measures, HTuple hv_EvaluationType,
        out HTuple hv_PixelMeasures)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_ValidMeasures = new HTuple(), hv_M = new HTuple();
        // Initialize local and output iconic variables 
        hv_PixelMeasures = new HTuple();
        try
        {
            //
            //This helper procedure returns for a given list of
            //requested measures all pixel measures for the specified
            //evaluation type.
            //
            hv_PixelMeasures.Dispose();
            hv_PixelMeasures = new HTuple();
            hv_ValidMeasures.Dispose();
            get_valid_pixel_measures(hv_EvaluationType, out hv_ValidMeasures);
            //
            for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
            {
                if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual("all"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_PixelMeasures = hv_PixelMeasures.TupleConcat(
                                hv_ValidMeasures);
                            hv_PixelMeasures.Dispose();
                            hv_PixelMeasures = ExpTmpLocalVar_PixelMeasures;
                        }
                    }
                }
                else if ((int)(new HTuple(((hv_ValidMeasures.TupleFind(hv_Measures.TupleSelect(
                    hv_M)))).TupleNotEqual(-1))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_PixelMeasures = hv_PixelMeasures.TupleConcat(
                                hv_Measures.TupleSelect(hv_M));
                            hv_PixelMeasures.Dispose();
                            hv_PixelMeasures = ExpTmpLocalVar_PixelMeasures;
                        }
                    }
                }
            }
            //

            hv_ValidMeasures.Dispose();
            hv_M.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_ValidMeasures.Dispose();
            hv_M.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Model
    // Short Description: Returns the list of available pixel evaluation measures for the specified type. 
    private void get_valid_pixel_measures(HTuple hv_EvaluationType, out HTuple hv_EvaluationMeasures)
    {



        // Local iconic variables 
        // Initialize local and output iconic variables 
        hv_EvaluationMeasures = new HTuple();
        //
        //This helper procedure returns for the given evaluation type
        //all pixel measures available for this type.
        //
        hv_EvaluationMeasures.Dispose();
        hv_EvaluationMeasures = new HTuple();
        if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
        {
            hv_EvaluationMeasures.Dispose();
            hv_EvaluationMeasures = new HTuple();
            hv_EvaluationMeasures[0] = "pixel_accuracy";
            hv_EvaluationMeasures[1] = "mean_accuracy";
            hv_EvaluationMeasures[2] = "mean_iou";
            hv_EvaluationMeasures[3] = "class_iou";
            hv_EvaluationMeasures[4] = "class_pixel_accuracy";
            hv_EvaluationMeasures[5] = "pixel_confusion_matrix";
            hv_EvaluationMeasures[6] = "frequency_weighted_iou";
        }
        else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("3d_gripping_point_detection"))) != 0)
        {
            hv_EvaluationMeasures.Dispose();
            hv_EvaluationMeasures = new HTuple();
            hv_EvaluationMeasures[0] = "mean_precision";
            hv_EvaluationMeasures[1] = "mean_iou";
        }
        //


        return;
    }

    // Chapter: Deep Learning / Model
    // Short Description: Initialize the dictionary RunningMeasures for the evaluation. 
    public void init_running_evaluation_measures(HTuple hv_EvalParams, out HTuple hv_RunningMeasures)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_Valid = new HTuple(), hv_Exception = new HTuple();
        HTuple hv_NumClasses = new HTuple(), hv_EvaluationType = new HTuple();
        HTuple hv_Measures = new HTuple(), hv_ClassIDs = new HTuple();
        HTuple hv_PixelMeasures = new HTuple(), hv_CalcRegionMeasures = new HTuple();
        HTuple hv_CalcGrippingPointMeasures = new HTuple(), hv_Index = new HTuple();
        HTuple hv_ClassDict = new HTuple(), hv_ClassKey = new HTuple();
        HTuple hv_InstanceType = new HTuple(), hv_EvalOrientation = new HTuple();
        HTuple hv_AllocationBlockLength = new HTuple(), hv_IoUThreshs = new HTuple();
        HTuple hv_MaxNumDetections = new HTuple(), hv_AreaRanges = new HTuple();
        HTuple hv_AreaNames = new HTuple(), hv_MinAreas = new HTuple();
        HTuple hv_MaxAreas = new HTuple(), hv_DetailedEvaluation = new HTuple();
        HTuple hv_MaxNumIdx = new HTuple(), hv_MaxNum = new HTuple();
        HTuple hv_CurrentRunningMeasure = new HTuple(), hv_AreaIdx = new HTuple();
        HTuple hv_AreaRunningMeasure = new HTuple(), hv_I = new HTuple();
        HTuple hv_IoURunningMeasure = new HTuple(), hv_ClsIdx = new HTuple();
        HTuple hv_ClassRunningMeasures = new HTuple(), hv_Confidence = new HTuple();
        HTuple hv_IgnoreClassIDs = new HTuple(), hv_CalcConfMatrix = new HTuple();
        HTuple hv_MatrixSize = new HTuple(), hv_PixelConfusionMatrix = new HTuple();
        HTuple hv_MaxId = new HTuple(), hv_ClsIDToClsIdx = new HTuple();
        HTuple hv_TP = new HTuple(), hv_FP = new HTuple(), hv_FN = new HTuple();
        HTuple hv___Tmp_Ctrl_Dict_Init_1 = new HTuple();
        // Initialize local and output iconic variables 
        hv_RunningMeasures = new HTuple();
        try
        {
            //
            //This procedure initializes the dictionary RunningMeasures for evaluation.
            //It uses the evaluation parameters to initialize the running measures accordingly.
            //
            //The structure of RunningMeasures depends on the entry 'evaluate_instances' in the dictionary EvalParams.
            //
            //The dictionary RunningMeasures can be updated based on the per-batch/per-image evaluation results.
            //
            hv_RunningMeasures.Dispose();
            HOperatorSet.CreateDict(out hv_RunningMeasures);
            //Check that the necessary evaluation parameters exist.
            hv_Valid.Dispose(); hv_Exception.Dispose();
            validate_evaluation_param(hv_EvalParams, out hv_Valid, out hv_Exception);
            if ((int)(hv_Valid.TupleNot()) != 0)
            {
                throw new HalconException(new HTuple("Invalid EvalParams, ") + hv_Exception);
            }
            //
            //Get general evaluation parameters.
            hv_NumClasses.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
            hv_EvaluationType.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
            hv_Measures.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
            hv_ClassIDs.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
            //
            if ((int)(new HTuple(hv_EvaluationType.TupleEqual("3d_gripping_point_detection"))) != 0)
            {
                //RunningMeasures contains:
                //if pixel measures:
                //- tp/fp/fn (pixel numbers for the gripping_map class)
                //if region measures:
                //- gt_overlap (accumulated overlap of ground truth regions with the prediction)
                //- num_gt_regions (overall number of ground truth regions)
                //if gripping point measures:
                //- gp_tp/gp_fp/gp_fn (gripping point true positives, false positives, and
                //  false negatives w.r.t. ground truth gripping point region).
                hv_PixelMeasures.Dispose();
                get_requested_pixel_measures(hv_Measures, hv_EvaluationType, out hv_PixelMeasures);
                if ((int)(new HTuple((new HTuple(hv_PixelMeasures.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "tp", 0);
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "fp", 0);
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "fn", 0);
                }
                hv_CalcRegionMeasures.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_CalcRegionMeasures = (new HTuple(((hv_Measures.TupleFind(
                        "mean_pro"))).TupleGreater(-1))).TupleOr(new HTuple(((hv_Measures.TupleFind(
                        "all"))).TupleGreater(-1)));
                }
                if ((int)(hv_CalcRegionMeasures) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "gt_overlap", 0);
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "num_gt_regions", 0);
                }
                hv_CalcGrippingPointMeasures.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_CalcGrippingPointMeasures = new HTuple((new HTuple((new HTuple(hv_Measures.TupleRegexpSelect(
                        "gripping_point_.*|all"))).TupleLength())).TupleGreater(0));
                }
                if ((int)(hv_CalcGrippingPointMeasures) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "gp_tp", 0);
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "gp_fp", 0);
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "gp_fn", 0);
                }
            }
            else if ((int)((new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))).TupleOr(
                new HTuple(hv_EvaluationType.TupleEqual("gc_anomaly_detection")))) != 0)
            {
                //RunningMeasures contains:
                //- image_ids:          IDs of the images.
                //- anomaly_label_ids:  Class IDs of ground truth labels.
                //- anomaly_scores:     Predicted image level anomaly scores.
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", new HTuple());
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "anomaly_label_ids", new HTuple());
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "anomaly_scores", new HTuple());
            }
            else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
            {
                //RunningMeasures contains:
                //- image_ids:          IDs of the images.
                //- image_label_ids:    Class IDs of ground truth labels.
                //- top1_predictions:   Class IDs of the top predicted class.
                //- topk_predictions:   Class IDs of top-K predicted classes.
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", new HTuple());
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_label_ids", new HTuple());
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "top1_predictions", new HTuple());
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "topk_predictions", new HTuple());
            }
            else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("multi_label_classification"))) != 0)
            {
                //RunningMeasures contains:
                //- image_ids:        IDs of the images.
                //- correct_predictions: The number of correctly classified samples
                //- class_{class_id}: A dictionary for each class
                //  -- ground_truth     A tuple with the ground_truth labels
                //  -- confidences      A tuple with the prediction confidence values
                //  -- tp               The number of true positives at min_confidence threshold
                //  -- fp               The number of false positives at min_confidence threshold
                //  -- fn               The number of false negatives at min_confidence threshold
                //  -- f_score          The f_score at min_confidence threshold
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", new HTuple());
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "correct_predictions", 0);
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ClassIDs.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_ClassDict.Dispose();
                    HOperatorSet.CreateDict(out hv_ClassDict);
                    HOperatorSet.SetDictTuple(hv_ClassDict, "ground_truth", new HTuple());
                    HOperatorSet.SetDictTuple(hv_ClassDict, "confidences", new HTuple());
                    //
                    HOperatorSet.SetDictTuple(hv_ClassDict, "tp", 0);
                    HOperatorSet.SetDictTuple(hv_ClassDict, "fp", 0);
                    HOperatorSet.SetDictTuple(hv_ClassDict, "fn", 0);
                    hv_ClassKey.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassKey = "class_" + (hv_ClassIDs.TupleSelect(
                            hv_Index));
                    }
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, hv_ClassKey, hv_ClassDict);
                }
            }
            else if ((int)((new HTuple(hv_EvaluationType.TupleEqual("detection"))).TupleOr(
                new HTuple(hv_EvaluationType.TupleEqual("ocr_detection")))) != 0)
            {
                //RunningMeasures contains:
                //For each maximal number of regions (MaxNumDetections):
                // - For each area range (AreaRanges):
                //   -- confidence:     Confidence (score) of each result.
                //   -- num_gt:         Total number of ground truth instances per class.
                //   -- num_pred:       Total number of predictions per class.
                //   -- num_gt_ignore:  Number of ignored ground truth instances per class.
                //   -- for each IoU-threshold:
                //      --- For each class:
                //          ---- is_tp:                  TP/FP assignment of result.
                //          ---- ignore:                 Ignore/Not-Ignore assignment of result.
                //          ---- abs_orientation_diff (for instance_type 'rectangle2' with measure SoAP):
                //                                       Absolute orientation difference of the result.
                //
                //Check if the orientation difference is to be evaluated.
                hv_InstanceType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "instance_type", out hv_InstanceType);
                hv_EvalOrientation.Dispose();
                hv_EvalOrientation = 0;
                if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd(
                    (new HTuple(((hv_Measures.TupleFind("soap"))).TupleNotEqual(-1))).TupleOr(
                    new HTuple(((hv_Measures.TupleFind("all"))).TupleNotEqual(-1))))) != 0)
                {
                    hv_EvalOrientation.Dispose();
                    hv_EvalOrientation = 1;
                }
                //
                //Calculating the measures confidence, is_tp, ignore, and abs_orientation_diff,
                //arrays are allocated with -1 in blocks of AllocationBlockLength
                //(thus, if a block is filled, the next block is allocated).
                //Otherwise the arrays have to be concatenated which is rather slow.
                //The actual length of the array is garnered in num_pred.
                hv_AllocationBlockLength.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "allocation_block_length", out hv_AllocationBlockLength);
                hv_IoUThreshs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_IoUThreshs);
                hv_MaxNumDetections.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "max_num_detections", out hv_MaxNumDetections);
                hv_AreaRanges.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "area_ranges", out hv_AreaRanges);
                //AreaRanges is a dictionary containing 'name', 'min_area', 'max_area'.
                hv_AreaNames.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaNames);
                hv_MinAreas.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "min", out hv_MinAreas);
                hv_MaxAreas.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "max", out hv_MaxAreas);
                //Check if a detailed evaluation will be performed.
                hv_DetailedEvaluation.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "detailed_evaluation", out hv_DetailedEvaluation);
                //Set a result dictionary for each maximal number of detections and IoU-threshold.
                for (hv_MaxNumIdx = 0; (int)hv_MaxNumIdx <= (int)((new HTuple(hv_MaxNumDetections.TupleLength()
                    )) - 1); hv_MaxNumIdx = (int)hv_MaxNumIdx + 1)
                {
                    hv_MaxNum.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxNum = hv_MaxNumDetections.TupleSelect(
                            hv_MaxNumIdx);
                    }
                    hv_CurrentRunningMeasure.Dispose();
                    HOperatorSet.CreateDict(out hv_CurrentRunningMeasure);
                    for (hv_AreaIdx = 0; (int)hv_AreaIdx <= (int)((new HTuple(hv_AreaNames.TupleLength()
                        )) - 1); hv_AreaIdx = (int)hv_AreaIdx + 1)
                    {
                        hv_AreaRunningMeasure.Dispose();
                        HOperatorSet.CreateDict(out hv_AreaRunningMeasure);
                        for (hv_I = 0; (int)hv_I <= (int)((new HTuple(hv_IoUThreshs.TupleLength()
                            )) - 1); hv_I = (int)hv_I + 1)
                        {
                            hv_IoURunningMeasure.Dispose();
                            HOperatorSet.CreateDict(out hv_IoURunningMeasure);
                            HTuple end_val135 = hv_NumClasses - 1;
                            HTuple step_val135 = 1;
                            for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val135, step_val135); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val135))
                            {
                                hv_ClassRunningMeasures.Dispose();
                                HOperatorSet.CreateDict(out hv_ClassRunningMeasures);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_tp", HTuple.TupleGenConst(
                                        hv_AllocationBlockLength, -1));
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "ignore", HTuple.TupleGenConst(
                                        hv_AllocationBlockLength, -1));
                                }
                                if ((int)(hv_EvalOrientation) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff",
                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                    }
                                }
                                if ((int)(hv_DetailedEvaluation) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_class",
                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_background",
                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_localization",
                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_duplicate",
                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_multiple",
                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                    }
                                    if ((int)(hv_EvalOrientation) != 0)
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff_class",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff_localization",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff_duplicate",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff_multiple",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "image_ids_with_false_negatives",
                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "image_ids_with_false_positives",
                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                    }
                                    HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "num_image_ids_with_false_negatives",
                                        0);
                                    HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "num_image_ids_with_false_positives",
                                        0);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "class_" + (hv_ClassIDs.TupleSelect(
                                        hv_ClsIdx)), hv_ClassRunningMeasures);
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "iou_" + ((("" + (hv_IoUThreshs.TupleSelect(
                                    hv_I)))).TupleRegexpReplace("\\.", "")), hv_IoURunningMeasure);
                            }
                        }
                        hv_Confidence.Dispose();
                        HOperatorSet.CreateDict(out hv_Confidence);
                        HTuple end_val164 = hv_NumClasses - 1;
                        HTuple step_val164 = 1;
                        for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val164, step_val164); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val164))
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_Confidence, "class_" + (hv_ClassIDs.TupleSelect(
                                    hv_ClsIdx)), HTuple.TupleGenConst(hv_AllocationBlockLength, -1.0));
                            }
                        }
                        HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "confidence", hv_Confidence);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "num_gt", HTuple.TupleGenConst(
                                hv_NumClasses, 0));
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "num_pred", HTuple.TupleGenConst(
                                hv_NumClasses, 0));
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "num_gt_ignore", HTuple.TupleGenConst(
                                hv_NumClasses, 0));
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_CurrentRunningMeasure, "area_" + (hv_AreaNames.TupleSelect(
                                hv_AreaIdx)), hv_AreaRunningMeasure);
                        }
                    }
                    if ((int)(new HTuple(hv_MaxNum.TupleEqual(-1))) != 0)
                    {
                        hv_MaxNum.Dispose();
                        hv_MaxNum = "all";
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "max_num_detections_" + hv_MaxNum,
                            hv_CurrentRunningMeasure);
                    }
                }
            }
            else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
            {
                //RunningMeasures contains:
                //if confusion matrix in Measures (slower but more information).
                // - confusion matrix per pixel.
                //else:
                // - TP/FP/FN (pixel numbers per class).
                //
                //Incorporate ignore class IDs.
                hv_IgnoreClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "ignore_class_ids", out hv_IgnoreClassIDs);
                //
                //Check if we need to compute/update the confusion matrix.
                hv_CalcConfMatrix.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_CalcConfMatrix = (new HTuple(((hv_Measures.TupleFind(
                        "pixel_confusion_matrix"))).TupleGreater(-1))).TupleOr(new HTuple(((hv_Measures.TupleFind(
                        "all"))).TupleGreater(-1)));
                }
                if ((int)(hv_CalcConfMatrix) != 0)
                {
                    //Define the size of the confusion matrix.
                    hv_MatrixSize.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MatrixSize = hv_NumClasses + (new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength()
                            )).TupleGreater(0)));
                    }
                    hv_PixelConfusionMatrix.Dispose();
                    HOperatorSet.CreateMatrix(hv_MatrixSize, hv_MatrixSize, 0, out hv_PixelConfusionMatrix);
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix",
                        hv_PixelConfusionMatrix);
                    //
                    //If the class IDs are not running indices from 0 to NumClasses we
                    //define a mapping from class IDs to class indices.
                    if ((int)((new HTuple(hv_ClassIDs.TupleNotEqual(HTuple.TupleGenSequence(
                        0, (new HTuple(hv_ClassIDs.TupleLength())) - 1, 1)))).TupleOr(new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength()
                        )).TupleGreater(0)))) != 0)
                    {
                        //Get the max ID that can occur.
                        hv_MaxId.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MaxId = (hv_ClassIDs.TupleMax()
                                ) + (new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength())).TupleGreater(
                                0)));
                        }
                        //Define the basic mapping.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClsIDToClsIdx.Dispose();
                            HOperatorSet.TupleGenConst(hv_MaxId + 1, -1, out hv_ClsIDToClsIdx);
                        }
                        if (hv_ClsIDToClsIdx == null)
                            hv_ClsIDToClsIdx = new HTuple();
                        hv_ClsIDToClsIdx[hv_ClassIDs] = HTuple.TupleGenSequence(0, (new HTuple(hv_ClassIDs.TupleLength()
                            )) - 1, 1);
                        //Map ignore IDs to the next higher one.
                        if (hv_ClsIDToClsIdx == null)
                            hv_ClsIDToClsIdx = new HTuple();
                        hv_ClsIDToClsIdx[hv_IgnoreClassIDs] = (hv_ClsIDToClsIdx.TupleMax()) + 1;
                        //Set the mapping to the evaluation parameters.
                        HOperatorSet.SetDictTuple(hv_EvalParams, "class_id_mapping", hv_ClsIDToClsIdx);
                    }
                }
                else
                {
                    hv_TP.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TP = HTuple.TupleGenConst(
                            hv_NumClasses, 0);
                    }
                    hv_FP.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FP = HTuple.TupleGenConst(
                            hv_NumClasses, 0);
                    }
                    hv_FN.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FN = HTuple.TupleGenConst(
                            hv_NumClasses, 0);
                    }
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "tp", hv_TP);
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "fp", hv_FP);
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "fn", hv_FN);
                }
            }
            else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("ocr_recognition"))) != 0)
            {
                //RunningMeasures for OCR recognition models.
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", new HTuple());
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "words_ground_truth", new HTuple());
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "words_prediction", new HTuple());
            }
            //
            //Add out-of-distribution detection items if necessary.
            if ((int)(hv_EvalParams.TupleGetDictTuple("calculate_ood_measures")) != 0)
            {
                //RunningMeasures additionally contains:
                //- ood_predictions:    Out-of-distribution detection predictions.
                //- ood_scores:         Out-of-distribution scores.
                //For in-distribution samples, these are stored directly
                //in entries of RunningMeasures.
                //For out-of-distribution samples, they are stored in the
                //sub-dictionary RunningMeasures.evaluated_ood_samples.
                //Additionally, the IDs of the out-of-distribution images
                //are stored in RunningMeasures.evaluated_ood_samples.image_ids.
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "ood_predictions", new HTuple());
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "ood_scores", new HTuple());
                hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_1);
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "evaluated_ood_samples", hv___Tmp_Ctrl_Dict_Init_1);
                hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv___Tmp_Ctrl_Dict_Init_1 = HTuple.TupleConstant(
                        "HNULL");
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_RunningMeasures.TupleGetDictTuple("evaluated_ood_samples"),
                        "image_ids", new HTuple());
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_RunningMeasures.TupleGetDictTuple("evaluated_ood_samples"),
                        "ood_predictions", new HTuple());
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_RunningMeasures.TupleGetDictTuple("evaluated_ood_samples"),
                        "ood_scores", new HTuple());
                }
            }
            //

            hv_Valid.Dispose();
            hv_Exception.Dispose();
            hv_NumClasses.Dispose();
            hv_EvaluationType.Dispose();
            hv_Measures.Dispose();
            hv_ClassIDs.Dispose();
            hv_PixelMeasures.Dispose();
            hv_CalcRegionMeasures.Dispose();
            hv_CalcGrippingPointMeasures.Dispose();
            hv_Index.Dispose();
            hv_ClassDict.Dispose();
            hv_ClassKey.Dispose();
            hv_InstanceType.Dispose();
            hv_EvalOrientation.Dispose();
            hv_AllocationBlockLength.Dispose();
            hv_IoUThreshs.Dispose();
            hv_MaxNumDetections.Dispose();
            hv_AreaRanges.Dispose();
            hv_AreaNames.Dispose();
            hv_MinAreas.Dispose();
            hv_MaxAreas.Dispose();
            hv_DetailedEvaluation.Dispose();
            hv_MaxNumIdx.Dispose();
            hv_MaxNum.Dispose();
            hv_CurrentRunningMeasure.Dispose();
            hv_AreaIdx.Dispose();
            hv_AreaRunningMeasure.Dispose();
            hv_I.Dispose();
            hv_IoURunningMeasure.Dispose();
            hv_ClsIdx.Dispose();
            hv_ClassRunningMeasures.Dispose();
            hv_Confidence.Dispose();
            hv_IgnoreClassIDs.Dispose();
            hv_CalcConfMatrix.Dispose();
            hv_MatrixSize.Dispose();
            hv_PixelConfusionMatrix.Dispose();
            hv_MaxId.Dispose();
            hv_ClsIDToClsIdx.Dispose();
            hv_TP.Dispose();
            hv_FP.Dispose();
            hv_FN.Dispose();
            hv___Tmp_Ctrl_Dict_Init_1.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_Valid.Dispose();
            hv_Exception.Dispose();
            hv_NumClasses.Dispose();
            hv_EvaluationType.Dispose();
            hv_Measures.Dispose();
            hv_ClassIDs.Dispose();
            hv_PixelMeasures.Dispose();
            hv_CalcRegionMeasures.Dispose();
            hv_CalcGrippingPointMeasures.Dispose();
            hv_Index.Dispose();
            hv_ClassDict.Dispose();
            hv_ClassKey.Dispose();
            hv_InstanceType.Dispose();
            hv_EvalOrientation.Dispose();
            hv_AllocationBlockLength.Dispose();
            hv_IoUThreshs.Dispose();
            hv_MaxNumDetections.Dispose();
            hv_AreaRanges.Dispose();
            hv_AreaNames.Dispose();
            hv_MinAreas.Dispose();
            hv_MaxAreas.Dispose();
            hv_DetailedEvaluation.Dispose();
            hv_MaxNumIdx.Dispose();
            hv_MaxNum.Dispose();
            hv_CurrentRunningMeasure.Dispose();
            hv_AreaIdx.Dispose();
            hv_AreaRunningMeasure.Dispose();
            hv_I.Dispose();
            hv_IoURunningMeasure.Dispose();
            hv_ClsIdx.Dispose();
            hv_ClassRunningMeasures.Dispose();
            hv_Confidence.Dispose();
            hv_IgnoreClassIDs.Dispose();
            hv_CalcConfMatrix.Dispose();
            hv_MatrixSize.Dispose();
            hv_PixelConfusionMatrix.Dispose();
            hv_MaxId.Dispose();
            hv_ClsIDToClsIdx.Dispose();
            hv_TP.Dispose();
            hv_FP.Dispose();
            hv_FN.Dispose();
            hv___Tmp_Ctrl_Dict_Init_1.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Model
    // Short Description: Read the dictionaries DLSamples from files. 
    public void read_dl_samples(HTuple hv_DLDataset, HTuple hv_SampleIndices, out HTuple hv_DLSampleBatch)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_DatasetSamples = new HTuple(), hv_MinIndex = new HTuple();
        HTuple hv_MaxIndex = new HTuple(), hv_KeyDirExists = new HTuple();
        HTuple hv_DictDir = new HTuple(), hv_DLSamplesProc = new HTuple();
        HTuple hv_ImageIndex = new HTuple(), hv_KeyFileExists = new HTuple();
        HTuple hv_ImageID = new HTuple(), hv_FileNameRelative = new HTuple();
        HTuple hv_FileNameSample = new HTuple(), hv_FileExists = new HTuple();
        HTuple hv_DictPath = new HTuple(), hv_DLSample = new HTuple();
        HTuple hv_Exception = new HTuple(), hv_isOOD = new HTuple();
        HTuple hv_DLSampleProc = new HTuple(), hv___Tmp_Ctrl_Type = new HTuple();
        // Initialize local and output iconic variables 
        hv_DLSampleBatch = new HTuple();
        try
        {
            //
            //This procedure reads a batch of DLSample dictionaries from disk.
            //The wanted samples are selected from a DLDataset by their indices.
            //The indices of the wanted samples are handed over in SampleIndices.
            //It returns the tuple of read-in dictionaries in DLSampleBatch.
            //
            //Sanity checks of inputs.
            //
            if ((int)(new HTuple((new HTuple(hv_SampleIndices.TupleLength())).TupleLessEqual(
                0))) != 0)
            {
                //Check the length of selected indices.
                throw new HalconException(new HTuple("Invalid length of SelectedIndices: ") + (new HTuple(hv_SampleIndices.TupleLength()
                    )));
            }
            else
            {
                //Get the samples from the DLDataset.
                hv_DatasetSamples.Dispose();
                HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DatasetSamples);
                //Get min and max value of given indices.
                hv_MinIndex.Dispose();
                HOperatorSet.TupleMin(hv_SampleIndices, out hv_MinIndex);
                hv_MaxIndex.Dispose();
                HOperatorSet.TupleMax(hv_SampleIndices, out hv_MaxIndex);
                if ((int)((new HTuple(hv_MinIndex.TupleLess(0))).TupleOr(new HTuple(hv_MaxIndex.TupleGreater(
                    (new HTuple(hv_DatasetSamples.TupleLength())) - 1)))) != 0)
                {
                    //Check the value range of the provided indices.
                    throw new HalconException("The given SampleIndices are not within the range of available samples in DLDataset.");
                }
            }
            //
            //Check if the key dlsample_dir is given.
            hv_KeyDirExists.Dispose();
            HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", "dlsample_dir", out hv_KeyDirExists);
            //
            if ((int)(hv_KeyDirExists) != 0)
            {
                //
                //Get the dlsample_dir.
                hv_DictDir.Dispose();
                HOperatorSet.GetDictTuple(hv_DLDataset, "dlsample_dir", out hv_DictDir);
                //Get the samples to be processed.
                hv_DLSamplesProc.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DLSamplesProc = hv_DatasetSamples.TupleSelect(
                        hv_SampleIndices);
                }
                //
                //Initialize DLSampleBatch tuple.
                hv_DLSampleBatch.Dispose();
                hv_DLSampleBatch = new HTuple();
                //
                //Read in all DLSamples into the batch.
                for (hv_ImageIndex = 0; (int)hv_ImageIndex <= (int)((new HTuple(hv_SampleIndices.TupleLength()
                    )) - 1); hv_ImageIndex = (int)hv_ImageIndex + 1)
                {
                    //Check if dlsample key exist.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_KeyFileExists.Dispose();
                        HOperatorSet.GetDictParam(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                            "key_exists", "dlsample_file_name", out hv_KeyFileExists);
                    }
                    //
                    if ((int)(hv_KeyFileExists.TupleNot()) != 0)
                    {
                        //
                        //If the key does not exist, check if a corresponding file exists.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ImageID.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                "image_id", out hv_ImageID);
                        }
                        hv_FileNameRelative.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FileNameRelative = hv_ImageID + "_dlsample.hdict";
                        }
                        hv_FileNameSample.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FileNameSample = (hv_DictDir + "/") + hv_FileNameRelative;
                        }
                        //
                        hv_FileExists.Dispose();
                        HOperatorSet.FileExists(hv_FileNameSample, out hv_FileExists);
                        if ((int)(hv_FileExists) != 0)
                        {
                            //If it exists, create corresponding key.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                    "dlsample_file_name", hv_FileNameRelative);
                            }
                        }
                        else
                        {
                            //If not, throw an error.
                            throw new HalconException("No 'dlsample_file_name' and hdict file available for image ID " + hv_ImageID);
                        }
                        //
                    }
                    //
                    //If dlsample dictionary is available for reading, read it.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DictPath.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                            "dlsample_file_name", out hv_DictPath);
                    }
                    try
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DLSample.Dispose();
                            HOperatorSet.ReadDict((hv_DictDir + "/") + hv_DictPath, new HTuple(), new HTuple(),
                                out hv_DLSample);
                        }
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        throw new HalconException((((("An error has occurred while reading " + hv_DictDir) + "/") + hv_DictPath) + new HTuple(" , HALCON error # ")) + (hv_Exception.TupleSelect(
                            0)));
                    }
                    //If the sample is marked as an out-of-distribution sample, add the key.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_isOOD.Dispose();
                        HOperatorSet.GetDictParam(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                            "key_exists", "is_ood", out hv_isOOD);
                    }
                    if ((int)(hv_isOOD) != 0)
                    {
                        hv_DLSampleProc.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DLSampleProc = hv_DLSamplesProc.TupleSelect(
                                hv_ImageIndex);
                        }
                        hv___Tmp_Ctrl_Type.Dispose();
                        HOperatorSet.GetDictParam(hv_DLSampleProc, "key_data_type", "is_ood",
                            out hv___Tmp_Ctrl_Type);
                        if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictObject(hv_DLSampleProc.TupleGetDictObject("is_ood"),
                                    hv_DLSample, "is_ood");
                            }
                        }
                        else
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_DLSample, "is_ood", hv_DLSampleProc.TupleGetDictTuple(
                                    "is_ood"));
                            }
                        }
                    }
                    //Add it to the DLSampleBatch.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_DLSampleBatch = hv_DLSampleBatch.TupleConcat(
                                hv_DLSample);
                            hv_DLSampleBatch.Dispose();
                            hv_DLSampleBatch = ExpTmpLocalVar_DLSampleBatch;
                        }
                    }
                    //
                }
            }
            else
            {
                throw new HalconException("The dataset needs to include the key 'dlsample_dir' for reading a DLSample from file.");
            }


            hv_DatasetSamples.Dispose();
            hv_MinIndex.Dispose();
            hv_MaxIndex.Dispose();
            hv_KeyDirExists.Dispose();
            hv_DictDir.Dispose();
            hv_DLSamplesProc.Dispose();
            hv_ImageIndex.Dispose();
            hv_KeyFileExists.Dispose();
            hv_ImageID.Dispose();
            hv_FileNameRelative.Dispose();
            hv_FileNameSample.Dispose();
            hv_FileExists.Dispose();
            hv_DictPath.Dispose();
            hv_DLSample.Dispose();
            hv_Exception.Dispose();
            hv_isOOD.Dispose();
            hv_DLSampleProc.Dispose();
            hv___Tmp_Ctrl_Type.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_DatasetSamples.Dispose();
            hv_MinIndex.Dispose();
            hv_MaxIndex.Dispose();
            hv_KeyDirExists.Dispose();
            hv_DictDir.Dispose();
            hv_DLSamplesProc.Dispose();
            hv_ImageIndex.Dispose();
            hv_KeyFileExists.Dispose();
            hv_ImageID.Dispose();
            hv_FileNameRelative.Dispose();
            hv_FileNameSample.Dispose();
            hv_FileExists.Dispose();
            hv_DictPath.Dispose();
            hv_DLSample.Dispose();
            hv_Exception.Dispose();
            hv_isOOD.Dispose();
            hv_DLSampleProc.Dispose();
            hv___Tmp_Ctrl_Type.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Graphics / Text
    // Short Description: Set font independent of OS 
    public void set_display_font(HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font,
        HTuple hv_Bold, HTuple hv_Slant)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_OS = new HTuple(), hv_Fonts = new HTuple();
        HTuple hv_Style = new HTuple(), hv_Exception = new HTuple();
        HTuple hv_AvailableFonts = new HTuple(), hv_Fdx = new HTuple();
        HTuple hv_Indices = new HTuple();
        HTuple hv_Font_COPY_INP_TMP = new HTuple(hv_Font);
        HTuple hv_Size_COPY_INP_TMP = new HTuple(hv_Size);

        // Initialize local and output iconic variables 
        try
        {
            //This procedure sets the text font of the current window with
            //the specified attributes.
            //
            //Input parameters:
            //WindowHandle: The graphics window for which the font will be set
            //Size: The font size. If Size=-1, the default of 16 is used.
            //Bold: If set to 'true', a bold font is used
            //Slant: If set to 'true', a slanted font is used
            //
            hv_OS.Dispose();
            HOperatorSet.GetSystem("operating_system", out hv_OS);
            if ((int)((new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
                new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(-1)))) != 0)
            {
                hv_Size_COPY_INP_TMP.Dispose();
                hv_Size_COPY_INP_TMP = 16;
            }
            if ((int)(new HTuple(((hv_OS.TupleSubstr(0, 2))).TupleEqual("Win"))) != 0)
            {
                //Restore previous behavior
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_Size = ((1.13677 * hv_Size_COPY_INP_TMP)).TupleInt()
                            ;
                        hv_Size_COPY_INP_TMP.Dispose();
                        hv_Size_COPY_INP_TMP = ExpTmpLocalVar_Size;
                    }
                }
            }
            else
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_Size = hv_Size_COPY_INP_TMP.TupleInt()
                            ;
                        hv_Size_COPY_INP_TMP.Dispose();
                        hv_Size_COPY_INP_TMP = ExpTmpLocalVar_Size;
                    }
                }
            }
            if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("Courier"))) != 0)
            {
                hv_Fonts.Dispose();
                hv_Fonts = new HTuple();
                hv_Fonts[0] = "Courier";
                hv_Fonts[1] = "Courier 10 Pitch";
                hv_Fonts[2] = "Courier New";
                hv_Fonts[3] = "CourierNew";
                hv_Fonts[4] = "Liberation Mono";
            }
            else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))) != 0)
            {
                hv_Fonts.Dispose();
                hv_Fonts = new HTuple();
                hv_Fonts[0] = "Consolas";
                hv_Fonts[1] = "Menlo";
                hv_Fonts[2] = "Courier";
                hv_Fonts[3] = "Courier 10 Pitch";
                hv_Fonts[4] = "FreeMono";
                hv_Fonts[5] = "Liberation Mono";
                hv_Fonts[6] = "DejaVu Sans Mono";
            }
            else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
            {
                hv_Fonts.Dispose();
                hv_Fonts = new HTuple();
                hv_Fonts[0] = "Luxi Sans";
                hv_Fonts[1] = "DejaVu Sans";
                hv_Fonts[2] = "FreeSans";
                hv_Fonts[3] = "Arial";
                hv_Fonts[4] = "Liberation Sans";
            }
            else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
            {
                hv_Fonts.Dispose();
                hv_Fonts = new HTuple();
                hv_Fonts[0] = "Times New Roman";
                hv_Fonts[1] = "Luxi Serif";
                hv_Fonts[2] = "DejaVu Serif";
                hv_Fonts[3] = "FreeSerif";
                hv_Fonts[4] = "Utopia";
                hv_Fonts[5] = "Liberation Serif";
            }
            else
            {
                hv_Fonts.Dispose();
                hv_Fonts = new HTuple(hv_Font_COPY_INP_TMP);
            }
            hv_Style.Dispose();
            hv_Style = "";
            if ((int)(new HTuple(hv_Bold.TupleEqual("true"))) != 0)
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_Style = hv_Style + "Bold";
                        hv_Style.Dispose();
                        hv_Style = ExpTmpLocalVar_Style;
                    }
                }
            }
            else if ((int)(new HTuple(hv_Bold.TupleNotEqual("false"))) != 0)
            {
                hv_Exception.Dispose();
                hv_Exception = "Wrong value of control parameter Bold";
                throw new HalconException(hv_Exception);
            }
            if ((int)(new HTuple(hv_Slant.TupleEqual("true"))) != 0)
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_Style = hv_Style + "Italic";
                        hv_Style.Dispose();
                        hv_Style = ExpTmpLocalVar_Style;
                    }
                }
            }
            else if ((int)(new HTuple(hv_Slant.TupleNotEqual("false"))) != 0)
            {
                hv_Exception.Dispose();
                hv_Exception = "Wrong value of control parameter Slant";
                throw new HalconException(hv_Exception);
            }
            if ((int)(new HTuple(hv_Style.TupleEqual(""))) != 0)
            {
                hv_Style.Dispose();
                hv_Style = "Normal";
            }
            hv_AvailableFonts.Dispose();
            HOperatorSet.QueryFont(hv_WindowHandle, out hv_AvailableFonts);
            hv_Font_COPY_INP_TMP.Dispose();
            hv_Font_COPY_INP_TMP = "";
            for (hv_Fdx = 0; (int)hv_Fdx <= (int)((new HTuple(hv_Fonts.TupleLength())) - 1); hv_Fdx = (int)hv_Fdx + 1)
            {
                hv_Indices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Indices = hv_AvailableFonts.TupleFind(
                        hv_Fonts.TupleSelect(hv_Fdx));
                }
                if ((int)(new HTuple((new HTuple(hv_Indices.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    if ((int)(new HTuple(((hv_Indices.TupleSelect(0))).TupleGreaterEqual(0))) != 0)
                    {
                        hv_Font_COPY_INP_TMP.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Font_COPY_INP_TMP = hv_Fonts.TupleSelect(
                                hv_Fdx);
                        }
                        break;
                    }
                }
            }
            if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual(""))) != 0)
            {
                throw new HalconException("Wrong value of control parameter Font");
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                {
                    HTuple
                      ExpTmpLocalVar_Font = (((hv_Font_COPY_INP_TMP + "-") + hv_Style) + "-") + hv_Size_COPY_INP_TMP;
                    hv_Font_COPY_INP_TMP.Dispose();
                    hv_Font_COPY_INP_TMP = ExpTmpLocalVar_Font;
                }
            }
            HOperatorSet.SetFont(hv_WindowHandle, hv_Font_COPY_INP_TMP);

            hv_Font_COPY_INP_TMP.Dispose();
            hv_Size_COPY_INP_TMP.Dispose();
            hv_OS.Dispose();
            hv_Fonts.Dispose();
            hv_Style.Dispose();
            hv_Exception.Dispose();
            hv_AvailableFonts.Dispose();
            hv_Fdx.Dispose();
            hv_Indices.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_Font_COPY_INP_TMP.Dispose();
            hv_Size_COPY_INP_TMP.Dispose();
            hv_OS.Dispose();
            hv_Fonts.Dispose();
            hv_Style.Dispose();
            hv_Exception.Dispose();
            hv_AvailableFonts.Dispose();
            hv_Fdx.Dispose();
            hv_Indices.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: System / Operating System
    // Short Description: Create a formatted string of a time span. 
    public void timespan_string(HTuple hv_TotalSeconds, HTuple hv_Format, out HTuple hv_TimeString)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_Seconds = new HTuple(), hv_TotalMinutes = new HTuple();
        HTuple hv_Minutes = new HTuple(), hv_TotalHours = new HTuple();
        HTuple hv_Hours = new HTuple(), hv_Days = new HTuple();
        HTuple hv_TotalSeconds_COPY_INP_TMP = new HTuple(hv_TotalSeconds);

        // Initialize local and output iconic variables 
        hv_TimeString = new HTuple();
        try
        {
            //
            //This procedure creates a readable representation of a time span
            //given the elapsed time in seconds.
            //
            //Ensure that the input is an integer.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                {
                    HTuple
                      ExpTmpLocalVar_TotalSeconds = hv_TotalSeconds_COPY_INP_TMP.TupleInt()
                        ;
                    hv_TotalSeconds_COPY_INP_TMP.Dispose();
                    hv_TotalSeconds_COPY_INP_TMP = ExpTmpLocalVar_TotalSeconds;
                }
            }
            //
            hv_Seconds.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_Seconds = hv_TotalSeconds_COPY_INP_TMP % 60;
            }
            //
            hv_TotalMinutes.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_TotalMinutes = hv_TotalSeconds_COPY_INP_TMP / 60;
            }
            hv_Minutes.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_Minutes = hv_TotalMinutes % 60;
            }
            //
            hv_TotalHours.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_TotalHours = hv_TotalSeconds_COPY_INP_TMP / 3600;
            }
            hv_Hours.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_Hours = hv_TotalHours % 24;
            }
            //
            hv_Days.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_Days = hv_TotalSeconds_COPY_INP_TMP / 86400;
            }
            //
            if ((int)(new HTuple(hv_Format.TupleEqual("auto"))) != 0)
            {
                //Print the highest non-zero unit and all remaining sub-units.
                if ((int)(new HTuple(hv_Days.TupleGreater(0))) != 0)
                {
                    hv_TimeString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TimeString = (((((((hv_Days.TupleString(
                            "d")) + "d ") + (hv_Hours.TupleString("d"))) + "h ") + (hv_Minutes.TupleString(
                            "d"))) + "m ") + (hv_Seconds.TupleString("d"))) + "s";
                    }
                }
                else if ((int)(new HTuple(hv_Hours.TupleGreater(0))) != 0)
                {
                    hv_TimeString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TimeString = (((((hv_Hours.TupleString(
                            "d")) + "h ") + (hv_Minutes.TupleString("d"))) + "m ") + (hv_Seconds.TupleString(
                            "d"))) + "s";
                    }
                }
                else if ((int)(new HTuple(hv_Minutes.TupleGreater(0))) != 0)
                {
                    hv_TimeString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TimeString = (((hv_Minutes.TupleString(
                            "d")) + "m ") + (hv_Seconds.TupleString("d"))) + "s";
                    }
                }
                else
                {
                    hv_TimeString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TimeString = (hv_Seconds.TupleString(
                            "d")) + "s";
                    }
                }
            }
            else if ((int)(new HTuple(hv_Format.TupleEqual("top1"))) != 0)
            {
                //Print the highest non-zero unit.
                if ((int)(new HTuple(hv_Days.TupleGreater(0))) != 0)
                {
                    hv_TimeString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TimeString = (hv_Days.TupleString(
                            "d")) + "d";
                    }
                }
                else if ((int)(new HTuple(hv_Hours.TupleGreater(0))) != 0)
                {
                    hv_TimeString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TimeString = (hv_Hours.TupleString(
                            "d")) + "h";
                    }
                }
                else if ((int)(new HTuple(hv_Minutes.TupleGreater(0))) != 0)
                {
                    hv_TimeString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TimeString = (hv_Minutes.TupleString(
                            "d")) + "m";
                    }
                }
                else
                {
                    hv_TimeString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TimeString = (hv_Seconds.TupleString(
                            "d")) + "s";
                    }
                }
            }
            else if ((int)(new HTuple(hv_Format.TupleEqual("top2"))) != 0)
            {
                //Print the highest non-zero unit and the following sub-unit.
                if ((int)(new HTuple(hv_Days.TupleGreater(0))) != 0)
                {
                    hv_TimeString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TimeString = (((hv_Days.TupleString(
                            "d")) + "d ") + (hv_Hours.TupleString("d"))) + "h";
                    }
                }
                else if ((int)(new HTuple(hv_Hours.TupleGreater(0))) != 0)
                {
                    hv_TimeString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TimeString = (((hv_Hours.TupleString(
                            "d")) + "h ") + (hv_Minutes.TupleString("d"))) + "m";
                    }
                }
                else if ((int)(new HTuple(hv_Minutes.TupleGreater(0))) != 0)
                {
                    hv_TimeString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TimeString = (((hv_Minutes.TupleString(
                            "d")) + "m ") + (hv_Seconds.TupleString("d"))) + "s";
                    }
                }
                else
                {
                    hv_TimeString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TimeString = (hv_Seconds.TupleString(
                            "d")) + "s";
                    }
                }
            }
            else if ((int)(new HTuple(hv_Format.TupleEqual("dhms"))) != 0)
            {
                //Print a Days-Hours-Minutes-Seconds string.
                hv_TimeString.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TimeString = (((((((hv_Days.TupleString(
                        "d")) + "d ") + (hv_Hours.TupleString("d"))) + "h ") + (hv_Minutes.TupleString(
                        "d"))) + "m ") + (hv_Seconds.TupleString("d"))) + "s";
                }
            }
            else if ((int)(new HTuple(hv_Format.TupleEqual("hms"))) != 0)
            {
                //Print a Hours-Minutes-Seconds string, where hours can be >= 24.
                hv_TimeString.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TimeString = (((((hv_TotalHours.TupleString(
                        "d")) + "h ") + (hv_Minutes.TupleString("d"))) + "m ") + (hv_Seconds.TupleString(
                        "d"))) + "s";
                }
            }
            else
            {
                throw new HalconException("Unknown format string.");
            }
            //

            hv_TotalSeconds_COPY_INP_TMP.Dispose();
            hv_Seconds.Dispose();
            hv_TotalMinutes.Dispose();
            hv_Minutes.Dispose();
            hv_TotalHours.Dispose();
            hv_Hours.Dispose();
            hv_Days.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_TotalSeconds_COPY_INP_TMP.Dispose();
            hv_Seconds.Dispose();
            hv_TotalMinutes.Dispose();
            hv_Minutes.Dispose();
            hv_TotalHours.Dispose();
            hv_Hours.Dispose();
            hv_Days.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Tuple / Arithmetic
    // Short Description: Calculate the cross product of two vectors of length 3. 
    public void tuple_vector_cross_product(HTuple hv_V1, HTuple hv_V2, out HTuple hv_VC)
    {



        // Local iconic variables 
        // Initialize local and output iconic variables 
        hv_VC = new HTuple();
        //The caller must ensure that the length of both input vectors is 3
        hv_VC.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
            hv_VC = ((hv_V1.TupleSelect(
                1)) * (hv_V2.TupleSelect(2))) - ((hv_V1.TupleSelect(2)) * (hv_V2.TupleSelect(1)));
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
            {
                HTuple
                  ExpTmpLocalVar_VC = hv_VC.TupleConcat(
                    ((hv_V1.TupleSelect(2)) * (hv_V2.TupleSelect(0))) - ((hv_V1.TupleSelect(0)) * (hv_V2.TupleSelect(
                    2))));
                hv_VC.Dispose();
                hv_VC = ExpTmpLocalVar_VC;
            }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
            {
                HTuple
                  ExpTmpLocalVar_VC = hv_VC.TupleConcat(
                    ((hv_V1.TupleSelect(0)) * (hv_V2.TupleSelect(1))) - ((hv_V1.TupleSelect(1)) * (hv_V2.TupleSelect(
                    0))));
                hv_VC.Dispose();
                hv_VC = ExpTmpLocalVar_VC;
            }
        }


        return;
    }

    // Chapter: Deep Learning / Model
    // Short Description: Update RunningMeasures by evaluating Samples and corresponding Results. 
    public void update_running_evaluation_measures(HTuple hv_Samples, HTuple hv_Results,
        HTuple hv_EvalParams, HTuple hv_RunningMeasures)
    {



        // Local control variables 

        HTuple hv_EvaluationType = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            //
            //This procedure updates the running measures depending on the evaluation type.
            hv_EvaluationType.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
            if ((int)((new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))).TupleOr(
                new HTuple(hv_EvaluationType.TupleEqual("gc_anomaly_detection")))) != 0)
            {
                update_running_image_anomaly_measures(hv_Samples, hv_Results, hv_EvalParams,
                    hv_RunningMeasures);
            }
            else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
            {
                update_running_image_classification_measures(hv_Samples, hv_Results, hv_EvalParams,
                    hv_RunningMeasures);
            }
            else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("multi_label_classification"))) != 0)
            {
                update_running_multi_label_classification_measures(hv_Samples, hv_Results,
                    hv_EvalParams, hv_RunningMeasures);
            }
            else if ((int)((new HTuple(hv_EvaluationType.TupleEqual("detection"))).TupleOr(
                new HTuple(hv_EvaluationType.TupleEqual("ocr_detection")))) != 0)
            {
                update_running_instance_measures(hv_Samples, hv_Results, hv_EvalParams, hv_RunningMeasures);
            }
            else if ((int)((new HTuple(hv_EvaluationType.TupleEqual("segmentation"))).TupleOr(
                new HTuple(hv_EvaluationType.TupleEqual("3d_gripping_point_detection")))) != 0)
            {
                update_running_pixel_measures(hv_Samples, hv_Results, hv_EvalParams, hv_RunningMeasures);
                if ((int)(new HTuple(hv_EvaluationType.TupleEqual("3d_gripping_point_detection"))) != 0)
                {
                    update_running_region_measures(hv_Samples, hv_Results, hv_EvalParams, hv_RunningMeasures);
                    update_running_gripping_point_measures(hv_Samples, hv_Results, hv_EvalParams,
                        hv_RunningMeasures);
                }
            }
            else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("ocr_recognition"))) != 0)
            {
                update_running_ocr_recognition_measures(hv_Samples, hv_Results, hv_EvalParams,
                    hv_RunningMeasures);
            }
            //

            hv_EvaluationType.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_EvaluationType.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: 3D Matching / 3D Gripping Point Detection
    // Short Description: Update running measures for 3D gripping points. 
    private void update_running_gripping_point_measures(HTuple hv_Samples, HTuple hv_Results,
        HTuple hv_EvalParams, HTuple hv_RunningMeasures)
    {



        // Local iconic variables 

        HObject ho_AnnotationRegion = null, ho_GTRegions = null;
        HObject ho_GTRegion = null;

        // Local control variables 

        HTuple hv_Index = new HTuple(), hv_Sample = new HTuple();
        HTuple hv_Result = new HTuple(), hv_NumGTRegions = new HTuple();
        HTuple hv_GrippingPointFound = new HTuple(), hv_IndexGTRegions = new HTuple();
        HTuple hv_TP = new HTuple(), hv_FP = new HTuple(), hv_IndexGrippingPoint = new HTuple();
        HTuple hv_GrippingPoint = new HTuple(), hv_GPFound = new HTuple();
        HTuple hv_NumGrippingPointFound = new HTuple();
        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_AnnotationRegion);
        HOperatorSet.GenEmptyObj(out ho_GTRegions);
        HOperatorSet.GenEmptyObj(out ho_GTRegion);
        try
        {
            if ((int)(new HTuple((new HTuple((new HTuple(((hv_EvalParams.TupleGetDictTuple(
                "measures"))).TupleRegexpSelect("gripping_point_.*|all"))).TupleLength()
                )).TupleGreater(0))) != 0)
            {
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Samples.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_Sample.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Sample = hv_Samples.TupleSelect(
                            hv_Index);
                    }
                    hv_Result.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Result = hv_Results.TupleSelect(
                            hv_Index);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        gen_dl_3d_gripping_points_and_poses(hv_Sample, hv_EvalParams.TupleGetDictTuple(
                            "gripping_point_params"), hv_Result);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_AnnotationRegion.Dispose();
                        HOperatorSet.Threshold(hv_Sample.TupleGetDictObject("segmentation_image"),
                            out ho_AnnotationRegion, ((hv_EvalParams.TupleGetDictTuple("class_ids"))).TupleSelect(
                            0), ((hv_EvalParams.TupleGetDictTuple("class_ids"))).TupleSelect(0));
                    }
                    ho_GTRegions.Dispose();
                    HOperatorSet.Connection(ho_AnnotationRegion, out ho_GTRegions);
                    hv_NumGTRegions.Dispose();
                    HOperatorSet.CountObj(ho_GTRegions, out hv_NumGTRegions);
                    //True positives: Only one gripping point
                    //within a ground truth region is counted
                    //as true positive. All additional points
                    //within the same ground truth region are
                    //considered a false positive.
                    //False negative: All ground truth regions
                    //that do not contain at least one
                    //gripping point are a false negative.
                    hv_GrippingPointFound.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_GrippingPointFound = HTuple.TupleGenConst(
                            new HTuple(((hv_Result.TupleGetDictTuple("gripping_points"))).TupleLength()
                            ), 0);
                    }
                    HTuple end_val17 = hv_NumGTRegions;
                    HTuple step_val17 = 1;
                    for (hv_IndexGTRegions = 1; hv_IndexGTRegions.Continue(end_val17, step_val17); hv_IndexGTRegions = hv_IndexGTRegions.TupleAdd(step_val17))
                    {
                        ho_GTRegion.Dispose();
                        HOperatorSet.SelectObj(ho_GTRegions, out ho_GTRegion, hv_IndexGTRegions);
                        hv_TP.Dispose();
                        hv_TP = 0.0;
                        hv_FP.Dispose();
                        hv_FP = 0.0;
                        for (hv_IndexGrippingPoint = 0; (int)hv_IndexGrippingPoint <= (int)((new HTuple(((hv_Result.TupleGetDictTuple(
                            "gripping_points"))).TupleLength())) - 1); hv_IndexGrippingPoint = (int)hv_IndexGrippingPoint + 1)
                        {
                            hv_GrippingPoint.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_GrippingPoint = ((hv_Result.TupleGetDictTuple(
                                    "gripping_points"))).TupleSelect(hv_IndexGrippingPoint);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_GPFound.Dispose();
                                HOperatorSet.TestRegionPoint(ho_GTRegion, hv_GrippingPoint.TupleGetDictTuple(
                                    "row"), hv_GrippingPoint.TupleGetDictTuple("column"), out hv_GPFound);
                            }
                            if ((int)(hv_GPFound) != 0)
                            {
                                if ((int)(new HTuple(hv_TP.TupleEqual(0.0))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_TP = hv_TP + 1.0;
                                            hv_TP.Dispose();
                                            hv_TP = ExpTmpLocalVar_TP;
                                        }
                                    }
                                }
                                else
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_FP = hv_FP + 1.0;
                                            hv_FP.Dispose();
                                            hv_FP = ExpTmpLocalVar_FP;
                                        }
                                    }
                                }
                                if (hv_GrippingPointFound == null)
                                    hv_GrippingPointFound = new HTuple();
                                hv_GrippingPointFound[hv_IndexGrippingPoint] = 1;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_RunningMeasures, "gp_tp", (hv_RunningMeasures.TupleGetDictTuple(
                                "gp_tp")) + hv_TP);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_RunningMeasures, "gp_fp", (hv_RunningMeasures.TupleGetDictTuple(
                                "gp_fp")) + hv_FP);
                        }
                        if ((int)(new HTuple(hv_TP.TupleEqual(0.0))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_RunningMeasures, "gp_fn", (hv_RunningMeasures.TupleGetDictTuple(
                                    "gp_fn")) + 1.0);
                            }
                        }
                    }
                    //All gripping points that have not been
                    //found to lie within the ground truth
                    //region are additional false positives.
                    if ((int)(new HTuple((new HTuple(hv_GrippingPointFound.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        hv_NumGrippingPointFound.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumGrippingPointFound = hv_GrippingPointFound.TupleSum()
                                ;
                        }
                    }
                    else
                    {
                        hv_NumGrippingPointFound.Dispose();
                        hv_NumGrippingPointFound = 0;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "gp_fp", (hv_RunningMeasures.TupleGetDictTuple(
                            "gp_fp")) + ((new HTuple(hv_GrippingPointFound.TupleLength())) - hv_NumGrippingPointFound));
                    }
                }
            }
            ho_AnnotationRegion.Dispose();
            ho_GTRegions.Dispose();
            ho_GTRegion.Dispose();

            hv_Index.Dispose();
            hv_Sample.Dispose();
            hv_Result.Dispose();
            hv_NumGTRegions.Dispose();
            hv_GrippingPointFound.Dispose();
            hv_IndexGTRegions.Dispose();
            hv_TP.Dispose();
            hv_FP.Dispose();
            hv_IndexGrippingPoint.Dispose();
            hv_GrippingPoint.Dispose();
            hv_GPFound.Dispose();
            hv_NumGrippingPointFound.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_AnnotationRegion.Dispose();
            ho_GTRegions.Dispose();
            ho_GTRegion.Dispose();

            hv_Index.Dispose();
            hv_Sample.Dispose();
            hv_Result.Dispose();
            hv_NumGTRegions.Dispose();
            hv_GrippingPointFound.Dispose();
            hv_IndexGTRegions.Dispose();
            hv_TP.Dispose();
            hv_FP.Dispose();
            hv_IndexGrippingPoint.Dispose();
            hv_GrippingPoint.Dispose();
            hv_GPFound.Dispose();
            hv_NumGrippingPointFound.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
    // Short Description: Update running measures for an anomaly detection or Global Context Anomaly Detection evaluation. 
    private void update_running_image_anomaly_measures(HTuple hv_Samples, HTuple hv_Results,
        HTuple hv_EvalParams, HTuple hv_RunningMeasures)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_ImageIDs = new HTuple(), hv_AnomalyLabelIDs = new HTuple();
        HTuple hv_AnomalyScores = new HTuple(), hv_SampleIndex = new HTuple();
        HTuple hv_Sample = new HTuple(), hv_ImageID = new HTuple();
        HTuple hv_AnomalyLabelID = new HTuple(), hv_Result = new HTuple();
        HTuple hv_Keys = new HTuple(), hv_AnomalyScoreKey = new HTuple();
        HTuple hv_AnomalyScore = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            //
            //This procedure updates the RunningMeasures for an evaluation for anomaly detection.
            //
            //These measures are stored in the dictionary RunningMeasures and
            //updated by incorporating the Results the model obtained for the Samples.
            //
            //
            //Get image ids.
            hv_ImageIDs.Dispose();
            HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_ids", out hv_ImageIDs);
            //Get anomaly label ids.
            hv_AnomalyLabelIDs.Dispose();
            HOperatorSet.GetDictTuple(hv_RunningMeasures, "anomaly_label_ids", out hv_AnomalyLabelIDs);
            //Get anomaly scores.
            hv_AnomalyScores.Dispose();
            HOperatorSet.GetDictTuple(hv_RunningMeasures, "anomaly_scores", out hv_AnomalyScores);
            //Loop over all samples and update running measures accordingly.
            for (hv_SampleIndex = 0; (int)hv_SampleIndex <= (int)((new HTuple(hv_Samples.TupleLength()
                )) - 1); hv_SampleIndex = (int)hv_SampleIndex + 1)
            {
                hv_Sample.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Sample = hv_Samples.TupleSelect(
                        hv_SampleIndex);
                }
                hv_ImageID.Dispose();
                HOperatorSet.GetDictTuple(hv_Sample, "image_id", out hv_ImageID);
                hv_AnomalyLabelID.Dispose();
                HOperatorSet.GetDictTuple(hv_Sample, "anomaly_label_id", out hv_AnomalyLabelID);
                hv_Result.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Result = hv_Results.TupleSelect(
                        hv_SampleIndex);
                }
                hv_Keys.Dispose();
                HOperatorSet.GetDictParam(hv_Result, "keys", new HTuple(), out hv_Keys);
                hv_AnomalyScoreKey.Dispose();
                HOperatorSet.TupleRegexpSelect(hv_Keys, "anomaly_score.*", out hv_AnomalyScoreKey);
                //It is not expected that AnomalyScoreKey contains more than one item.
                //In case it unexpectedly does, we index it with [0].
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_AnomalyScore.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, hv_AnomalyScoreKey.TupleSelect(0), out hv_AnomalyScore);
                }
                //
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ImageIDs = hv_ImageIDs.TupleConcat(
                            hv_ImageID);
                        hv_ImageIDs.Dispose();
                        hv_ImageIDs = ExpTmpLocalVar_ImageIDs;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_AnomalyLabelIDs = hv_AnomalyLabelIDs.TupleConcat(
                            hv_AnomalyLabelID);
                        hv_AnomalyLabelIDs.Dispose();
                        hv_AnomalyLabelIDs = ExpTmpLocalVar_AnomalyLabelIDs;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_AnomalyScores = hv_AnomalyScores.TupleConcat(
                            hv_AnomalyScore);
                        hv_AnomalyScores.Dispose();
                        hv_AnomalyScores = ExpTmpLocalVar_AnomalyScores;
                    }
                }
            }
            //
            //Set image ids in running measures.
            HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", hv_ImageIDs);
            //Set anomaly label ids in running measures.
            HOperatorSet.SetDictTuple(hv_RunningMeasures, "anomaly_label_ids", hv_AnomalyLabelIDs);
            //Set anomaly scores in running measures.
            HOperatorSet.SetDictTuple(hv_RunningMeasures, "anomaly_scores", hv_AnomalyScores);
            //

            hv_ImageIDs.Dispose();
            hv_AnomalyLabelIDs.Dispose();
            hv_AnomalyScores.Dispose();
            hv_SampleIndex.Dispose();
            hv_Sample.Dispose();
            hv_ImageID.Dispose();
            hv_AnomalyLabelID.Dispose();
            hv_Result.Dispose();
            hv_Keys.Dispose();
            hv_AnomalyScoreKey.Dispose();
            hv_AnomalyScore.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_ImageIDs.Dispose();
            hv_AnomalyLabelIDs.Dispose();
            hv_AnomalyScores.Dispose();
            hv_SampleIndex.Dispose();
            hv_Sample.Dispose();
            hv_ImageID.Dispose();
            hv_AnomalyLabelID.Dispose();
            hv_Result.Dispose();
            hv_Keys.Dispose();
            hv_AnomalyScoreKey.Dispose();
            hv_AnomalyScore.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Classification
    // Short Description: Update running measures for an image classification evaluation. 
    private void update_running_image_classification_measures(HTuple hv_Samples, HTuple hv_Results,
        HTuple hv_EvalParams, HTuple hv_RunningMeasures)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_RegExpTopKError = new HTuple(), hv_Measures = new HTuple();
        HTuple hv_K = new HTuple(), hv_M = new HTuple(), hv_ComputeTopKError = new HTuple();
        HTuple hv_ImageIDs = new HTuple(), hv_ImageLabelIDs = new HTuple();
        HTuple hv_Top1Prediction = new HTuple(), hv_TopKPredictionDicts = new HTuple();
        HTuple hv_Index = new HTuple(), hv_Sample = new HTuple();
        HTuple hv_ImageID = new HTuple(), hv_ImageLabelID = new HTuple();
        HTuple hv_Result = new HTuple(), hv_PredictedClassIDs = new HTuple();
        HTuple hv_TopKPrediction = new HTuple(), hv_TopKPredictionDict = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            //
            //This procedure updates the RunningMeasures for an evaluation for classification.
            //
            //To avoid memory, only save first K predictions per sample.
            hv_RegExpTopKError.Dispose();
            hv_RegExpTopKError = "top([0-9]+)_error";
            hv_Measures.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
            hv_K.Dispose();
            hv_K = 1;
            for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
            {
                hv_ComputeTopKError.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ComputeTopKError = ((hv_Measures.TupleSelect(
                        hv_M))).TupleRegexpTest(hv_RegExpTopKError);
                }
                if ((int)(hv_ComputeTopKError) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_K = hv_K.TupleMax2(
                                ((((hv_Measures.TupleSelect(hv_M))).TupleRegexpMatch(hv_RegExpTopKError))).TupleNumber()
                                );
                            hv_K.Dispose();
                            hv_K = ExpTmpLocalVar_K;
                        }
                    }
                }
            }
            //
            //Extend tuples in RunningMeasures with new results.
            hv_ImageIDs.Dispose();
            HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_ids", out hv_ImageIDs);
            hv_ImageLabelIDs.Dispose();
            HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_label_ids", out hv_ImageLabelIDs);
            hv_Top1Prediction.Dispose();
            HOperatorSet.GetDictTuple(hv_RunningMeasures, "top1_predictions", out hv_Top1Prediction);
            hv_TopKPredictionDicts.Dispose();
            HOperatorSet.GetDictTuple(hv_RunningMeasures, "topk_predictions", out hv_TopKPredictionDicts);
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Samples.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
            {
                hv_Sample.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Sample = hv_Samples.TupleSelect(
                        hv_Index);
                }
                hv_ImageID.Dispose();
                HOperatorSet.GetDictTuple(hv_Sample, "image_id", out hv_ImageID);
                hv_ImageLabelID.Dispose();
                HOperatorSet.GetDictTuple(hv_Sample, "image_label_id", out hv_ImageLabelID);
                hv_Result.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Result = hv_Results.TupleSelect(
                        hv_Index);
                }
                hv_PredictedClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_Result, "classification_class_ids", out hv_PredictedClassIDs);
                hv_TopKPrediction.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TopKPrediction = hv_PredictedClassIDs.TupleSelectRange(
                        0, hv_K - 1);
                }
                hv_TopKPredictionDict.Dispose();
                HOperatorSet.CreateDict(out hv_TopKPredictionDict);
                HOperatorSet.SetDictTuple(hv_TopKPredictionDict, "predictions", hv_TopKPrediction);
                //
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ImageIDs = hv_ImageIDs.TupleConcat(
                            hv_ImageID);
                        hv_ImageIDs.Dispose();
                        hv_ImageIDs = ExpTmpLocalVar_ImageIDs;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ImageLabelIDs = hv_ImageLabelIDs.TupleConcat(
                            hv_ImageLabelID);
                        hv_ImageLabelIDs.Dispose();
                        hv_ImageLabelIDs = ExpTmpLocalVar_ImageLabelIDs;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_Top1Prediction = hv_Top1Prediction.TupleConcat(
                            hv_TopKPrediction.TupleSelect(0));
                        hv_Top1Prediction.Dispose();
                        hv_Top1Prediction = ExpTmpLocalVar_Top1Prediction;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_TopKPredictionDicts = hv_TopKPredictionDicts.TupleConcat(
                            hv_TopKPredictionDict);
                        hv_TopKPredictionDicts.Dispose();
                        hv_TopKPredictionDicts = ExpTmpLocalVar_TopKPredictionDicts;
                    }
                }
            }
            //
            HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", hv_ImageIDs);
            HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_label_ids", hv_ImageLabelIDs);
            HOperatorSet.SetDictTuple(hv_RunningMeasures, "top1_predictions", hv_Top1Prediction);
            HOperatorSet.SetDictTuple(hv_RunningMeasures, "topk_predictions", hv_TopKPredictionDicts);
            //
            if ((int)(hv_EvalParams.TupleGetDictTuple("calculate_ood_measures")) != 0)
            {
                update_running_ood_detection_measures(hv_Samples, hv_Results, hv_EvalParams,
                    hv_RunningMeasures);
            }
            //

            hv_RegExpTopKError.Dispose();
            hv_Measures.Dispose();
            hv_K.Dispose();
            hv_M.Dispose();
            hv_ComputeTopKError.Dispose();
            hv_ImageIDs.Dispose();
            hv_ImageLabelIDs.Dispose();
            hv_Top1Prediction.Dispose();
            hv_TopKPredictionDicts.Dispose();
            hv_Index.Dispose();
            hv_Sample.Dispose();
            hv_ImageID.Dispose();
            hv_ImageLabelID.Dispose();
            hv_Result.Dispose();
            hv_PredictedClassIDs.Dispose();
            hv_TopKPrediction.Dispose();
            hv_TopKPredictionDict.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_RegExpTopKError.Dispose();
            hv_Measures.Dispose();
            hv_K.Dispose();
            hv_M.Dispose();
            hv_ComputeTopKError.Dispose();
            hv_ImageIDs.Dispose();
            hv_ImageLabelIDs.Dispose();
            hv_Top1Prediction.Dispose();
            hv_TopKPredictionDicts.Dispose();
            hv_Index.Dispose();
            hv_Sample.Dispose();
            hv_ImageID.Dispose();
            hv_ImageLabelID.Dispose();
            hv_Result.Dispose();
            hv_PredictedClassIDs.Dispose();
            hv_TopKPrediction.Dispose();
            hv_TopKPredictionDict.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Object Detection and Instance Segmentation
    // Short Description: Update running measures for an instance-based evaluation. 
    private void update_running_instance_measures(HTuple hv_Samples, HTuple hv_Results,
        HTuple hv_EvalParams, HTuple hv_RunningMeasures)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_MaxNumDetections = new HTuple();
        HTuple hv_AreaRanges = new HTuple(), hv_IoUThresholds = new HTuple();
        HTuple hv_InstanceType = new HTuple(), hv_ClassIDs = new HTuple();
        HTuple hv_NumClasses = new HTuple(), hv_Measures = new HTuple();
        HTuple hv_AreaNames = new HTuple(), hv_MinAreas = new HTuple();
        HTuple hv_MaxAreas = new HTuple(), hv_NumAreaRanges = new HTuple();
        HTuple hv_AllocationBlockLength = new HTuple(), hv_DetailedEvaluation = new HTuple();
        HTuple hv_KeyExists = new HTuple(), hv_ClassIDToClassIdx = new HTuple();
        HTuple hv_EvaluateOrientation = new HTuple(), hv_SIdx = new HTuple();
        HTuple hv_CurrentSample = new HTuple(), hv_CurrentResult = new HTuple();
        HTuple hv_GtClassIDs = new HTuple(), hv_ResClassIDs = new HTuple();
        HTuple hv_NumGT = new HTuple(), hv_NumRes = new HTuple();
        HTuple hv_Confidences = new HTuple(), hv_ResSortIndices = new HTuple();
        HTuple hv_GtAreas = new HTuple(), hv_ResAreas = new HTuple();
        HTuple hv_IoUs = new HTuple(), hv_GtPhis = new HTuple();
        HTuple hv_ResPhis = new HTuple(), hv_MDIdx = new HTuple();
        HTuple hv_MaxNum = new HTuple(), hv_MaxNumStr = new HTuple();
        HTuple hv_CurrentRunningMeasures = new HTuple(), hv_AreaIdx = new HTuple();
        HTuple hv_MinArea = new HTuple(), hv_MaxArea = new HTuple();
        HTuple hv_AreaName = new HTuple(), hv_AreaRunningMeasures = new HTuple();
        HTuple hv_GtIgnore = new HTuple(), hv_GtIgnoreInds = new HTuple();
        HTuple hv_PerClassNumGt = new HTuple(), hv_PerClassNumPred = new HTuple();
        HTuple hv_PerClassConfidences = new HTuple(), hv_PerClassNumGtIgnore = new HTuple();
        HTuple hv_SampleHasFP = new HTuple(), hv_SampleHasFN = new HTuple();
        HTuple hv_ClsIdx = new HTuple(), hv_CurrentClassID = new HTuple();
        HTuple hv_CurrentGtIdxs = new HTuple(), hv_CurrentNumGt = new HTuple();
        HTuple hv_CurrentGtIgnore = new HTuple(), hv_CurrentNumGtIgnore = new HTuple();
        HTuple hv_CurrentNumGtNoIgnore = new HTuple(), hv_CurrentResIdxs = new HTuple();
        HTuple hv_CurrentNumRes = new HTuple(), hv_CurrentResAreas = new HTuple();
        HTuple hv_OldNumPred = new HTuple(), hv_CurrentClassConfidences = new HTuple();
        HTuple hv_GtSortIdx = new HTuple(), hv_CurrentResPhis = new HTuple();
        HTuple hv_CurrentGtPhis = new HTuple(), hv_ITIdx = new HTuple();
        HTuple hv_GtMatched = new HTuple(), hv_ResMatched = new HTuple();
        HTuple hv_ResAbsOrientationDiff = new HTuple(), hv_ResIgnore = new HTuple();
        HTuple hv_ResIdx = new HTuple(), hv_CurrentIoU = new HTuple();
        HTuple hv_MatchIdx = new HTuple(), hv_GtIdx = new HTuple();
        HTuple hv_AreaIgnore = new HTuple(), hv_PerIoUMeasure = new HTuple();
        HTuple hv_PerClassMeasures = new HTuple(), hv_CurrentIsTP = new HTuple();
        HTuple hv_CurrentIgnore = new HTuple(), hv_CurrentAbsOrientationDiff = new HTuple();
        HTuple hv_GtMatchedNoIgnore = new HTuple(), hv_ResIsFPClass = new HTuple();
        HTuple hv_ResIsFPBackground = new HTuple(), hv_ResIsFPLocalization = new HTuple();
        HTuple hv_ResIsFPDuplicate = new HTuple(), hv_ResIsFPMultiple = new HTuple();
        HTuple hv_ResAbsOrientationDiffClass = new HTuple(), hv_ResAbsOrientationDiffLocalization = new HTuple();
        HTuple hv_ResAbsOrientationDiffDuplicate = new HTuple();
        HTuple hv_ResAbsOrientationDiffMultiple = new HTuple();
        HTuple hv_FPResIdxsThisClass = new HTuple(), hv_FPResIdxsAllResults = new HTuple();
        HTuple hv_GTIdxsNotToIgnore = new HTuple(), hv_MaxIoU = new HTuple();
        HTuple hv_IoUsWithGT = new HTuple(), hv_MaxIdx = new HTuple();
        HTuple hv_GTClassIDMaxIoU = new HTuple(), hv_AbsOrientationDiff = new HTuple();
        HTuple hv_IsFPClass = new HTuple(), hv_IsFPBackground = new HTuple();
        HTuple hv_IsFPLocalization = new HTuple(), hv_IsFPDuplicate = new HTuple();
        HTuple hv_IsFPMultiple = new HTuple(), hv_AbsOrientationDiffMultiple = new HTuple();
        HTuple hv_AbsOrientationDiffDuplicate = new HTuple(), hv_AbsOrientationDiffLocalization = new HTuple();
        HTuple hv_AbsOrientationDiffClass = new HTuple(), hv_CurrentImageID = new HTuple();
        HTuple hv_ImageIDsWithFN = new HTuple(), hv_NumImageIDsWithFN = new HTuple();
        HTuple hv_ImageIDsWithFP = new HTuple(), hv_NumImageIDsWithFP = new HTuple();
        HTuple hv___Tmp_Ctrl_Dict_Init_0 = new HTuple(), hv___Tmp_Ctrl_Dict_Init_1 = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            //
            //This procedure updates the RunningMeasures
            //for an instance-based evaluation for detection.
            //These measures are stored in the dictionary RunningMeasures and
            //updated by incorporating the Results the model obtained for the Samples.
            //
            dev_update_off();
            //Get the necessary evaluation parameters.
            hv_MaxNumDetections.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "max_num_detections", out hv_MaxNumDetections);
            hv_AreaRanges.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "area_ranges", out hv_AreaRanges);
            hv_IoUThresholds.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_IoUThresholds);
            hv_InstanceType.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "instance_type", out hv_InstanceType);
            hv_ClassIDs.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
            hv_NumClasses.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
            hv_Measures.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
            //
            //Get the area parameters: name, min, and max.
            hv_AreaNames.Dispose();
            HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaNames);
            hv_MinAreas.Dispose();
            HOperatorSet.GetDictTuple(hv_AreaRanges, "min", out hv_MinAreas);
            hv_MaxAreas.Dispose();
            HOperatorSet.GetDictTuple(hv_AreaRanges, "max", out hv_MaxAreas);
            hv_NumAreaRanges.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_NumAreaRanges = (new HTuple(hv_AreaNames.TupleLength()
                    )) - 1;
            }
            //
            //Get the allocation length for extending tuples.
            hv_AllocationBlockLength.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "allocation_block_length", out hv_AllocationBlockLength);
            //
            //Check if a detailed evaluation should be done.
            hv_DetailedEvaluation.Dispose();
            hv_DetailedEvaluation = 0;
            hv_KeyExists.Dispose();
            HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "detailed_evaluation",
                out hv_KeyExists);
            if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
            {
                hv_DetailedEvaluation.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "detailed_evaluation", out hv_DetailedEvaluation);
            }
            if ((int)(hv_DetailedEvaluation) != 0)
            {
                //We need a mapping from class IDs to class indices
                hv_ClassIDToClassIdx.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ClassIDToClassIdx = HTuple.TupleGenConst(
                        (hv_ClassIDs.TupleMax()) + 1, -1);
                }
                if (hv_ClassIDToClassIdx == null)
                    hv_ClassIDToClassIdx = new HTuple();
                hv_ClassIDToClassIdx[hv_ClassIDs] = HTuple.TupleGenSequence(0, hv_NumClasses - 1, 1);
            }
            //
            //Check if the orientation is to be evaluated.
            hv_EvaluateOrientation.Dispose();
            hv_EvaluateOrientation = 0;
            if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd((new HTuple(((hv_Measures.TupleFind(
                "soap"))).TupleNotEqual(-1))).TupleOr(new HTuple(((hv_Measures.TupleFind(
                "all"))).TupleNotEqual(-1))))) != 0)
            {
                hv_EvaluateOrientation.Dispose();
                hv_EvaluateOrientation = 1;
            }
            //
            //Go through samples.
            for (hv_SIdx = 0; (int)hv_SIdx <= (int)((new HTuple(hv_Samples.TupleLength())) - 1); hv_SIdx = (int)hv_SIdx + 1)
            {
                //
                hv_CurrentSample.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_CurrentSample = hv_Samples.TupleSelect(
                        hv_SIdx);
                }
                hv_CurrentResult.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_CurrentResult = hv_Results.TupleSelect(
                        hv_SIdx);
                }
                //
                //Get classes.
                hv_GtClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_CurrentSample, "bbox_label_id", out hv_GtClassIDs);
                //Convert results from Deep OCR format to rectangle2 Object Detection format.
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_0);
                HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_0, "comp", "ocr_detection");
                if ((int)(((hv_EvalParams.TupleConcat(hv___Tmp_Ctrl_Dict_Init_0))).TupleTestEqualDictItem(
                    "evaluation_type", "comp")) != 0)
                {
                    {
                        HTuple ExpTmpOutVar_0;
                        convert_ocr_detection_result_to_object_detection(hv_CurrentResult, out ExpTmpOutVar_0);
                        hv_CurrentResult.Dispose();
                        hv_CurrentResult = ExpTmpOutVar_0;
                    }
                }
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv___Tmp_Ctrl_Dict_Init_0 = HTuple.TupleConstant(
                        "HNULL");
                }
                hv_ResClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_CurrentResult, "bbox_class_id", out hv_ResClassIDs);
                hv_NumGT.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumGT = new HTuple(hv_GtClassIDs.TupleLength()
                        );
                }
                hv_NumRes.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumRes = new HTuple(hv_ResClassIDs.TupleLength()
                        );
                }
                //
                //Get result confidences and sort them in descending order.
                hv_Confidences.Dispose();
                HOperatorSet.GetDictTuple(hv_CurrentResult, "bbox_confidence", out hv_Confidences);
                hv_ResSortIndices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ResSortIndices = ((-hv_Confidences)).TupleSortIndex()
                        ;
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_Confidences = hv_Confidences.TupleSelect(
                            hv_ResSortIndices);
                        hv_Confidences.Dispose();
                        hv_Confidences = ExpTmpLocalVar_Confidences;
                    }
                }
                //Sort the result class IDs.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ResClassIDs = hv_ResClassIDs.TupleSelect(
                            hv_ResSortIndices);
                        hv_ResClassIDs.Dispose();
                        hv_ResClassIDs = ExpTmpLocalVar_ResClassIDs;
                    }
                }
                //
                //Compute the IoUs of the instances.
                hv_GtAreas.Dispose(); hv_ResAreas.Dispose(); hv_IoUs.Dispose();
                area_iou(hv_CurrentSample, hv_CurrentResult, hv_InstanceType, hv_ResSortIndices,
                    out hv_GtAreas, out hv_ResAreas, out hv_IoUs);
                //
                if ((int)(hv_EvaluateOrientation) != 0)
                {
                    hv_GtPhis.Dispose();
                    HOperatorSet.GetDictTuple(hv_CurrentSample, "bbox_phi", out hv_GtPhis);
                    hv_ResPhis.Dispose();
                    HOperatorSet.GetDictTuple(hv_CurrentResult, "bbox_phi", out hv_ResPhis);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResPhis = hv_ResPhis.TupleSelect(
                                hv_ResSortIndices);
                            hv_ResPhis.Dispose();
                            hv_ResPhis = ExpTmpLocalVar_ResPhis;
                        }
                    }
                }
                //Loop over the maximal number of detections.
                for (hv_MDIdx = 0; (int)hv_MDIdx <= (int)((new HTuple(hv_MaxNumDetections.TupleLength()
                    )) - 1); hv_MDIdx = (int)hv_MDIdx + 1)
                {
                    hv_MaxNum.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxNum = hv_MaxNumDetections.TupleSelect(
                            hv_MDIdx);
                    }
                    hv_MaxNumStr.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxNumStr = "" + hv_MaxNum;
                    }
                    if ((int)(new HTuple(hv_MaxNum.TupleEqual(-1))) != 0)
                    {
                        hv_MaxNumStr.Dispose();
                        hv_MaxNumStr = "all";
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentRunningMeasures.Dispose();
                        HOperatorSet.GetDictTuple(hv_RunningMeasures, "max_num_detections_" + hv_MaxNumStr,
                            out hv_CurrentRunningMeasures);
                    }
                    //
                    //Loop over the area ranges.
                    for (hv_AreaIdx = 0; (int)hv_AreaIdx <= (int)((new HTuple(hv_AreaNames.TupleLength()
                        )) - 1); hv_AreaIdx = (int)hv_AreaIdx + 1)
                    {
                        //
                        //Get information about the current area range.
                        hv_MinArea.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MinArea = hv_MinAreas.TupleSelect(
                                hv_AreaIdx);
                        }
                        hv_MaxArea.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MaxArea = hv_MaxAreas.TupleSelect(
                                hv_AreaIdx);
                        }
                        hv_AreaName.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AreaName = hv_AreaNames.TupleSelect(
                                hv_AreaIdx);
                        }
                        //
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AreaRunningMeasures.Dispose();
                            HOperatorSet.GetDictTuple(hv_CurrentRunningMeasures, "area_" + hv_AreaName,
                                out hv_AreaRunningMeasures);
                        }
                        //
                        //Set ignore-flag for ground truth instances.
                        //For Deep OCR detection, ignore classes other than 'word'
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                        HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_1);
                        HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_1, "comp", "ocr_detection");
                        if ((int)(((hv_EvalParams.TupleConcat(hv___Tmp_Ctrl_Dict_Init_1))).TupleTestEqualDictItem(
                            "evaluation_type", "comp")) != 0)
                        {
                            hv_GtIgnore.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_GtIgnore = hv_GtClassIDs.TupleNotEqualElem(
                                    0);
                            }
                        }
                        else
                        {
                            hv_GtIgnore.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_GtIgnore = HTuple.TupleGenConst(
                                    hv_NumGT, 0);
                            }
                        }
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv___Tmp_Ctrl_Dict_Init_1 = HTuple.TupleConstant(
                                "HNULL");
                        }
                        //
                        //Ignore ground truth instances with area outside the area range.
                        if ((int)(new HTuple(hv_NumGT.TupleGreater(0))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_GtIgnoreInds.Dispose();
                                HOperatorSet.TupleFind(((hv_GtAreas.TupleLessElem(hv_MinArea))).TupleOr(
                                    hv_GtAreas.TupleGreaterElem(hv_MaxArea)), 1, out hv_GtIgnoreInds);
                            }
                            if ((int)(new HTuple(hv_GtIgnoreInds.TupleGreater(-1))) != 0)
                            {
                                if (hv_GtIgnore == null)
                                    hv_GtIgnore = new HTuple();
                                hv_GtIgnore[hv_GtIgnoreInds] = 1;
                            }
                        }
                        //
                        hv_PerClassNumGt.Dispose();
                        HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_gt", out hv_PerClassNumGt);
                        hv_PerClassNumPred.Dispose();
                        HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_pred", out hv_PerClassNumPred);
                        hv_PerClassConfidences.Dispose();
                        HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "confidence", out hv_PerClassConfidences);
                        hv_PerClassNumGtIgnore.Dispose();
                        HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_gt_ignore", out hv_PerClassNumGtIgnore);
                        //
                        if ((int)(hv_DetailedEvaluation) != 0)
                        {
                            //Store if a sample has at least one false positive or false negative (for each IoU threshold).
                            hv_SampleHasFP.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SampleHasFP = HTuple.TupleGenConst(
                                    new HTuple(hv_IoUThresholds.TupleLength()), 0);
                            }
                            hv_SampleHasFN.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SampleHasFN = HTuple.TupleGenConst(
                                    new HTuple(hv_IoUThresholds.TupleLength()), 0);
                            }
                        }
                        //
                        //Loop over the classes.
                        HTuple end_val127 = hv_NumClasses - 1;
                        HTuple step_val127 = 1;
                        for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val127, step_val127); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val127))
                        {
                            hv_CurrentClassID.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_CurrentClassID = hv_ClassIDs.TupleSelect(
                                    hv_ClsIdx);
                            }
                            //
                            //Get the ground truth for this class.
                            hv_CurrentGtIdxs.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_CurrentGtIdxs = hv_GtClassIDs.TupleFind(
                                    hv_CurrentClassID);
                            }
                            if ((int)(new HTuple(hv_CurrentGtIdxs.TupleEqual(-1))) != 0)
                            {
                                hv_CurrentGtIdxs.Dispose();
                                hv_CurrentGtIdxs = new HTuple();
                            }
                            hv_CurrentNumGt.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_CurrentNumGt = new HTuple(hv_CurrentGtIdxs.TupleLength()
                                    );
                            }
                            //
                            //Get ground truth ignore for this class.
                            hv_CurrentGtIgnore.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_CurrentGtIgnore = hv_GtIgnore.TupleSelect(
                                    hv_CurrentGtIdxs);
                            }
                            if ((int)(new HTuple((new HTuple(hv_CurrentGtIgnore.TupleLength())).TupleEqual(
                                0))) != 0)
                            {
                                hv_CurrentNumGtIgnore.Dispose();
                                hv_CurrentNumGtIgnore = 0;
                            }
                            else
                            {
                                hv_CurrentNumGtIgnore.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentNumGtIgnore = hv_CurrentGtIgnore.TupleSum()
                                        ;
                                }
                            }
                            //
                            //Number of gt for this class and without ignore.
                            hv_CurrentNumGtNoIgnore.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_CurrentNumGtNoIgnore = hv_CurrentNumGt - hv_CurrentNumGtIgnore;
                            }
                            //
                            //Get results for this class.
                            hv_CurrentResIdxs.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_CurrentResIdxs = hv_ResClassIDs.TupleFind(
                                    hv_CurrentClassID);
                            }
                            if ((int)(new HTuple(hv_CurrentResIdxs.TupleEqual(-1))) != 0)
                            {
                                hv_CurrentResIdxs.Dispose();
                                hv_CurrentResIdxs = new HTuple();
                            }
                            hv_CurrentNumRes.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_CurrentNumRes = hv_MaxNum.TupleMin2(
                                    new HTuple(hv_CurrentResIdxs.TupleLength()));
                            }
                            //MaxNum -1 corresponds to taking all results.
                            if ((int)(new HTuple(hv_MaxNum.TupleEqual(-1))) != 0)
                            {
                                hv_CurrentNumRes.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentNumRes = new HTuple(hv_CurrentResIdxs.TupleLength()
                                        );
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_CurrentResIdxs = hv_CurrentResIdxs.TupleSelectRange(
                                        0, hv_CurrentNumRes - 1);
                                    hv_CurrentResIdxs.Dispose();
                                    hv_CurrentResIdxs = ExpTmpLocalVar_CurrentResIdxs;
                                }
                            }
                            //
                            //Get areas of the current results.
                            hv_CurrentResAreas.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_CurrentResAreas = hv_ResAreas.TupleSelect(
                                    hv_CurrentResIdxs);
                            }
                            //
                            //Update the confidences, num_gt and num_pred for this class.
                            hv_OldNumPred.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_OldNumPred = hv_PerClassNumPred.TupleSelect(
                                    hv_ClsIdx);
                            }
                            if (hv_PerClassNumGt == null)
                                hv_PerClassNumGt = new HTuple();
                            hv_PerClassNumGt[hv_ClsIdx] = (hv_PerClassNumGt.TupleSelect(hv_ClsIdx)) + hv_CurrentNumGt;
                            if (hv_PerClassNumGtIgnore == null)
                                hv_PerClassNumGtIgnore = new HTuple();
                            hv_PerClassNumGtIgnore[hv_ClsIdx] = (hv_PerClassNumGtIgnore.TupleSelect(
                                hv_ClsIdx)) + hv_CurrentNumGtIgnore;
                            if (hv_PerClassNumPred == null)
                                hv_PerClassNumPred = new HTuple();
                            hv_PerClassNumPred[hv_ClsIdx] = (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) + hv_CurrentNumRes;
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_CurrentClassConfidences.Dispose();
                                HOperatorSet.GetDictTuple(hv_PerClassConfidences, "class_" + (hv_ClassIDs.TupleSelect(
                                    hv_ClsIdx)), out hv_CurrentClassConfidences);
                            }
                            //Confidences are allocated in blocks of AllocationBlockLength. Therefore, we have to check
                            //if the allocated block is long enough, otherwise allocate a new block.
                            if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                new HTuple(hv_CurrentClassConfidences.TupleLength())))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_CurrentClassConfidences = hv_CurrentClassConfidences.TupleConcat(
                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        hv_CurrentClassConfidences.Dispose();
                                        hv_CurrentClassConfidences = ExpTmpLocalVar_CurrentClassConfidences;
                                    }
                                }
                            }
                            if (hv_CurrentClassConfidences == null)
                                hv_CurrentClassConfidences = new HTuple();
                            hv_CurrentClassConfidences[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                hv_ClsIdx)) - 1, 1)] = hv_Confidences.TupleSelect(hv_CurrentResIdxs);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_PerClassConfidences, "class_" + (hv_ClassIDs.TupleSelect(
                                    hv_ClsIdx)), hv_CurrentClassConfidences);
                            }
                            //
                            //Sort the ground truth: Non-ignored instances first.
                            hv_GtSortIdx.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_GtSortIdx = hv_CurrentGtIgnore.TupleSortIndex()
                                    ;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_CurrentGtIgnore = hv_CurrentGtIgnore.TupleSelect(
                                        hv_GtSortIdx);
                                    hv_CurrentGtIgnore.Dispose();
                                    hv_CurrentGtIgnore = ExpTmpLocalVar_CurrentGtIgnore;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_CurrentGtIdxs = hv_CurrentGtIdxs.TupleSelect(
                                        hv_GtSortIdx);
                                    hv_CurrentGtIdxs.Dispose();
                                    hv_CurrentGtIdxs = ExpTmpLocalVar_CurrentGtIdxs;
                                }
                            }
                            //
                            //Get orientations of result and ground truth instances.
                            if ((int)(hv_EvaluateOrientation) != 0)
                            {
                                hv_CurrentResPhis.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentResPhis = hv_ResPhis.TupleSelect(
                                        hv_CurrentResIdxs);
                                }
                                hv_CurrentGtPhis.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentGtPhis = hv_GtPhis.TupleSelect(
                                        hv_CurrentGtIdxs);
                                }
                            }
                            //
                            if ((int)(new HTuple(hv_CurrentNumRes.TupleGreater(0))) != 0)
                            {
                                //Loop over IoU thresholds.
                                for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                    )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                                {
                                    //We check which ground truth and
                                    //result instance can be matched.
                                    hv_GtMatched.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_GtMatched = HTuple.TupleGenConst(
                                            hv_CurrentNumGt, 0);
                                    }
                                    hv_ResMatched.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_ResMatched = HTuple.TupleGenConst(
                                            hv_CurrentNumRes, 0);
                                    }
                                    //
                                    if ((int)(hv_EvaluateOrientation) != 0)
                                    {
                                        //Initialize the absolute orientation difference to -1.
                                        hv_ResAbsOrientationDiff.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_ResAbsOrientationDiff = HTuple.TupleGenConst(
                                                hv_CurrentNumRes, -1);
                                        }
                                    }
                                    //Store which detections should be ignored.
                                    hv_ResIgnore.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_ResIgnore = HTuple.TupleGenConst(
                                            hv_CurrentNumRes, 0);
                                    }
                                    HTuple end_val202 = hv_CurrentNumRes - 1;
                                    HTuple step_val202 = 1;
                                    for (hv_ResIdx = 0; hv_ResIdx.Continue(end_val202, step_val202); hv_ResIdx = hv_ResIdx.TupleAdd(step_val202))
                                    {
                                        //Set the currently best achieved IoU to the IoU threshold and
                                        //initialize the matching index.
                                        hv_CurrentIoU.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_CurrentIoU = ((hv_IoUThresholds.TupleSelect(
                                                hv_ITIdx))).TupleMin2(1 - 1.0e-10);
                                        }
                                        hv_MatchIdx.Dispose();
                                        hv_MatchIdx = -1;
                                        //Loop over ground truth.
                                        HTuple end_val208 = hv_CurrentNumGt - 1;
                                        HTuple step_val208 = 1;
                                        for (hv_GtIdx = 0; hv_GtIdx.Continue(end_val208, step_val208); hv_GtIdx = hv_GtIdx.TupleAdd(step_val208))
                                        {
                                            //Continue if this ground truth has already been matched.
                                            if ((int)(hv_GtMatched.TupleSelect(hv_GtIdx)) != 0)
                                            {
                                                continue;
                                            }
                                            //Stop if matched with non-ignored ground truth and current ground truth is on ignore.
                                            if ((int)(new HTuple(hv_MatchIdx.TupleGreater(-1))) != 0)
                                            {
                                                if ((int)((new HTuple(((hv_CurrentGtIgnore.TupleSelect(hv_MatchIdx))).TupleEqual(
                                                    0))).TupleAnd(new HTuple(((hv_CurrentGtIgnore.TupleSelect(
                                                    hv_GtIdx))).TupleEqual(1)))) != 0)
                                                {
                                                    break;
                                                }
                                            }
                                            //Continue if IoU is not better than a previous match.
                                            if ((int)(new HTuple(((hv_IoUs.TupleSelect(((hv_CurrentGtIdxs.TupleSelect(
                                                hv_GtIdx)) * hv_NumRes) + (hv_CurrentResIdxs.TupleSelect(hv_ResIdx))))).TupleLess(
                                                hv_CurrentIoU))) != 0)
                                            {
                                                continue;
                                            }
                                            //We got a new best match, store it.
                                            hv_CurrentIoU.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_CurrentIoU = hv_IoUs.TupleSelect(
                                                    ((hv_CurrentGtIdxs.TupleSelect(hv_GtIdx)) * hv_NumRes) + (hv_CurrentResIdxs.TupleSelect(
                                                    hv_ResIdx)));
                                            }
                                            hv_MatchIdx.Dispose();
                                            hv_MatchIdx = new HTuple(hv_GtIdx);
                                        }
                                        //If a match has been made we store it for both ground truth and result.
                                        if ((int)(new HTuple(hv_MatchIdx.TupleNotEqual(-1))) != 0)
                                        {
                                            //In COCO they use the IDs of GT and Res, we just use 1
                                            //to indicate the matching, but don't store which one has been matched.
                                            if (hv_ResMatched == null)
                                                hv_ResMatched = new HTuple();
                                            hv_ResMatched[hv_ResIdx] = 1;
                                            if (hv_GtMatched == null)
                                                hv_GtMatched = new HTuple();
                                            hv_GtMatched[hv_MatchIdx] = 1;
                                            if (hv_ResIgnore == null)
                                                hv_ResIgnore = new HTuple();
                                            hv_ResIgnore[hv_ResIdx] = hv_CurrentGtIgnore.TupleSelect(hv_MatchIdx);
                                            //
                                            if ((int)(hv_EvaluateOrientation) != 0)
                                            {
                                                //Set the absolute orientation difference.
                                                if (hv_ResAbsOrientationDiff == null)
                                                    hv_ResAbsOrientationDiff = new HTuple();
                                                hv_ResAbsOrientationDiff[hv_ResIdx] = (((hv_CurrentResPhis.TupleSelect(
                                                    hv_ResIdx)) - (hv_CurrentGtPhis.TupleSelect(hv_MatchIdx)))).TupleAbs()
                                                    ;
                                                if ((int)(new HTuple(((hv_ResAbsOrientationDiff.TupleSelect(
                                                    hv_ResIdx))).TupleGreater((new HTuple(180)).TupleRad()
                                                    ))) != 0)
                                                {
                                                    if (hv_ResAbsOrientationDiff == null)
                                                        hv_ResAbsOrientationDiff = new HTuple();
                                                    hv_ResAbsOrientationDiff[hv_ResIdx] = ((new HTuple(360)).TupleRad()
                                                        ) - (hv_ResAbsOrientationDiff.TupleSelect(hv_ResIdx));
                                                }
                                            }
                                        }
                                    }
                                    //Ignore the unmatched results that are outside of the current area range.
                                    hv_AreaIgnore.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_AreaIgnore = ((hv_CurrentResAreas.TupleLessElem(
                                            hv_MinArea))).TupleOr(hv_CurrentResAreas.TupleGreaterElem(hv_MaxArea));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_ResIgnore = (new HTuple(((hv_ResMatched.TupleEqualElem(
                                                -1))).TupleAnd(hv_AreaIgnore.TupleEqualElem(1)))).TupleOr(hv_ResIgnore);
                                            hv_ResIgnore.Dispose();
                                            hv_ResIgnore = ExpTmpLocalVar_ResIgnore;
                                        }
                                    }
                                    //True positives are the matched results.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUMeasure.Dispose();
                                        HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUMeasure);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerClassMeasures.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "class_" + (hv_ClassIDs.TupleSelect(
                                            hv_ClsIdx)), out hv_PerClassMeasures);
                                    }
                                    hv_CurrentIsTP.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_tp", out hv_CurrentIsTP);
                                    //As for confidences, check if we have to allocate a new block.
                                    if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                        new HTuple(hv_CurrentIsTP.TupleLength())))) != 0)
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_CurrentIsTP = hv_CurrentIsTP.TupleConcat(
                                                    HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                hv_CurrentIsTP.Dispose();
                                                hv_CurrentIsTP = ExpTmpLocalVar_CurrentIsTP;
                                            }
                                        }
                                    }
                                    if (hv_CurrentIsTP == null)
                                        hv_CurrentIsTP = new HTuple();
                                    hv_CurrentIsTP[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                        hv_ClsIdx)) - 1, 1)] = hv_ResMatched;
                                    HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_tp", hv_CurrentIsTP);
                                    //Set the ignored results.
                                    hv_CurrentIgnore.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerClassMeasures, "ignore", out hv_CurrentIgnore);
                                    if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                        new HTuple(hv_CurrentIgnore.TupleLength())))) != 0)
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_CurrentIgnore = hv_CurrentIgnore.TupleConcat(
                                                    HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                hv_CurrentIgnore.Dispose();
                                                hv_CurrentIgnore = ExpTmpLocalVar_CurrentIgnore;
                                            }
                                        }
                                    }
                                    if (hv_CurrentIgnore == null)
                                        hv_CurrentIgnore = new HTuple();
                                    hv_CurrentIgnore[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                        hv_ClsIdx)) - 1, 1)] = hv_ResIgnore;
                                    HOperatorSet.SetDictTuple(hv_PerClassMeasures, "ignore", hv_CurrentIgnore);
                                    //Set the absolute orientation difference.
                                    if ((int)(hv_EvaluateOrientation) != 0)
                                    {
                                        hv_CurrentAbsOrientationDiff.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff",
                                            out hv_CurrentAbsOrientationDiff);
                                        if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                            new HTuple(hv_CurrentAbsOrientationDiff.TupleLength())))) != 0)
                                        {
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                {
                                                    HTuple
                                                      ExpTmpLocalVar_CurrentAbsOrientationDiff = hv_CurrentAbsOrientationDiff.TupleConcat(
                                                        HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                    hv_CurrentAbsOrientationDiff.Dispose();
                                                    hv_CurrentAbsOrientationDiff = ExpTmpLocalVar_CurrentAbsOrientationDiff;
                                                }
                                            }
                                        }
                                        if (hv_CurrentAbsOrientationDiff == null)
                                            hv_CurrentAbsOrientationDiff = new HTuple();
                                        hv_CurrentAbsOrientationDiff[HTuple.TupleGenSequence(hv_OldNumPred,
                                            (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiff;
                                        HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff",
                                            hv_CurrentAbsOrientationDiff);
                                    }
                                    //
                                    //Beginning of detailed evaluation processing (optional).
                                    //
                                    if ((int)(hv_DetailedEvaluation) != 0)
                                    {
                                        //Check if there have been false negatives.
                                        if ((int)(new HTuple(hv_CurrentNumGtNoIgnore.TupleGreater(0))) != 0)
                                        {
                                            hv_GtMatchedNoIgnore.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_GtMatchedNoIgnore = hv_GtMatched.TupleAnd(
                                                    hv_CurrentGtIgnore.TupleNot());
                                            }
                                            if ((int)(new HTuple(((hv_GtMatchedNoIgnore.TupleSum())).TupleLess(
                                                hv_CurrentNumGtNoIgnore))) != 0)
                                            {
                                                if (hv_SampleHasFN == null)
                                                    hv_SampleHasFN = new HTuple();
                                                hv_SampleHasFN[hv_ITIdx] = 1;
                                            }
                                        }
                                        //
                                        //Initialize the detailed running measures.
                                        hv_ResIsFPClass.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_ResIsFPClass = HTuple.TupleGenConst(
                                                hv_CurrentNumRes, -1);
                                        }
                                        hv_ResIsFPBackground.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_ResIsFPBackground = HTuple.TupleGenConst(
                                                hv_CurrentNumRes, 0);
                                        }
                                        hv_ResIsFPLocalization.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_ResIsFPLocalization = HTuple.TupleGenConst(
                                                hv_CurrentNumRes, 0);
                                        }
                                        hv_ResIsFPDuplicate.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_ResIsFPDuplicate = HTuple.TupleGenConst(
                                                hv_CurrentNumRes, 0);
                                        }
                                        hv_ResIsFPMultiple.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_ResIsFPMultiple = HTuple.TupleGenConst(
                                                hv_CurrentNumRes, 0);
                                        }
                                        //
                                        //Initialize detailed running measures for orientation difference.
                                        if ((int)(hv_EvaluateOrientation) != 0)
                                        {
                                            hv_ResAbsOrientationDiffClass.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResAbsOrientationDiffClass = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, -1);
                                            }
                                            hv_ResAbsOrientationDiffLocalization.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResAbsOrientationDiffLocalization = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, -1);
                                            }
                                            hv_ResAbsOrientationDiffDuplicate.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResAbsOrientationDiffDuplicate = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, -1);
                                            }
                                            hv_ResAbsOrientationDiffMultiple.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResAbsOrientationDiffMultiple = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, -1);
                                            }
                                        }
                                        //Check if there have been false positives.
                                        if ((int)(new HTuple(((hv_ResMatched.TupleSum())).TupleLess(hv_CurrentNumRes))) != 0)
                                        {
                                            if (hv_SampleHasFP == null)
                                                hv_SampleHasFP = new HTuple();
                                            hv_SampleHasFP[hv_ITIdx] = 1;
                                            //
                                            //For each false positive, find out what was the reason for being false positive:
                                            hv_FPResIdxsThisClass.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_FPResIdxsThisClass = hv_ResMatched.TupleFind(
                                                    0);
                                            }
                                            hv_FPResIdxsAllResults.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_FPResIdxsAllResults = hv_CurrentResIdxs.TupleSelect(
                                                    hv_FPResIdxsThisClass);
                                            }
                                            hv_GTIdxsNotToIgnore.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_GTIdxsNotToIgnore = hv_GtIgnore.TupleFind(
                                                    0);
                                            }
                                            for (hv_ResIdx = 0; (int)hv_ResIdx <= (int)((new HTuple(hv_FPResIdxsThisClass.TupleLength()
                                                )) - 1); hv_ResIdx = (int)hv_ResIdx + 1)
                                            {
                                                if ((int)(((hv_ResIgnore.TupleSelect(hv_FPResIdxsThisClass.TupleSelect(
                                                    hv_ResIdx)))).TupleNot()) != 0)
                                                {
                                                    if ((int)((new HTuple((new HTuple(hv_GTIdxsNotToIgnore.TupleLength()
                                                        )).TupleEqual(0))).TupleOr(new HTuple(hv_GTIdxsNotToIgnore.TupleEqual(
                                                        -1)))) != 0)
                                                    {
                                                        //No GT instances or all GT instances are ignored.
                                                        //Thus, any detection is a background detection
                                                        hv_MaxIoU.Dispose();
                                                        hv_MaxIoU = 0.0;
                                                    }
                                                    else
                                                    {
                                                        //We have GT instances to consider.
                                                        hv_IoUsWithGT.Dispose();
                                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                        {
                                                            hv_IoUsWithGT = hv_IoUs.TupleSelect(
                                                                (hv_GTIdxsNotToIgnore * hv_NumRes) + (hv_FPResIdxsAllResults.TupleSelect(
                                                                hv_ResIdx)));
                                                        }
                                                        hv_MaxIoU.Dispose();
                                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                        {
                                                            hv_MaxIoU = hv_IoUsWithGT.TupleMax()
                                                                ;
                                                        }
                                                        //It is enough to look for the first occurrence because the IoUs to ground truth should be different.
                                                        hv_MaxIdx.Dispose();
                                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                        {
                                                            hv_MaxIdx = hv_IoUsWithGT.TupleFindFirst(
                                                                hv_MaxIoU);
                                                        }
                                                        hv_GTClassIDMaxIoU.Dispose();
                                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                        {
                                                            hv_GTClassIDMaxIoU = hv_GtClassIDs.TupleSelect(
                                                                hv_GTIdxsNotToIgnore.TupleSelect(hv_MaxIdx));
                                                        }
                                                    }
                                                    if ((int)(hv_EvaluateOrientation.TupleAnd(new HTuple(hv_MaxIoU.TupleGreater(
                                                        0.0)))) != 0)
                                                    {
                                                        //Calculate the absolute orientation difference to the GT instance with maximal IoU.
                                                        hv_AbsOrientationDiff.Dispose();
                                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                        {
                                                            hv_AbsOrientationDiff = (((hv_ResPhis.TupleSelect(
                                                                hv_FPResIdxsAllResults.TupleSelect(hv_ResIdx))) - (hv_GtPhis.TupleSelect(
                                                                hv_GTIdxsNotToIgnore.TupleSelect(hv_MaxIdx))))).TupleAbs()
                                                                ;
                                                        }
                                                        if ((int)(new HTuple(hv_AbsOrientationDiff.TupleGreater(
                                                            (new HTuple(180)).TupleRad()))) != 0)
                                                        {
                                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                            {
                                                                {
                                                                    HTuple
                                                                      ExpTmpLocalVar_AbsOrientationDiff = ((new HTuple(360)).TupleRad()
                                                                        ) - hv_AbsOrientationDiff;
                                                                    hv_AbsOrientationDiff.Dispose();
                                                                    hv_AbsOrientationDiff = ExpTmpLocalVar_AbsOrientationDiff;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    //Determine false positive type.
                                                    if ((int)(new HTuple(hv_MaxIoU.TupleEqual(0.0))) != 0)
                                                    {
                                                        //Background detection. This detection does not overlap to any ground truth (that is not ignored).
                                                        if (hv_ResIsFPBackground == null)
                                                            hv_ResIsFPBackground = new HTuple();
                                                        hv_ResIsFPBackground[hv_FPResIdxsThisClass.TupleSelect(
                                                            hv_ResIdx)] = 1;
                                                    }
                                                    else if ((int)((new HTuple(hv_MaxIoU.TupleGreaterEqual(
                                                        hv_IoUThresholds.TupleSelect(hv_ITIdx)))).TupleAnd(
                                                        new HTuple(hv_CurrentClassID.TupleNotEqual(hv_GTClassIDMaxIoU)))) != 0)
                                                    {
                                                        //False class.
                                                        //Note that this does not necessarily mean that this detection
                                                        //would be a true positive if the class was changed. It could still be a duplicate.
                                                        if (hv_ResIsFPClass == null)
                                                            hv_ResIsFPClass = new HTuple();
                                                        hv_ResIsFPClass[hv_FPResIdxsThisClass.TupleSelect(hv_ResIdx)] = hv_ClassIDToClassIdx.TupleSelect(
                                                            hv_GTClassIDMaxIoU);
                                                        //Store the absolute orientation difference.
                                                        if ((int)(hv_EvaluateOrientation) != 0)
                                                        {
                                                            if (hv_ResAbsOrientationDiffClass == null)
                                                                hv_ResAbsOrientationDiffClass = new HTuple();
                                                            hv_ResAbsOrientationDiffClass[hv_FPResIdxsThisClass.TupleSelect(
                                                                hv_ResIdx)] = hv_AbsOrientationDiff;
                                                        }
                                                    }
                                                    else if ((int)((new HTuple(hv_MaxIoU.TupleGreaterEqual(
                                                        hv_IoUThresholds.TupleSelect(hv_ITIdx)))).TupleAnd(
                                                        new HTuple(hv_CurrentClassID.TupleEqual(hv_GTClassIDMaxIoU)))) != 0)
                                                    {
                                                        //Duplicate detection. There must exist another detection with a higher confidence with the same ground truth.
                                                        if (hv_ResIsFPDuplicate == null)
                                                            hv_ResIsFPDuplicate = new HTuple();
                                                        hv_ResIsFPDuplicate[hv_FPResIdxsThisClass.TupleSelect(
                                                            hv_ResIdx)] = 1;
                                                        //Store the absolute orientation difference.
                                                        if ((int)(hv_EvaluateOrientation) != 0)
                                                        {
                                                            if (hv_ResAbsOrientationDiffDuplicate == null)
                                                                hv_ResAbsOrientationDiffDuplicate = new HTuple();
                                                            hv_ResAbsOrientationDiffDuplicate[hv_FPResIdxsThisClass.TupleSelect(
                                                                hv_ResIdx)] = hv_AbsOrientationDiff;
                                                        }
                                                    }
                                                    else if ((int)((new HTuple(hv_MaxIoU.TupleLess(
                                                        hv_IoUThresholds.TupleSelect(hv_ITIdx)))).TupleAnd(
                                                        new HTuple(hv_CurrentClassID.TupleEqual(hv_GTClassIDMaxIoU)))) != 0)
                                                    {
                                                        //Bad localization. Class is correct, but the IoU is too low.
                                                        if (hv_ResIsFPLocalization == null)
                                                            hv_ResIsFPLocalization = new HTuple();
                                                        hv_ResIsFPLocalization[hv_FPResIdxsThisClass.TupleSelect(
                                                            hv_ResIdx)] = 1;
                                                        //Store the absolute orientation difference.
                                                        if ((int)(hv_EvaluateOrientation) != 0)
                                                        {
                                                            if (hv_ResAbsOrientationDiffLocalization == null)
                                                                hv_ResAbsOrientationDiffLocalization = new HTuple();
                                                            hv_ResAbsOrientationDiffLocalization[hv_FPResIdxsThisClass.TupleSelect(
                                                                hv_ResIdx)] = hv_AbsOrientationDiff;
                                                        }
                                                    }
                                                    else if ((int)((new HTuple(hv_MaxIoU.TupleLess(
                                                        hv_IoUThresholds.TupleSelect(hv_ITIdx)))).TupleAnd(
                                                        new HTuple(hv_CurrentClassID.TupleNotEqual(hv_GTClassIDMaxIoU)))) != 0)
                                                    {
                                                        //Wrong class and bad localization.
                                                        if (hv_ResIsFPMultiple == null)
                                                            hv_ResIsFPMultiple = new HTuple();
                                                        hv_ResIsFPMultiple[hv_FPResIdxsThisClass.TupleSelect(
                                                            hv_ResIdx)] = 1;
                                                        //Store the absolute orientation difference.
                                                        if ((int)(hv_EvaluateOrientation) != 0)
                                                        {
                                                            if (hv_ResAbsOrientationDiffMultiple == null)
                                                                hv_ResAbsOrientationDiffMultiple = new HTuple();
                                                            hv_ResAbsOrientationDiffMultiple[hv_FPResIdxsThisClass.TupleSelect(
                                                                hv_ResIdx)] = hv_AbsOrientationDiff;
                                                        }
                                                    }
                                                    else
                                                    {
                                                        //This case should never occur.
                                                        throw new HalconException("Fatal error during detailed evaluation.");
                                                    }
                                                }
                                            }
                                        }
                                        //
                                        //Overwrite the detailed running measures.
                                        hv_IsFPClass.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_class",
                                            out hv_IsFPClass);
                                        hv_IsFPBackground.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_background",
                                            out hv_IsFPBackground);
                                        hv_IsFPLocalization.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_localization",
                                            out hv_IsFPLocalization);
                                        hv_IsFPDuplicate.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_duplicate",
                                            out hv_IsFPDuplicate);
                                        hv_IsFPMultiple.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_multiple",
                                            out hv_IsFPMultiple);
                                        if ((int)(hv_EvaluateOrientation) != 0)
                                        {
                                            hv_AbsOrientationDiffMultiple.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_multiple",
                                                out hv_AbsOrientationDiffMultiple);
                                            hv_AbsOrientationDiffDuplicate.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_duplicate",
                                                out hv_AbsOrientationDiffDuplicate);
                                            hv_AbsOrientationDiffLocalization.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_localization",
                                                out hv_AbsOrientationDiffLocalization);
                                            hv_AbsOrientationDiffClass.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_class",
                                                out hv_AbsOrientationDiffClass);
                                        }
                                        //Allocate new blocks if necessary (all have the same length).
                                        if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                            new HTuple(hv_IsFPClass.TupleLength())))) != 0)
                                        {
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                {
                                                    HTuple
                                                      ExpTmpLocalVar_IsFPClass = hv_IsFPClass.TupleConcat(
                                                        HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                    hv_IsFPClass.Dispose();
                                                    hv_IsFPClass = ExpTmpLocalVar_IsFPClass;
                                                }
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                {
                                                    HTuple
                                                      ExpTmpLocalVar_IsFPBackground = hv_IsFPBackground.TupleConcat(
                                                        HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                    hv_IsFPBackground.Dispose();
                                                    hv_IsFPBackground = ExpTmpLocalVar_IsFPBackground;
                                                }
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                {
                                                    HTuple
                                                      ExpTmpLocalVar_IsFPLocalization = hv_IsFPLocalization.TupleConcat(
                                                        HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                    hv_IsFPLocalization.Dispose();
                                                    hv_IsFPLocalization = ExpTmpLocalVar_IsFPLocalization;
                                                }
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                {
                                                    HTuple
                                                      ExpTmpLocalVar_IsFPDuplicate = hv_IsFPDuplicate.TupleConcat(
                                                        HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                    hv_IsFPDuplicate.Dispose();
                                                    hv_IsFPDuplicate = ExpTmpLocalVar_IsFPDuplicate;
                                                }
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                {
                                                    HTuple
                                                      ExpTmpLocalVar_IsFPMultiple = hv_IsFPMultiple.TupleConcat(
                                                        HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                    hv_IsFPMultiple.Dispose();
                                                    hv_IsFPMultiple = ExpTmpLocalVar_IsFPMultiple;
                                                }
                                            }
                                            if ((int)(hv_EvaluateOrientation) != 0)
                                            {
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_AbsOrientationDiffMultiple = hv_AbsOrientationDiffMultiple.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_AbsOrientationDiffMultiple.Dispose();
                                                        hv_AbsOrientationDiffMultiple = ExpTmpLocalVar_AbsOrientationDiffMultiple;
                                                    }
                                                }
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_AbsOrientationDiffDuplicate = hv_AbsOrientationDiffDuplicate.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_AbsOrientationDiffDuplicate.Dispose();
                                                        hv_AbsOrientationDiffDuplicate = ExpTmpLocalVar_AbsOrientationDiffDuplicate;
                                                    }
                                                }
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_AbsOrientationDiffLocalization = hv_AbsOrientationDiffLocalization.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_AbsOrientationDiffLocalization.Dispose();
                                                        hv_AbsOrientationDiffLocalization = ExpTmpLocalVar_AbsOrientationDiffLocalization;
                                                    }
                                                }
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_AbsOrientationDiffClass = hv_AbsOrientationDiffClass.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_AbsOrientationDiffClass.Dispose();
                                                        hv_AbsOrientationDiffClass = ExpTmpLocalVar_AbsOrientationDiffClass;
                                                    }
                                                }
                                            }
                                        }
                                        if (hv_IsFPClass == null)
                                            hv_IsFPClass = new HTuple();
                                        hv_IsFPClass[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                            hv_ClsIdx)) - 1, 1)] = hv_ResIsFPClass;
                                        if (hv_IsFPBackground == null)
                                            hv_IsFPBackground = new HTuple();
                                        hv_IsFPBackground[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                            hv_ClsIdx)) - 1, 1)] = hv_ResIsFPBackground;
                                        if (hv_IsFPLocalization == null)
                                            hv_IsFPLocalization = new HTuple();
                                        hv_IsFPLocalization[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                            hv_ClsIdx)) - 1, 1)] = hv_ResIsFPLocalization;
                                        if (hv_IsFPDuplicate == null)
                                            hv_IsFPDuplicate = new HTuple();
                                        hv_IsFPDuplicate[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                            hv_ClsIdx)) - 1, 1)] = hv_ResIsFPDuplicate;
                                        if (hv_IsFPMultiple == null)
                                            hv_IsFPMultiple = new HTuple();
                                        hv_IsFPMultiple[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                            hv_ClsIdx)) - 1, 1)] = hv_ResIsFPMultiple;
                                        if ((int)(hv_EvaluateOrientation) != 0)
                                        {
                                            if (hv_AbsOrientationDiffMultiple == null)
                                                hv_AbsOrientationDiffMultiple = new HTuple();
                                            hv_AbsOrientationDiffMultiple[HTuple.TupleGenSequence(hv_OldNumPred,
                                                (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiffMultiple;
                                            if (hv_AbsOrientationDiffDuplicate == null)
                                                hv_AbsOrientationDiffDuplicate = new HTuple();
                                            hv_AbsOrientationDiffDuplicate[HTuple.TupleGenSequence(hv_OldNumPred,
                                                (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiffDuplicate;
                                            if (hv_AbsOrientationDiffLocalization == null)
                                                hv_AbsOrientationDiffLocalization = new HTuple();
                                            hv_AbsOrientationDiffLocalization[HTuple.TupleGenSequence(hv_OldNumPred,
                                                (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiffLocalization;
                                            if (hv_AbsOrientationDiffClass == null)
                                                hv_AbsOrientationDiffClass = new HTuple();
                                            hv_AbsOrientationDiffClass[HTuple.TupleGenSequence(hv_OldNumPred,
                                                (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiffClass;
                                        }
                                        HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_class",
                                            hv_IsFPClass);
                                        HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_background",
                                            hv_IsFPBackground);
                                        HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_localization",
                                            hv_IsFPLocalization);
                                        HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_duplicate",
                                            hv_IsFPDuplicate);
                                        HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_multiple",
                                            hv_IsFPMultiple);
                                        if ((int)(hv_EvaluateOrientation) != 0)
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_multiple",
                                                hv_AbsOrientationDiffMultiple);
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_duplicate",
                                                hv_AbsOrientationDiffDuplicate);
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_localization",
                                                hv_AbsOrientationDiffLocalization);
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_class",
                                                hv_AbsOrientationDiffClass);
                                        }
                                    }
                                    //
                                    //End of detailed evaluation processing.
                                    //
                                }
                            }
                            else
                            {
                                if ((int)(hv_DetailedEvaluation.TupleAnd(new HTuple(hv_CurrentNumGtNoIgnore.TupleGreater(
                                    0)))) != 0)
                                {
                                    //There are false negatives for this class.
                                    //Loop over IoU thresholds.
                                    for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                        )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                                    {
                                        if (hv_SampleHasFN == null)
                                            hv_SampleHasFN = new HTuple();
                                        hv_SampleHasFN[hv_ITIdx] = 1;
                                    }
                                }
                            }
                        }
                        //Update the confidences, num_gt and num_pred.
                        HOperatorSet.SetDictTuple(hv_AreaRunningMeasures, "num_gt", hv_PerClassNumGt);
                        HOperatorSet.SetDictTuple(hv_AreaRunningMeasures, "num_pred", hv_PerClassNumPred);
                        HOperatorSet.SetDictTuple(hv_AreaRunningMeasures, "confidence", hv_PerClassConfidences);
                        HOperatorSet.SetDictTuple(hv_AreaRunningMeasures, "num_gt_ignore", hv_PerClassNumGtIgnore);
                        //
                        if ((int)(hv_DetailedEvaluation) != 0)
                        {
                            //Set values that are calculated over all classes (for each IoU threshold).
                            for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUMeasure.Dispose();
                                    HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                        hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUMeasure);
                                }
                                //Set image IDs with false negatives
                                if ((int)(hv_SampleHasFN.TupleSelect(hv_ITIdx)) != 0)
                                {
                                    hv_CurrentImageID.Dispose();
                                    HOperatorSet.GetDictTuple(hv_CurrentSample, "image_id", out hv_CurrentImageID);
                                    hv_ImageIDsWithFN.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_negatives",
                                        out hv_ImageIDsWithFN);
                                    hv_NumImageIDsWithFN.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_negatives",
                                        out hv_NumImageIDsWithFN);
                                    //Allocate a new block if necessary.
                                    if ((int)(new HTuple(((hv_NumImageIDsWithFN + 1)).TupleGreater(new HTuple(hv_ImageIDsWithFN.TupleLength()
                                        )))) != 0)
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_ImageIDsWithFN = hv_ImageIDsWithFN.TupleConcat(
                                                    HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                hv_ImageIDsWithFN.Dispose();
                                                hv_ImageIDsWithFN = ExpTmpLocalVar_ImageIDsWithFN;
                                            }
                                        }
                                    }
                                    if (hv_ImageIDsWithFN == null)
                                        hv_ImageIDsWithFN = new HTuple();
                                    hv_ImageIDsWithFN[hv_NumImageIDsWithFN] = hv_CurrentImageID;
                                    HOperatorSet.SetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_negatives",
                                        hv_ImageIDsWithFN);
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_negatives",
                                            hv_NumImageIDsWithFN + 1);
                                    }
                                }
                                if ((int)(hv_SampleHasFP.TupleSelect(hv_ITIdx)) != 0)
                                {
                                    hv_CurrentImageID.Dispose();
                                    HOperatorSet.GetDictTuple(hv_CurrentSample, "image_id", out hv_CurrentImageID);
                                    hv_ImageIDsWithFP.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_positives",
                                        out hv_ImageIDsWithFP);
                                    hv_NumImageIDsWithFP.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_positives",
                                        out hv_NumImageIDsWithFP);
                                    //Allocate a new block if necessary.
                                    if ((int)(new HTuple(((hv_NumImageIDsWithFP + 1)).TupleGreater(new HTuple(hv_ImageIDsWithFP.TupleLength()
                                        )))) != 0)
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_ImageIDsWithFP = hv_ImageIDsWithFP.TupleConcat(
                                                    HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                hv_ImageIDsWithFP.Dispose();
                                                hv_ImageIDsWithFP = ExpTmpLocalVar_ImageIDsWithFP;
                                            }
                                        }
                                    }
                                    if (hv_ImageIDsWithFP == null)
                                        hv_ImageIDsWithFP = new HTuple();
                                    hv_ImageIDsWithFP[hv_NumImageIDsWithFP] = hv_CurrentImageID;
                                    HOperatorSet.SetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_positives",
                                        hv_ImageIDsWithFP);
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_positives",
                                            hv_NumImageIDsWithFP + 1);
                                    }
                                }
                            }
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_CurrentRunningMeasures, "area_" + hv_AreaName,
                            hv_AreaRunningMeasures);
                    }
                }
            }
            //

            hv_MaxNumDetections.Dispose();
            hv_AreaRanges.Dispose();
            hv_IoUThresholds.Dispose();
            hv_InstanceType.Dispose();
            hv_ClassIDs.Dispose();
            hv_NumClasses.Dispose();
            hv_Measures.Dispose();
            hv_AreaNames.Dispose();
            hv_MinAreas.Dispose();
            hv_MaxAreas.Dispose();
            hv_NumAreaRanges.Dispose();
            hv_AllocationBlockLength.Dispose();
            hv_DetailedEvaluation.Dispose();
            hv_KeyExists.Dispose();
            hv_ClassIDToClassIdx.Dispose();
            hv_EvaluateOrientation.Dispose();
            hv_SIdx.Dispose();
            hv_CurrentSample.Dispose();
            hv_CurrentResult.Dispose();
            hv_GtClassIDs.Dispose();
            hv_ResClassIDs.Dispose();
            hv_NumGT.Dispose();
            hv_NumRes.Dispose();
            hv_Confidences.Dispose();
            hv_ResSortIndices.Dispose();
            hv_GtAreas.Dispose();
            hv_ResAreas.Dispose();
            hv_IoUs.Dispose();
            hv_GtPhis.Dispose();
            hv_ResPhis.Dispose();
            hv_MDIdx.Dispose();
            hv_MaxNum.Dispose();
            hv_MaxNumStr.Dispose();
            hv_CurrentRunningMeasures.Dispose();
            hv_AreaIdx.Dispose();
            hv_MinArea.Dispose();
            hv_MaxArea.Dispose();
            hv_AreaName.Dispose();
            hv_AreaRunningMeasures.Dispose();
            hv_GtIgnore.Dispose();
            hv_GtIgnoreInds.Dispose();
            hv_PerClassNumGt.Dispose();
            hv_PerClassNumPred.Dispose();
            hv_PerClassConfidences.Dispose();
            hv_PerClassNumGtIgnore.Dispose();
            hv_SampleHasFP.Dispose();
            hv_SampleHasFN.Dispose();
            hv_ClsIdx.Dispose();
            hv_CurrentClassID.Dispose();
            hv_CurrentGtIdxs.Dispose();
            hv_CurrentNumGt.Dispose();
            hv_CurrentGtIgnore.Dispose();
            hv_CurrentNumGtIgnore.Dispose();
            hv_CurrentNumGtNoIgnore.Dispose();
            hv_CurrentResIdxs.Dispose();
            hv_CurrentNumRes.Dispose();
            hv_CurrentResAreas.Dispose();
            hv_OldNumPred.Dispose();
            hv_CurrentClassConfidences.Dispose();
            hv_GtSortIdx.Dispose();
            hv_CurrentResPhis.Dispose();
            hv_CurrentGtPhis.Dispose();
            hv_ITIdx.Dispose();
            hv_GtMatched.Dispose();
            hv_ResMatched.Dispose();
            hv_ResAbsOrientationDiff.Dispose();
            hv_ResIgnore.Dispose();
            hv_ResIdx.Dispose();
            hv_CurrentIoU.Dispose();
            hv_MatchIdx.Dispose();
            hv_GtIdx.Dispose();
            hv_AreaIgnore.Dispose();
            hv_PerIoUMeasure.Dispose();
            hv_PerClassMeasures.Dispose();
            hv_CurrentIsTP.Dispose();
            hv_CurrentIgnore.Dispose();
            hv_CurrentAbsOrientationDiff.Dispose();
            hv_GtMatchedNoIgnore.Dispose();
            hv_ResIsFPClass.Dispose();
            hv_ResIsFPBackground.Dispose();
            hv_ResIsFPLocalization.Dispose();
            hv_ResIsFPDuplicate.Dispose();
            hv_ResIsFPMultiple.Dispose();
            hv_ResAbsOrientationDiffClass.Dispose();
            hv_ResAbsOrientationDiffLocalization.Dispose();
            hv_ResAbsOrientationDiffDuplicate.Dispose();
            hv_ResAbsOrientationDiffMultiple.Dispose();
            hv_FPResIdxsThisClass.Dispose();
            hv_FPResIdxsAllResults.Dispose();
            hv_GTIdxsNotToIgnore.Dispose();
            hv_MaxIoU.Dispose();
            hv_IoUsWithGT.Dispose();
            hv_MaxIdx.Dispose();
            hv_GTClassIDMaxIoU.Dispose();
            hv_AbsOrientationDiff.Dispose();
            hv_IsFPClass.Dispose();
            hv_IsFPBackground.Dispose();
            hv_IsFPLocalization.Dispose();
            hv_IsFPDuplicate.Dispose();
            hv_IsFPMultiple.Dispose();
            hv_AbsOrientationDiffMultiple.Dispose();
            hv_AbsOrientationDiffDuplicate.Dispose();
            hv_AbsOrientationDiffLocalization.Dispose();
            hv_AbsOrientationDiffClass.Dispose();
            hv_CurrentImageID.Dispose();
            hv_ImageIDsWithFN.Dispose();
            hv_NumImageIDsWithFN.Dispose();
            hv_ImageIDsWithFP.Dispose();
            hv_NumImageIDsWithFP.Dispose();
            hv___Tmp_Ctrl_Dict_Init_0.Dispose();
            hv___Tmp_Ctrl_Dict_Init_1.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_MaxNumDetections.Dispose();
            hv_AreaRanges.Dispose();
            hv_IoUThresholds.Dispose();
            hv_InstanceType.Dispose();
            hv_ClassIDs.Dispose();
            hv_NumClasses.Dispose();
            hv_Measures.Dispose();
            hv_AreaNames.Dispose();
            hv_MinAreas.Dispose();
            hv_MaxAreas.Dispose();
            hv_NumAreaRanges.Dispose();
            hv_AllocationBlockLength.Dispose();
            hv_DetailedEvaluation.Dispose();
            hv_KeyExists.Dispose();
            hv_ClassIDToClassIdx.Dispose();
            hv_EvaluateOrientation.Dispose();
            hv_SIdx.Dispose();
            hv_CurrentSample.Dispose();
            hv_CurrentResult.Dispose();
            hv_GtClassIDs.Dispose();
            hv_ResClassIDs.Dispose();
            hv_NumGT.Dispose();
            hv_NumRes.Dispose();
            hv_Confidences.Dispose();
            hv_ResSortIndices.Dispose();
            hv_GtAreas.Dispose();
            hv_ResAreas.Dispose();
            hv_IoUs.Dispose();
            hv_GtPhis.Dispose();
            hv_ResPhis.Dispose();
            hv_MDIdx.Dispose();
            hv_MaxNum.Dispose();
            hv_MaxNumStr.Dispose();
            hv_CurrentRunningMeasures.Dispose();
            hv_AreaIdx.Dispose();
            hv_MinArea.Dispose();
            hv_MaxArea.Dispose();
            hv_AreaName.Dispose();
            hv_AreaRunningMeasures.Dispose();
            hv_GtIgnore.Dispose();
            hv_GtIgnoreInds.Dispose();
            hv_PerClassNumGt.Dispose();
            hv_PerClassNumPred.Dispose();
            hv_PerClassConfidences.Dispose();
            hv_PerClassNumGtIgnore.Dispose();
            hv_SampleHasFP.Dispose();
            hv_SampleHasFN.Dispose();
            hv_ClsIdx.Dispose();
            hv_CurrentClassID.Dispose();
            hv_CurrentGtIdxs.Dispose();
            hv_CurrentNumGt.Dispose();
            hv_CurrentGtIgnore.Dispose();
            hv_CurrentNumGtIgnore.Dispose();
            hv_CurrentNumGtNoIgnore.Dispose();
            hv_CurrentResIdxs.Dispose();
            hv_CurrentNumRes.Dispose();
            hv_CurrentResAreas.Dispose();
            hv_OldNumPred.Dispose();
            hv_CurrentClassConfidences.Dispose();
            hv_GtSortIdx.Dispose();
            hv_CurrentResPhis.Dispose();
            hv_CurrentGtPhis.Dispose();
            hv_ITIdx.Dispose();
            hv_GtMatched.Dispose();
            hv_ResMatched.Dispose();
            hv_ResAbsOrientationDiff.Dispose();
            hv_ResIgnore.Dispose();
            hv_ResIdx.Dispose();
            hv_CurrentIoU.Dispose();
            hv_MatchIdx.Dispose();
            hv_GtIdx.Dispose();
            hv_AreaIgnore.Dispose();
            hv_PerIoUMeasure.Dispose();
            hv_PerClassMeasures.Dispose();
            hv_CurrentIsTP.Dispose();
            hv_CurrentIgnore.Dispose();
            hv_CurrentAbsOrientationDiff.Dispose();
            hv_GtMatchedNoIgnore.Dispose();
            hv_ResIsFPClass.Dispose();
            hv_ResIsFPBackground.Dispose();
            hv_ResIsFPLocalization.Dispose();
            hv_ResIsFPDuplicate.Dispose();
            hv_ResIsFPMultiple.Dispose();
            hv_ResAbsOrientationDiffClass.Dispose();
            hv_ResAbsOrientationDiffLocalization.Dispose();
            hv_ResAbsOrientationDiffDuplicate.Dispose();
            hv_ResAbsOrientationDiffMultiple.Dispose();
            hv_FPResIdxsThisClass.Dispose();
            hv_FPResIdxsAllResults.Dispose();
            hv_GTIdxsNotToIgnore.Dispose();
            hv_MaxIoU.Dispose();
            hv_IoUsWithGT.Dispose();
            hv_MaxIdx.Dispose();
            hv_GTClassIDMaxIoU.Dispose();
            hv_AbsOrientationDiff.Dispose();
            hv_IsFPClass.Dispose();
            hv_IsFPBackground.Dispose();
            hv_IsFPLocalization.Dispose();
            hv_IsFPDuplicate.Dispose();
            hv_IsFPMultiple.Dispose();
            hv_AbsOrientationDiffMultiple.Dispose();
            hv_AbsOrientationDiffDuplicate.Dispose();
            hv_AbsOrientationDiffLocalization.Dispose();
            hv_AbsOrientationDiffClass.Dispose();
            hv_CurrentImageID.Dispose();
            hv_ImageIDsWithFN.Dispose();
            hv_NumImageIDsWithFN.Dispose();
            hv_ImageIDsWithFP.Dispose();
            hv_NumImageIDsWithFP.Dispose();
            hv___Tmp_Ctrl_Dict_Init_0.Dispose();
            hv___Tmp_Ctrl_Dict_Init_1.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Multi-Label Classification
    // Short Description: Update running measures for a multi-label classification evaluation. 
    private void update_running_multi_label_classification_measures(HTuple hv_Samples,
        HTuple hv_Results, HTuple hv_EvalParams, HTuple hv_RunningMeasures)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_ClassIDs = new HTuple(), hv_MinConfidence = new HTuple();
        HTuple hv_ClassIDToClassIdx = new HTuple(), hv_ImageIDs = new HTuple();
        HTuple hv_CorrectPredictions = new HTuple(), hv_Index = new HTuple();
        HTuple hv_Sample = new HTuple(), hv_ImageID = new HTuple();
        HTuple hv_GtID = new HTuple(), hv_SampleGroundTruth = new HTuple();
        HTuple hv_Result = new HTuple(), hv_PredictionConfidences = new HTuple();
        HTuple hv_ClassIdx = new HTuple(), hv_ClassDict = new HTuple();
        HTuple hv_Confidences = new HTuple(), hv_GroundTruth = new HTuple();
        HTuple hv_Threshold = new HTuple(), hv_IsP = new HTuple();
        HTuple hv_IsTP = new HTuple(), hv_IsFP = new HTuple();
        HTuple hv_IsFN = new HTuple(), hv_TP = new HTuple(), hv_FP = new HTuple();
        HTuple hv_FN = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            //This procedure updates the RunningMeasures for an evaluation for multi-label classification.
            //
            hv_ClassIDs.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
            //Min confidence threshold of model
            hv_MinConfidence.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "min_confidence", out hv_MinConfidence);
            //
            //We need a mapping from class IDs to class indices
            hv_ClassIDToClassIdx.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_ClassIDToClassIdx = HTuple.TupleGenConst(
                    (hv_ClassIDs.TupleMax()) + 1, -1);
            }
            if (hv_ClassIDToClassIdx == null)
                hv_ClassIDToClassIdx = new HTuple();
            hv_ClassIDToClassIdx[hv_ClassIDs] = HTuple.TupleGenSequence(0, (new HTuple(hv_ClassIDs.TupleLength()
                )) - 1, 1);
            //
            //
            //Extend tuples in RunningMeasures with new results.
            hv_ImageIDs.Dispose();
            HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_ids", out hv_ImageIDs);
            hv_CorrectPredictions.Dispose();
            HOperatorSet.GetDictTuple(hv_RunningMeasures, "correct_predictions", out hv_CorrectPredictions);
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Samples.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
            {
                hv_Sample.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Sample = hv_Samples.TupleSelect(
                        hv_Index);
                }
                hv_ImageID.Dispose();
                HOperatorSet.GetDictTuple(hv_Sample, "image_id", out hv_ImageID);
                hv_GtID.Dispose();
                HOperatorSet.GetDictTuple(hv_Sample, "image_label_ids", out hv_GtID);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SampleGroundTruth.Dispose();
                    HOperatorSet.TupleGenConst(new HTuple(hv_ClassIDs.TupleLength()), 0, out hv_SampleGroundTruth);
                }
                if (hv_SampleGroundTruth == null)
                    hv_SampleGroundTruth = new HTuple();
                hv_SampleGroundTruth[hv_ClassIDToClassIdx.TupleSelect(hv_GtID)] = 1;
                hv_Result.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Result = hv_Results.TupleSelect(
                        hv_Index);
                }
                hv_PredictionConfidences.Dispose();
                HOperatorSet.GetDictTuple(hv_Result, "confidences", out hv_PredictionConfidences);
                //
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ImageIDs = hv_ImageIDs.TupleConcat(
                            hv_ImageID);
                        hv_ImageIDs.Dispose();
                        hv_ImageIDs = ExpTmpLocalVar_ImageIDs;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_CorrectPredictions = hv_CorrectPredictions + (new HTuple(((((hv_Sample.TupleGetDictTuple(
                            "image_label_ids"))).TupleSort())).TupleEqual(((hv_Result.TupleGetDictTuple(
                            "selected_class_ids"))).TupleSort())));
                        hv_CorrectPredictions.Dispose();
                        hv_CorrectPredictions = ExpTmpLocalVar_CorrectPredictions;
                    }
                }
                //
                for (hv_ClassIdx = 0; (int)hv_ClassIdx <= (int)((new HTuple(hv_ClassIDs.TupleLength()
                    )) - 1); hv_ClassIdx = (int)hv_ClassIdx + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassDict.Dispose();
                        HOperatorSet.GetDictTuple(hv_RunningMeasures, "class_" + (hv_ClassIDs.TupleSelect(
                            hv_ClassIdx)), out hv_ClassDict);
                    }
                    hv_Confidences.Dispose();
                    HOperatorSet.GetDictTuple(hv_ClassDict, "confidences", out hv_Confidences);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_ClassDict, "confidences", hv_Confidences.TupleConcat(
                            hv_PredictionConfidences.TupleSelect(hv_ClassIdx)));
                    }
                    hv_GroundTruth.Dispose();
                    HOperatorSet.GetDictTuple(hv_ClassDict, "ground_truth", out hv_GroundTruth);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_ClassDict, "ground_truth", hv_GroundTruth.TupleConcat(
                            hv_SampleGroundTruth.TupleSelect(hv_ClassIdx)));
                    }
                    //
                    //Determine TPs, FPs and FNs for model min_confidence
                    hv_Threshold.Dispose();
                    hv_Threshold = new HTuple(hv_MinConfidence);
                    hv_IsP.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IsP = new HTuple(((hv_PredictionConfidences.TupleSelect(
                            hv_ClassIdx))).TupleGreaterEqual(hv_Threshold));
                    }
                    hv_IsTP.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IsTP = hv_IsP.TupleAnd(
                            hv_SampleGroundTruth.TupleSelect(hv_ClassIdx));
                    }
                    hv_IsFP.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IsFP = hv_IsP.TupleAnd(
                            ((hv_SampleGroundTruth.TupleSelect(hv_ClassIdx))).TupleNot());
                    }
                    hv_IsFN.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IsFN = (new HTuple(hv_IsP.TupleNot()
                            )).TupleAnd(hv_SampleGroundTruth.TupleSelect(hv_ClassIdx));
                    }
                    hv_TP.Dispose();
                    HOperatorSet.GetDictTuple(hv_ClassDict, "tp", out hv_TP);
                    hv_FP.Dispose();
                    HOperatorSet.GetDictTuple(hv_ClassDict, "fp", out hv_FP);
                    hv_FN.Dispose();
                    HOperatorSet.GetDictTuple(hv_ClassDict, "fn", out hv_FN);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_ClassDict, "tp", hv_TP + hv_IsTP);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_ClassDict, "fp", hv_FP + hv_IsFP);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_ClassDict, "fn", hv_FN + hv_IsFN);
                    }
                }
            }
            //
            HOperatorSet.SetDictTuple(hv_RunningMeasures, "correct_predictions", hv_CorrectPredictions);
            HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", hv_ImageIDs);
            //

            hv_ClassIDs.Dispose();
            hv_MinConfidence.Dispose();
            hv_ClassIDToClassIdx.Dispose();
            hv_ImageIDs.Dispose();
            hv_CorrectPredictions.Dispose();
            hv_Index.Dispose();
            hv_Sample.Dispose();
            hv_ImageID.Dispose();
            hv_GtID.Dispose();
            hv_SampleGroundTruth.Dispose();
            hv_Result.Dispose();
            hv_PredictionConfidences.Dispose();
            hv_ClassIdx.Dispose();
            hv_ClassDict.Dispose();
            hv_Confidences.Dispose();
            hv_GroundTruth.Dispose();
            hv_Threshold.Dispose();
            hv_IsP.Dispose();
            hv_IsTP.Dispose();
            hv_IsFP.Dispose();
            hv_IsFN.Dispose();
            hv_TP.Dispose();
            hv_FP.Dispose();
            hv_FN.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_ClassIDs.Dispose();
            hv_MinConfidence.Dispose();
            hv_ClassIDToClassIdx.Dispose();
            hv_ImageIDs.Dispose();
            hv_CorrectPredictions.Dispose();
            hv_Index.Dispose();
            hv_Sample.Dispose();
            hv_ImageID.Dispose();
            hv_GtID.Dispose();
            hv_SampleGroundTruth.Dispose();
            hv_Result.Dispose();
            hv_PredictionConfidences.Dispose();
            hv_ClassIdx.Dispose();
            hv_ClassDict.Dispose();
            hv_Confidences.Dispose();
            hv_GroundTruth.Dispose();
            hv_Threshold.Dispose();
            hv_IsP.Dispose();
            hv_IsTP.Dispose();
            hv_IsFP.Dispose();
            hv_IsFN.Dispose();
            hv_TP.Dispose();
            hv_FP.Dispose();
            hv_FN.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: OCR / Deep OCR
    // Short Description: Update running measures for an OCR recognition evaluation. 
    private void update_running_ocr_recognition_measures(HTuple hv_Samples, HTuple hv_Results,
        HTuple hv_EvalParams, HTuple hv_RunningMeasures)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_N = new HTuple(), hv_ImageIDsBatch = new HTuple();
        HTuple hv_WordsPredictionBatch = new HTuple(), hv_WordsGroundTruthBatch = new HTuple();
        HTuple hv_SampleIndex = new HTuple(), hv_Sample = new HTuple();
        HTuple hv_Result = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            //
            //This procedure updates the RunningMeasures for an evaluation for OCR recognition.
            //
            //These measures are stored in the dictionary RunningMeasures and
            //updated by incorporating the Results the model obtained for the Samples.
            //
            //
            hv_N.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_N = new HTuple(hv_Samples.TupleLength()
                    );
            }
            hv_ImageIDsBatch.Dispose();
            HOperatorSet.TupleGenConst(hv_N, 0, out hv_ImageIDsBatch);
            hv_WordsPredictionBatch.Dispose();
            HOperatorSet.TupleGenConst(hv_N, 0, out hv_WordsPredictionBatch);
            hv_WordsGroundTruthBatch.Dispose();
            HOperatorSet.TupleGenConst(hv_N, 0, out hv_WordsGroundTruthBatch);
            //Loop over all samples and update running measures accordingly.
            HTuple end_val12 = hv_N - 1;
            HTuple step_val12 = 1;
            for (hv_SampleIndex = 0; hv_SampleIndex.Continue(end_val12, step_val12); hv_SampleIndex = hv_SampleIndex.TupleAdd(step_val12))
            {
                hv_Sample.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Sample = hv_Samples.TupleSelect(
                        hv_SampleIndex);
                }
                hv_Result.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Result = hv_Results.TupleSelect(
                        hv_SampleIndex);
                }
                if (hv_ImageIDsBatch == null)
                    hv_ImageIDsBatch = new HTuple();
                hv_ImageIDsBatch[hv_SampleIndex] = hv_Sample.TupleGetDictTuple("image_id");
                if (hv_WordsPredictionBatch == null)
                    hv_WordsPredictionBatch = new HTuple();
                hv_WordsPredictionBatch[hv_SampleIndex] = hv_Result.TupleGetDictTuple("word");
                if (hv_WordsGroundTruthBatch == null)
                    hv_WordsGroundTruthBatch = new HTuple();
                hv_WordsGroundTruthBatch[hv_SampleIndex] = hv_Sample.TupleGetDictTuple("word");
            }
            //
            //Update running measures
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", ((hv_RunningMeasures.TupleGetDictTuple(
                    "image_ids"))).TupleConcat(hv_ImageIDsBatch));
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "words_prediction", ((hv_RunningMeasures.TupleGetDictTuple(
                    "words_prediction"))).TupleConcat(hv_WordsPredictionBatch));
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "words_ground_truth", ((hv_RunningMeasures.TupleGetDictTuple(
                    "words_ground_truth"))).TupleConcat(hv_WordsGroundTruthBatch));
            }
            //

            hv_N.Dispose();
            hv_ImageIDsBatch.Dispose();
            hv_WordsPredictionBatch.Dispose();
            hv_WordsGroundTruthBatch.Dispose();
            hv_SampleIndex.Dispose();
            hv_Sample.Dispose();
            hv_Result.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_N.Dispose();
            hv_ImageIDsBatch.Dispose();
            hv_WordsPredictionBatch.Dispose();
            hv_WordsGroundTruthBatch.Dispose();
            hv_SampleIndex.Dispose();
            hv_Sample.Dispose();
            hv_Result.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Classification
    // Short Description: Update running measures for an out-of-distribtuion detection evaluation. 
    private void update_running_ood_detection_measures(HTuple hv_Samples, HTuple hv_Results,
        HTuple hv_EvalParams, HTuple hv_RunningMeasures)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_OODPredictionsID = new HTuple();
        HTuple hv_OODScoresID = new HTuple(), hv_OODPredictionsOOD = new HTuple();
        HTuple hv_OODScoresOOD = new HTuple(), hv_ImageIDsOOD = new HTuple();
        HTuple hv_Index = new HTuple(), hv_Sample = new HTuple();
        HTuple hv_Result = new HTuple(), hv_IsOOD = new HTuple();
        HTuple hv_IsOODExists = new HTuple(), hv___Tmp_Ctrl_Dict_Init_0 = new HTuple();
        HTuple hv___Tmp_Ctrl_Dict_Init_1 = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            //
            //This procedure updates the RunningMeasures for an evaluation
            //for out-of-distribution detection.
            //
            //
            //Collect tuples with new results.
            //The results are stored in different tuples for
            //in-distribution and out-of-distribution samples.
            hv_OODPredictionsID.Dispose();
            hv_OODPredictionsID = new HTuple();
            hv_OODScoresID.Dispose();
            hv_OODScoresID = new HTuple();
            hv_OODPredictionsOOD.Dispose();
            hv_OODPredictionsOOD = new HTuple();
            hv_OODScoresOOD.Dispose();
            hv_OODScoresOOD = new HTuple();
            //For out-of-distribution samples, the image IDs are collected.
            //For in-distribution samples, this has already been done in another procedure.
            hv_ImageIDsOOD.Dispose();
            hv_ImageIDsOOD = new HTuple();
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Samples.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
            {
                hv_Sample.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Sample = hv_Samples.TupleSelect(
                        hv_Index);
                }
                hv_Result.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Result = hv_Results.TupleSelect(
                        hv_Index);
                }
                //
                //OOD samples have an 'is_ood' entry that is set to 'true'.
                hv_IsOOD.Dispose();
                hv_IsOOD = "false";
                hv_IsOODExists.Dispose();
                HOperatorSet.GetDictParam(hv_Sample, "key_exists", "is_ood", out hv_IsOODExists);
                if ((int)(hv_IsOODExists) != 0)
                {
                    hv_IsOOD.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "is_ood", out hv_IsOOD);
                }
                if ((int)(new HTuple(hv_IsOOD.TupleEqual("true"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_OODScoresOOD = hv_OODScoresOOD.TupleConcat(
                                hv_Result.TupleGetDictTuple("ood_score"));
                            hv_OODScoresOOD.Dispose();
                            hv_OODScoresOOD = ExpTmpLocalVar_OODScoresOOD;
                        }
                    }
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_0);
                    HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_0, "comp", "true");
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_OODPredictionsOOD = hv_OODPredictionsOOD.TupleConcat(
                                ((hv_Result.TupleConcat(hv___Tmp_Ctrl_Dict_Init_0))).TupleTestEqualDictItem(
                                "ood_result", "comp"));
                            hv_OODPredictionsOOD.Dispose();
                            hv_OODPredictionsOOD = ExpTmpLocalVar_OODPredictionsOOD;
                        }
                    }
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv___Tmp_Ctrl_Dict_Init_0 = HTuple.TupleConstant(
                            "HNULL");
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ImageIDsOOD = hv_ImageIDsOOD.TupleConcat(
                                hv_Sample.TupleGetDictTuple("image_id"));
                            hv_ImageIDsOOD.Dispose();
                            hv_ImageIDsOOD = ExpTmpLocalVar_ImageIDsOOD;
                        }
                    }
                }
                else if ((int)(new HTuple(hv_IsOOD.TupleEqual("false"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_OODScoresID = hv_OODScoresID.TupleConcat(
                                hv_Result.TupleGetDictTuple("ood_score"));
                            hv_OODScoresID.Dispose();
                            hv_OODScoresID = ExpTmpLocalVar_OODScoresID;
                        }
                    }
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                    HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_1);
                    HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_1, "comp", "true");
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_OODPredictionsID = hv_OODPredictionsID.TupleConcat(
                                ((hv_Result.TupleConcat(hv___Tmp_Ctrl_Dict_Init_1))).TupleTestEqualDictItem(
                                "ood_result", "comp"));
                            hv_OODPredictionsID.Dispose();
                            hv_OODPredictionsID = ExpTmpLocalVar_OODPredictionsID;
                        }
                    }
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv___Tmp_Ctrl_Dict_Init_1 = HTuple.TupleConstant(
                            "HNULL");
                    }
                }
                else
                {
                    throw new HalconException("Invalid sample entry for 'is_ood': " + hv_IsOOD);
                }
            }
            //
            //Extend the tuples in RunningMeasures with the new results.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "ood_predictions", ((hv_RunningMeasures.TupleGetDictTuple(
                    "ood_predictions"))).TupleConcat(hv_OODPredictionsID));
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "ood_scores", ((hv_RunningMeasures.TupleGetDictTuple(
                    "ood_scores"))).TupleConcat(hv_OODScoresID));
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                HOperatorSet.SetDictTuple(hv_RunningMeasures.TupleGetDictTuple("evaluated_ood_samples"),
                    "ood_predictions", ((((hv_RunningMeasures.TupleGetDictTuple("evaluated_ood_samples"))).TupleGetDictTuple(
                    "ood_predictions"))).TupleConcat(hv_OODPredictionsOOD));
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                HOperatorSet.SetDictTuple(hv_RunningMeasures.TupleGetDictTuple("evaluated_ood_samples"),
                    "ood_scores", ((((hv_RunningMeasures.TupleGetDictTuple("evaluated_ood_samples"))).TupleGetDictTuple(
                    "ood_scores"))).TupleConcat(hv_OODScoresOOD));
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                HOperatorSet.SetDictTuple(hv_RunningMeasures.TupleGetDictTuple("evaluated_ood_samples"),
                    "image_ids", ((((hv_RunningMeasures.TupleGetDictTuple("evaluated_ood_samples"))).TupleGetDictTuple(
                    "image_ids"))).TupleConcat(hv_ImageIDsOOD));
            }
            //

            hv_OODPredictionsID.Dispose();
            hv_OODScoresID.Dispose();
            hv_OODPredictionsOOD.Dispose();
            hv_OODScoresOOD.Dispose();
            hv_ImageIDsOOD.Dispose();
            hv_Index.Dispose();
            hv_Sample.Dispose();
            hv_Result.Dispose();
            hv_IsOOD.Dispose();
            hv_IsOODExists.Dispose();
            hv___Tmp_Ctrl_Dict_Init_0.Dispose();
            hv___Tmp_Ctrl_Dict_Init_1.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_OODPredictionsID.Dispose();
            hv_OODScoresID.Dispose();
            hv_OODPredictionsOOD.Dispose();
            hv_OODScoresOOD.Dispose();
            hv_ImageIDsOOD.Dispose();
            hv_Index.Dispose();
            hv_Sample.Dispose();
            hv_Result.Dispose();
            hv_IsOOD.Dispose();
            hv_IsOODExists.Dispose();
            hv___Tmp_Ctrl_Dict_Init_0.Dispose();
            hv___Tmp_Ctrl_Dict_Init_1.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
    // Short Description: Update running measures for a pixel-based evaluation. 
    private void update_running_pixel_measures(HTuple hv_Samples, HTuple hv_Results,
        HTuple hv_EvalParams, HTuple hv_RunningMeasures)
    {



        // Stack for temporary objects 
        HObject[] OTemp = new HObject[20];

        // Local iconic variables 

        HObject ho_Annot = null, ho_Result = null, ho_ClsIgnore = null;
        HObject ho_ClsIgnoreTmp = null, ho_ClsAnnot = null, ho_ClsResult = null;
        HObject ho_TPReg = null, ho_FPReg = null, ho_FNReg = null;

        // Local control variables 

        HTuple hv_EvaluationType = new HTuple(), hv_Measures = new HTuple();
        HTuple hv_PixelMeasures = new HTuple(), hv_ClassIDs = new HTuple();
        HTuple hv_NumClasses = new HTuple(), hv_IgnoreClassIDs = new HTuple();
        HTuple hv_CalcConfMatrix = new HTuple(), hv_SegmentationImageExists = new HTuple();
        HTuple hv_GrippingMapExists = new HTuple(), hv_ResultKey = new HTuple();
        HTuple hv_ClassIDsResult = new HTuple(), hv_ConfMatrix = new HTuple();
        HTuple hv_MapClassIDs = new HTuple(), hv_ClsIdToClsIdx = new HTuple();
        HTuple hv_TP = new HTuple(), hv_FP = new HTuple(), hv_FN = new HTuple();
        HTuple hv_SampleIndex = new HTuple(), hv_Rows = new HTuple();
        HTuple hv_Columns = new HTuple(), hv_AnnotVals = new HTuple();
        HTuple hv_ResultVals = new HTuple(), hv_ConfTuple = new HTuple();
        HTuple hv_ConfHist = new HTuple(), hv_BinSize = new HTuple();
        HTuple hv_ConfMatrixTmp = new HTuple(), hv_IgnoreIndex = new HTuple();
        HTuple hv_ClsIndex = new HTuple(), hv_ClsId = new HTuple();
        HTuple hv_ClsIdRes = new HTuple(), hv_ClsTP = new HTuple();
        HTuple hv_ClsFP = new HTuple(), hv_ClsFN = new HTuple();
        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Annot);
        HOperatorSet.GenEmptyObj(out ho_Result);
        HOperatorSet.GenEmptyObj(out ho_ClsIgnore);
        HOperatorSet.GenEmptyObj(out ho_ClsIgnoreTmp);
        HOperatorSet.GenEmptyObj(out ho_ClsAnnot);
        HOperatorSet.GenEmptyObj(out ho_ClsResult);
        HOperatorSet.GenEmptyObj(out ho_TPReg);
        HOperatorSet.GenEmptyObj(out ho_FPReg);
        HOperatorSet.GenEmptyObj(out ho_FNReg);
        try
        {
            //
            //This procedure updates the RunningMeasures for a pixel-
            //based evaluation for segmentation or 3D Gripping Point
            //Detection. These measures are stored in the dictionary
            //RunningMeasures and updated by incorporating the Results
            //the model obtained for the Samples.
            //
            //Get evaluation type.
            hv_EvaluationType.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
            //Get evaluation measures.
            hv_Measures.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
            //Check if any pixel measures are requested.
            hv_PixelMeasures.Dispose();
            get_requested_pixel_measures(hv_Measures, hv_EvaluationType, out hv_PixelMeasures);
            if ((int)(new HTuple((new HTuple(hv_PixelMeasures.TupleLength())).TupleEqual(
                0))) != 0)
            {
                ho_Annot.Dispose();
                ho_Result.Dispose();
                ho_ClsIgnore.Dispose();
                ho_ClsIgnoreTmp.Dispose();
                ho_ClsAnnot.Dispose();
                ho_ClsResult.Dispose();
                ho_TPReg.Dispose();
                ho_FPReg.Dispose();
                ho_FNReg.Dispose();

                hv_EvaluationType.Dispose();
                hv_Measures.Dispose();
                hv_PixelMeasures.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClasses.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_CalcConfMatrix.Dispose();
                hv_SegmentationImageExists.Dispose();
                hv_GrippingMapExists.Dispose();
                hv_ResultKey.Dispose();
                hv_ClassIDsResult.Dispose();
                hv_ConfMatrix.Dispose();
                hv_MapClassIDs.Dispose();
                hv_ClsIdToClsIdx.Dispose();
                hv_TP.Dispose();
                hv_FP.Dispose();
                hv_FN.Dispose();
                hv_SampleIndex.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_AnnotVals.Dispose();
                hv_ResultVals.Dispose();
                hv_ConfTuple.Dispose();
                hv_ConfHist.Dispose();
                hv_BinSize.Dispose();
                hv_ConfMatrixTmp.Dispose();
                hv_IgnoreIndex.Dispose();
                hv_ClsIndex.Dispose();
                hv_ClsId.Dispose();
                hv_ClsIdRes.Dispose();
                hv_ClsTP.Dispose();
                hv_ClsFP.Dispose();
                hv_ClsFN.Dispose();

                return;
            }
            //
            //Get the class IDs.
            hv_ClassIDs.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
            //Get the number of classes.
            hv_NumClasses.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
            //Get the ignore class IDs.
            hv_IgnoreClassIDs.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "ignore_class_ids", out hv_IgnoreClassIDs);
            //
            //Check if we need to compute/update the confusion matrix.
            hv_CalcConfMatrix.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_CalcConfMatrix = new HTuple(((hv_PixelMeasures.TupleFind(
                    "pixel_confusion_matrix"))).TupleGreater(-1));
            }
            //
            //Check and set result type and class IDs.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_SegmentationImageExists.Dispose();
                HOperatorSet.GetDictParam(hv_Results.TupleSelect(0), "key_exists", "segmentation_image",
                    out hv_SegmentationImageExists);
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_GrippingMapExists.Dispose();
                HOperatorSet.GetDictParam(hv_Results.TupleSelect(0), "key_exists", "gripping_map",
                    out hv_GrippingMapExists);
            }
            if ((int)(hv_SegmentationImageExists) != 0)
            {
                hv_ResultKey.Dispose();
                hv_ResultKey = "segmentation_image";
                //Class IDs in the result are the same as in the ground truth.
                hv_ClassIDsResult.Dispose();
                hv_ClassIDsResult = new HTuple(hv_ClassIDs);
            }
            else if ((int)(hv_GrippingMapExists) != 0)
            {
                hv_ResultKey.Dispose();
                hv_ResultKey = "gripping_map";
                //Since the result is a binary gripping map, the class ID
                //is always 1.
                hv_ClassIDsResult.Dispose();
                hv_ClassIDsResult = 1;
            }
            else
            {
                throw new HalconException("No result available for evaluation");
            }
            //
            if ((int)(hv_CalcConfMatrix) != 0)
            {
                //Get the current confusion matrix.
                hv_ConfMatrix.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix", out hv_ConfMatrix);
                //Check if we need to map the class IDs.
                hv_MapClassIDs.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_id_mapping",
                    out hv_MapClassIDs);
                if ((int)(hv_MapClassIDs) != 0)
                {
                    hv_ClsIdToClsIdx.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_id_mapping", out hv_ClsIdToClsIdx);
                    hv_NumClasses.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumClasses = (hv_ClsIdToClsIdx.TupleMax()
                            ) + 1;
                    }
                }
            }
            else
            {
                //Get the tuples for TP/FP/FN
                hv_TP.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "tp", out hv_TP);
                hv_FP.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "fp", out hv_FP);
                hv_FN.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "fn", out hv_FN);
            }
            //
            //Loop over images, i.e. sample dictionaries.
            for (hv_SampleIndex = 0; (int)hv_SampleIndex <= (int)((new HTuple(hv_Samples.TupleLength()
                )) - 1); hv_SampleIndex = (int)hv_SampleIndex + 1)
            {
                //Get annotation.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_Annot.Dispose();
                    HOperatorSet.GetDictObject(out ho_Annot, hv_Samples.TupleSelect(hv_SampleIndex),
                        "segmentation_image");
                }
                //Get result.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_Result.Dispose();
                    HOperatorSet.GetDictObject(out ho_Result, hv_Results.TupleSelect(hv_SampleIndex),
                        hv_ResultKey);
                }
                //
                //Update the measures.
                if ((int)(hv_CalcConfMatrix) != 0)
                {
                    //Get the ground truth and predicted class IDs of all pixels.
                    hv_Rows.Dispose(); hv_Columns.Dispose();
                    HOperatorSet.GetRegionPoints(ho_Annot, out hv_Rows, out hv_Columns);
                    hv_AnnotVals.Dispose();
                    HOperatorSet.GetGrayval(ho_Annot, hv_Rows, hv_Columns, out hv_AnnotVals);
                    hv_ResultVals.Dispose();
                    HOperatorSet.GetGrayval(ho_Result, hv_Rows, hv_Columns, out hv_ResultVals);
                    //Map the class IDs to class indices.
                    if ((int)(hv_MapClassIDs) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_AnnotVals = hv_ClsIdToClsIdx.TupleSelect(
                                    hv_AnnotVals);
                                hv_AnnotVals.Dispose();
                                hv_AnnotVals = ExpTmpLocalVar_AnnotVals;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ResultVals = hv_ClsIdToClsIdx.TupleSelect(
                                    hv_ResultVals);
                                hv_ResultVals.Dispose();
                                hv_ResultVals = ExpTmpLocalVar_ResultVals;
                            }
                        }
                    }
                    //The ground truth and predicted IDs are accumulated
                    //such that each confusion pair (class_i <-> class_j) gets a unique value.
                    hv_ConfTuple.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ConfTuple = (hv_NumClasses * hv_AnnotVals) + hv_ResultVals;
                    }
                    //Compute the histogram of this confusion tuple.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ConfHist.Dispose(); hv_BinSize.Dispose();
                        HOperatorSet.TupleHistoRange(hv_ConfTuple, 0, (hv_NumClasses * hv_NumClasses) - 1,
                            hv_NumClasses * hv_NumClasses, out hv_ConfHist, out hv_BinSize);
                    }
                    hv_ConfMatrixTmp.Dispose();
                    HOperatorSet.CreateMatrix(hv_NumClasses, hv_NumClasses, hv_ConfHist, out hv_ConfMatrixTmp);
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.TransposeMatrix(hv_ConfMatrixTmp, out ExpTmpOutVar_0);
                        hv_ConfMatrixTmp.Dispose();
                        hv_ConfMatrixTmp = ExpTmpOutVar_0;
                    }
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.AddMatrix(hv_ConfMatrix, hv_ConfMatrixTmp, out ExpTmpOutVar_0);
                        hv_ConfMatrix.Dispose();
                        hv_ConfMatrix = ExpTmpOutVar_0;
                    }
                }
                else
                {
                    //Get the ignore region.
                    ho_ClsIgnore.Dispose();
                    HOperatorSet.GenEmptyRegion(out ho_ClsIgnore);
                    for (hv_IgnoreIndex = 0; (int)hv_IgnoreIndex <= (int)((new HTuple(hv_IgnoreClassIDs.TupleLength()
                        )) - 1); hv_IgnoreIndex = (int)hv_IgnoreIndex + 1)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_ClsIgnoreTmp.Dispose();
                            HOperatorSet.Threshold(ho_Annot, out ho_ClsIgnoreTmp, hv_IgnoreClassIDs.TupleSelect(
                                hv_IgnoreIndex), hv_IgnoreClassIDs.TupleSelect(hv_IgnoreIndex));
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.Union2(ho_ClsIgnore, ho_ClsIgnoreTmp, out ExpTmpOutVar_0
                                );
                            ho_ClsIgnore.Dispose();
                            ho_ClsIgnore = ExpTmpOutVar_0;
                        }
                    }
                    //
                    //Go through model classes.
                    for (hv_ClsIndex = 0; (int)hv_ClsIndex <= (int)((new HTuple(hv_ClassIDs.TupleLength()
                        )) - 1); hv_ClsIndex = (int)hv_ClsIndex + 1)
                    {
                        hv_ClsId.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClsId = hv_ClassIDs.TupleSelect(
                                hv_ClsIndex);
                        }
                        hv_ClsIdRes.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClsIdRes = hv_ClassIDsResult.TupleSelect(
                                hv_ClsIndex);
                        }
                        //Get the annotated region for this class.
                        ho_ClsAnnot.Dispose();
                        HOperatorSet.Threshold(ho_Annot, out ho_ClsAnnot, hv_ClsId, hv_ClsId);
                        //Get the result region for this class.
                        ho_ClsResult.Dispose();
                        HOperatorSet.Threshold(ho_Result, out ho_ClsResult, hv_ClsIdRes, hv_ClsIdRes);
                        //The pixels in the ignore region should not be considered.
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.Difference(ho_ClsResult, ho_ClsIgnore, out ExpTmpOutVar_0
                                );
                            ho_ClsResult.Dispose();
                            ho_ClsResult = ExpTmpOutVar_0;
                        }
                        //Get TP/FP/FN.
                        ho_TPReg.Dispose();
                        HOperatorSet.Intersection(ho_ClsAnnot, ho_ClsResult, out ho_TPReg);
                        ho_FPReg.Dispose();
                        HOperatorSet.Difference(ho_ClsResult, ho_ClsAnnot, out ho_FPReg);
                        //We define false negatives as pixels that have been labeled as this class,
                        //but not been correctly predicted.
                        ho_FNReg.Dispose();
                        HOperatorSet.Difference(ho_ClsAnnot, ho_ClsResult, out ho_FNReg);
                        //Get corresponding pixel numbers and update.
                        hv_ClsTP.Dispose();
                        HOperatorSet.RegionFeatures(ho_TPReg, "area", out hv_ClsTP);
                        hv_ClsFP.Dispose();
                        HOperatorSet.RegionFeatures(ho_FPReg, "area", out hv_ClsFP);
                        hv_ClsFN.Dispose();
                        HOperatorSet.RegionFeatures(ho_FNReg, "area", out hv_ClsFN);
                        if (hv_TP == null)
                            hv_TP = new HTuple();
                        hv_TP[hv_ClsIndex] = (hv_TP.TupleSelect(hv_ClsIndex)) + hv_ClsTP;
                        if (hv_FP == null)
                            hv_FP = new HTuple();
                        hv_FP[hv_ClsIndex] = (hv_FP.TupleSelect(hv_ClsIndex)) + hv_ClsFP;
                        if (hv_FN == null)
                            hv_FN = new HTuple();
                        hv_FN[hv_ClsIndex] = (hv_FN.TupleSelect(hv_ClsIndex)) + hv_ClsFN;
                    }
                }
            }
            //
            //Update running measures.
            if ((int)(hv_CalcConfMatrix) != 0)
            {
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix", hv_ConfMatrix);
            }
            else
            {
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "tp", hv_TP);
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "fp", hv_FP);
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "fn", hv_FN);
            }
            //
            ho_Annot.Dispose();
            ho_Result.Dispose();
            ho_ClsIgnore.Dispose();
            ho_ClsIgnoreTmp.Dispose();
            ho_ClsAnnot.Dispose();
            ho_ClsResult.Dispose();
            ho_TPReg.Dispose();
            ho_FPReg.Dispose();
            ho_FNReg.Dispose();

            hv_EvaluationType.Dispose();
            hv_Measures.Dispose();
            hv_PixelMeasures.Dispose();
            hv_ClassIDs.Dispose();
            hv_NumClasses.Dispose();
            hv_IgnoreClassIDs.Dispose();
            hv_CalcConfMatrix.Dispose();
            hv_SegmentationImageExists.Dispose();
            hv_GrippingMapExists.Dispose();
            hv_ResultKey.Dispose();
            hv_ClassIDsResult.Dispose();
            hv_ConfMatrix.Dispose();
            hv_MapClassIDs.Dispose();
            hv_ClsIdToClsIdx.Dispose();
            hv_TP.Dispose();
            hv_FP.Dispose();
            hv_FN.Dispose();
            hv_SampleIndex.Dispose();
            hv_Rows.Dispose();
            hv_Columns.Dispose();
            hv_AnnotVals.Dispose();
            hv_ResultVals.Dispose();
            hv_ConfTuple.Dispose();
            hv_ConfHist.Dispose();
            hv_BinSize.Dispose();
            hv_ConfMatrixTmp.Dispose();
            hv_IgnoreIndex.Dispose();
            hv_ClsIndex.Dispose();
            hv_ClsId.Dispose();
            hv_ClsIdRes.Dispose();
            hv_ClsTP.Dispose();
            hv_ClsFP.Dispose();
            hv_ClsFN.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_Annot.Dispose();
            ho_Result.Dispose();
            ho_ClsIgnore.Dispose();
            ho_ClsIgnoreTmp.Dispose();
            ho_ClsAnnot.Dispose();
            ho_ClsResult.Dispose();
            ho_TPReg.Dispose();
            ho_FPReg.Dispose();
            ho_FNReg.Dispose();

            hv_EvaluationType.Dispose();
            hv_Measures.Dispose();
            hv_PixelMeasures.Dispose();
            hv_ClassIDs.Dispose();
            hv_NumClasses.Dispose();
            hv_IgnoreClassIDs.Dispose();
            hv_CalcConfMatrix.Dispose();
            hv_SegmentationImageExists.Dispose();
            hv_GrippingMapExists.Dispose();
            hv_ResultKey.Dispose();
            hv_ClassIDsResult.Dispose();
            hv_ConfMatrix.Dispose();
            hv_MapClassIDs.Dispose();
            hv_ClsIdToClsIdx.Dispose();
            hv_TP.Dispose();
            hv_FP.Dispose();
            hv_FN.Dispose();
            hv_SampleIndex.Dispose();
            hv_Rows.Dispose();
            hv_Columns.Dispose();
            hv_AnnotVals.Dispose();
            hv_ResultVals.Dispose();
            hv_ConfTuple.Dispose();
            hv_ConfHist.Dispose();
            hv_BinSize.Dispose();
            hv_ConfMatrixTmp.Dispose();
            hv_IgnoreIndex.Dispose();
            hv_ClsIndex.Dispose();
            hv_ClsId.Dispose();
            hv_ClsIdRes.Dispose();
            hv_ClsTP.Dispose();
            hv_ClsFP.Dispose();
            hv_ClsFN.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Model
    // Short Description: Update running measures for a region-based evaluation. 
    private void update_running_region_measures(HTuple hv_Samples, HTuple hv_Results,
        HTuple hv_EvalParams, HTuple hv_RunningMeasures)
    {



        // Stack for temporary objects 
        HObject[] OTemp = new HObject[20];

        // Local iconic variables 

        HObject ho_Annot = null, ho_Result = null, ho_ClsAnnot = null;
        HObject ho_ClsResult = null, ho_ClsAnnotConnected = null, ho_ClsAnnotSelected = null;
        HObject ho_RegionIntersection = null;

        // Local control variables 

        HTuple hv_Measures = new HTuple(), hv_CalcRegionMeasures = new HTuple();
        HTuple hv_ClassIDs = new HTuple(), hv_GrippingMapExists = new HTuple();
        HTuple hv_ResultKey = new HTuple(), hv_ClassIDsResult = new HTuple();
        HTuple hv_SampleIndex = new HTuple(), hv_ClsIndex = new HTuple();
        HTuple hv_ClsId = new HTuple(), hv_ClsIdRes = new HTuple();
        HTuple hv_NumRegions = new HTuple(), hv_RegionIndex = new HTuple();
        HTuple hv_AreaIntersection = new HTuple(), hv_AreaGroundtruth = new HTuple();
        HTuple hv_RegionOverlap = new HTuple();
        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Annot);
        HOperatorSet.GenEmptyObj(out ho_Result);
        HOperatorSet.GenEmptyObj(out ho_ClsAnnot);
        HOperatorSet.GenEmptyObj(out ho_ClsResult);
        HOperatorSet.GenEmptyObj(out ho_ClsAnnotConnected);
        HOperatorSet.GenEmptyObj(out ho_ClsAnnotSelected);
        HOperatorSet.GenEmptyObj(out ho_RegionIntersection);
        try
        {
            //
            //This procedure updates the RunningMeasures for a region-
            //based evaluation for 3D Gripping Point Detection.
            //These measures are stored in the dictionary RunningMeasures
            //and updated by incorporating the Results the model obtained
            //for the Samples.
            //
            //Check if we need to compute any region measures.
            hv_Measures.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
            hv_CalcRegionMeasures.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_CalcRegionMeasures = (new HTuple(((hv_Measures.TupleFind(
                    "mean_pro"))).TupleGreater(-1))).TupleOr(new HTuple(((hv_Measures.TupleFind(
                    "all"))).TupleGreater(-1)));
            }
            if ((int)(hv_CalcRegionMeasures.TupleNot()) != 0)
            {
                ho_Annot.Dispose();
                ho_Result.Dispose();
                ho_ClsAnnot.Dispose();
                ho_ClsResult.Dispose();
                ho_ClsAnnotConnected.Dispose();
                ho_ClsAnnotSelected.Dispose();
                ho_RegionIntersection.Dispose();

                hv_Measures.Dispose();
                hv_CalcRegionMeasures.Dispose();
                hv_ClassIDs.Dispose();
                hv_GrippingMapExists.Dispose();
                hv_ResultKey.Dispose();
                hv_ClassIDsResult.Dispose();
                hv_SampleIndex.Dispose();
                hv_ClsIndex.Dispose();
                hv_ClsId.Dispose();
                hv_ClsIdRes.Dispose();
                hv_NumRegions.Dispose();
                hv_RegionIndex.Dispose();
                hv_AreaIntersection.Dispose();
                hv_AreaGroundtruth.Dispose();
                hv_RegionOverlap.Dispose();

                return;
            }
            //
            //Get the class IDs.
            hv_ClassIDs.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
            //
            //Check and set result type and class IDs.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_GrippingMapExists.Dispose();
                HOperatorSet.GetDictParam(hv_Results.TupleSelect(0), "key_exists", "gripping_map",
                    out hv_GrippingMapExists);
            }
            if ((int)(hv_GrippingMapExists) != 0)
            {
                hv_ResultKey.Dispose();
                hv_ResultKey = "gripping_map";
                //Since the result is a binary gripping map, the class ID
                //is always 1.
                hv_ClassIDsResult.Dispose();
                hv_ClassIDsResult = 1;
            }
            else
            {
                throw new HalconException("No result available for evaluation");
            }
            //
            //Loop over images, i.e. sample dictionaries.
            for (hv_SampleIndex = 0; (int)hv_SampleIndex <= (int)((new HTuple(hv_Samples.TupleLength()
                )) - 1); hv_SampleIndex = (int)hv_SampleIndex + 1)
            {
                //Get annotation.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_Annot.Dispose();
                    HOperatorSet.GetDictObject(out ho_Annot, hv_Samples.TupleSelect(hv_SampleIndex),
                        "segmentation_image");
                }
                //Get result.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_Result.Dispose();
                    HOperatorSet.GetDictObject(out ho_Result, hv_Results.TupleSelect(hv_SampleIndex),
                        hv_ResultKey);
                }
                //
                //Go through model classes.
                for (hv_ClsIndex = 0; (int)hv_ClsIndex <= (int)((new HTuple(hv_ClassIDs.TupleLength()
                    )) - 1); hv_ClsIndex = (int)hv_ClsIndex + 1)
                {
                    hv_ClsId.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClsId = hv_ClassIDs.TupleSelect(
                            hv_ClsIndex);
                    }
                    hv_ClsIdRes.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClsIdRes = hv_ClassIDsResult.TupleSelect(
                            hv_ClsIndex);
                    }
                    //Get the annotated region for this class.
                    ho_ClsAnnot.Dispose();
                    HOperatorSet.Threshold(ho_Annot, out ho_ClsAnnot, hv_ClsId, hv_ClsId);
                    //Get the result region for this class.
                    ho_ClsResult.Dispose();
                    HOperatorSet.Threshold(ho_Result, out ho_ClsResult, hv_ClsIdRes, hv_ClsIdRes);
                    //
                    ho_ClsAnnotConnected.Dispose();
                    HOperatorSet.Connection(ho_ClsAnnot, out ho_ClsAnnotConnected);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.SelectShape(ho_ClsAnnotConnected, out ExpTmpOutVar_0, "area",
                            "and", 1, "max");
                        ho_ClsAnnotConnected.Dispose();
                        ho_ClsAnnotConnected = ExpTmpOutVar_0;
                    }
                    hv_NumRegions.Dispose();
                    HOperatorSet.CountObj(ho_ClsAnnotConnected, out hv_NumRegions);
                    HTuple end_val47 = hv_NumRegions;
                    HTuple step_val47 = 1;
                    for (hv_RegionIndex = 1; hv_RegionIndex.Continue(end_val47, step_val47); hv_RegionIndex = hv_RegionIndex.TupleAdd(step_val47))
                    {
                        ho_ClsAnnotSelected.Dispose();
                        HOperatorSet.SelectObj(ho_ClsAnnotConnected, out ho_ClsAnnotSelected,
                            hv_RegionIndex);
                        ho_RegionIntersection.Dispose();
                        HOperatorSet.Intersection(ho_ClsResult, ho_ClsAnnotSelected, out ho_RegionIntersection
                            );
                        hv_AreaIntersection.Dispose();
                        HOperatorSet.RegionFeatures(ho_RegionIntersection, "area", out hv_AreaIntersection);
                        hv_AreaGroundtruth.Dispose();
                        HOperatorSet.RegionFeatures(ho_ClsAnnotSelected, "area", out hv_AreaGroundtruth);
                        hv_RegionOverlap.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_RegionOverlap = (hv_AreaIntersection.TupleReal()
                                ) / (hv_AreaGroundtruth.TupleReal());
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTupleAt(hv_RunningMeasures, "gt_overlap", hv_ClsIndex,
                                (((hv_RunningMeasures.TupleGetDictTuple("gt_overlap"))).TupleSelect(
                                hv_ClsIndex)) + hv_RegionOverlap);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTupleAt(hv_RunningMeasures, "num_gt_regions", hv_ClsIndex,
                                (((hv_RunningMeasures.TupleGetDictTuple("num_gt_regions"))).TupleSelect(
                                hv_ClsIndex)) + 1);
                        }
                    }
                }
            }
            //
            ho_Annot.Dispose();
            ho_Result.Dispose();
            ho_ClsAnnot.Dispose();
            ho_ClsResult.Dispose();
            ho_ClsAnnotConnected.Dispose();
            ho_ClsAnnotSelected.Dispose();
            ho_RegionIntersection.Dispose();

            hv_Measures.Dispose();
            hv_CalcRegionMeasures.Dispose();
            hv_ClassIDs.Dispose();
            hv_GrippingMapExists.Dispose();
            hv_ResultKey.Dispose();
            hv_ClassIDsResult.Dispose();
            hv_SampleIndex.Dispose();
            hv_ClsIndex.Dispose();
            hv_ClsId.Dispose();
            hv_ClsIdRes.Dispose();
            hv_NumRegions.Dispose();
            hv_RegionIndex.Dispose();
            hv_AreaIntersection.Dispose();
            hv_AreaGroundtruth.Dispose();
            hv_RegionOverlap.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_Annot.Dispose();
            ho_Result.Dispose();
            ho_ClsAnnot.Dispose();
            ho_ClsResult.Dispose();
            ho_ClsAnnotConnected.Dispose();
            ho_ClsAnnotSelected.Dispose();
            ho_RegionIntersection.Dispose();

            hv_Measures.Dispose();
            hv_CalcRegionMeasures.Dispose();
            hv_ClassIDs.Dispose();
            hv_GrippingMapExists.Dispose();
            hv_ResultKey.Dispose();
            hv_ClassIDsResult.Dispose();
            hv_SampleIndex.Dispose();
            hv_ClsIndex.Dispose();
            hv_ClsId.Dispose();
            hv_ClsIdRes.Dispose();
            hv_NumRegions.Dispose();
            hv_RegionIndex.Dispose();
            hv_AreaIntersection.Dispose();
            hv_AreaGroundtruth.Dispose();
            hv_RegionOverlap.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Deep Learning / Model
    // Short Description: Check that all given entries in EvalParams are valid. 
    private void validate_evaluation_param(HTuple hv_EvalParams, out HTuple hv_Valid,
        out HTuple hv_Exception)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_ClassIDsExist = new HTuple(), hv_ClassIDs = new HTuple();
        HTuple hv_NumClassesExist = new HTuple(), hv_NumClasses = new HTuple();
        HTuple hv_EvalInstancesExists = new HTuple(), hv_EvaluationTypeExists = new HTuple();
        HTuple hv_EvaluationType = new HTuple(), hv_Indices = new HTuple();
        HTuple hv_MeasuresExists = new HTuple(), hv_Measures = new HTuple();
        HTuple hv_ValidMeasures = new HTuple(), hv_Ks = new HTuple();
        HTuple hv_KeysExist = new HTuple(), hv_ClassNames = new HTuple();
        HTuple hv_ClassesToEvaluate = new HTuple(), hv_ClassIDsToEvaluate = new HTuple();
        HTuple hv_KeyExists = new HTuple(), hv_InterpolatePRCurves = new HTuple();
        HTuple hv_IouThreshExists = new HTuple(), hv_IouThresholds = new HTuple();
        HTuple hv_MaxNumDetectionsExists = new HTuple(), hv_MaxNumDetections = new HTuple();
        HTuple hv_AreaRangesExist = new HTuple(), hv_AreaRanges = new HTuple();
        HTuple hv_AreaKeysExist = new HTuple(), hv_AreaNames = new HTuple();
        HTuple hv_MinAreas = new HTuple(), hv_MaxAreas = new HTuple();
        HTuple hv_InstanceTypeExists = new HTuple(), hv_InstanceType = new HTuple();
        HTuple hv_ValidInstanceTypes = new HTuple(), hv_AllocationBlockLengthExists = new HTuple();
        HTuple hv_AllocationBlockLength = new HTuple(), hv_DetailedEvaluationExists = new HTuple();
        HTuple hv_DetailedEvaluation = new HTuple(), hv_IgnoreClassIDsExist = new HTuple();
        HTuple hv_ValidMeasuresString = new HTuple(), hv_Idx = new HTuple();
        HTuple hv_ValidMeasure = new HTuple(), hv_CalculateOODMeasuresExists = new HTuple();
        HTuple hv___Tmp_Ctrl_Dict_Init_0 = new HTuple(), hv___Tmp_Ctrl_Dict_Init_1 = new HTuple();
        // Initialize local and output iconic variables 
        hv_Valid = new HTuple();
        hv_Exception = new HTuple();
        try
        {
            //
            //This procedure checks if the dictionary EvalParams
            //contains all necessary parameters and if they are valid (type, range, ...).
            //
            hv_Valid.Dispose();
            hv_Valid = 0;
            hv_Exception.Dispose();
            hv_Exception = "";
            //Check class IDs.
            hv_ClassIDsExist.Dispose();
            HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_ids", out hv_ClassIDsExist);
            if ((int)(hv_ClassIDsExist.TupleNot()) != 0)
            {
                hv_Exception.Dispose();
                hv_Exception = "The evaluation parameters need a key-value pair for 'class_ids'";

                hv_ClassIDsExist.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClassesExist.Dispose();
                hv_NumClasses.Dispose();
                hv_EvalInstancesExists.Dispose();
                hv_EvaluationTypeExists.Dispose();
                hv_EvaluationType.Dispose();
                hv_Indices.Dispose();
                hv_MeasuresExists.Dispose();
                hv_Measures.Dispose();
                hv_ValidMeasures.Dispose();
                hv_Ks.Dispose();
                hv_KeysExist.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_KeyExists.Dispose();
                hv_InterpolatePRCurves.Dispose();
                hv_IouThreshExists.Dispose();
                hv_IouThresholds.Dispose();
                hv_MaxNumDetectionsExists.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRangesExist.Dispose();
                hv_AreaRanges.Dispose();
                hv_AreaKeysExist.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_InstanceTypeExists.Dispose();
                hv_InstanceType.Dispose();
                hv_ValidInstanceTypes.Dispose();
                hv_AllocationBlockLengthExists.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_DetailedEvaluationExists.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_IgnoreClassIDsExist.Dispose();
                hv_ValidMeasuresString.Dispose();
                hv_Idx.Dispose();
                hv_ValidMeasure.Dispose();
                hv_CalculateOODMeasuresExists.Dispose();
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                return;
            }
            else
            {
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                if ((int)(new HTuple((new HTuple(hv_ClassIDs.TupleLength())).TupleLess(1))) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "'class_ids' should have at least length 1";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();
                    hv_CalculateOODMeasuresExists.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                    return;
                }
                if ((int)(new HTuple(((hv_ClassIDs.TupleIsIntElem())).TupleNotEqual(HTuple.TupleGenConst(
                    new HTuple(hv_ClassIDs.TupleLength()), 1)))) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "'class_ids' should be of type int";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();
                    hv_CalculateOODMeasuresExists.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                    return;
                }
                if ((int)(new HTuple(((((hv_ClassIDs.TupleLessElem(0))).TupleFind(1))).TupleGreater(
                    -1))) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "'class_ids' should be positive or zero";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();
                    hv_CalculateOODMeasuresExists.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                    return;
                }
            }
            //Check the entry num_classes.
            hv_NumClassesExist.Dispose();
            HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "num_classes", out hv_NumClassesExist);
            if ((int)(hv_NumClassesExist.TupleNot()) != 0)
            {
                hv_Exception.Dispose();
                hv_Exception = "The evaluation parameters need a key-value pair for 'num_classes'";

                hv_ClassIDsExist.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClassesExist.Dispose();
                hv_NumClasses.Dispose();
                hv_EvalInstancesExists.Dispose();
                hv_EvaluationTypeExists.Dispose();
                hv_EvaluationType.Dispose();
                hv_Indices.Dispose();
                hv_MeasuresExists.Dispose();
                hv_Measures.Dispose();
                hv_ValidMeasures.Dispose();
                hv_Ks.Dispose();
                hv_KeysExist.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_KeyExists.Dispose();
                hv_InterpolatePRCurves.Dispose();
                hv_IouThreshExists.Dispose();
                hv_IouThresholds.Dispose();
                hv_MaxNumDetectionsExists.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRangesExist.Dispose();
                hv_AreaRanges.Dispose();
                hv_AreaKeysExist.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_InstanceTypeExists.Dispose();
                hv_InstanceType.Dispose();
                hv_ValidInstanceTypes.Dispose();
                hv_AllocationBlockLengthExists.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_DetailedEvaluationExists.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_IgnoreClassIDsExist.Dispose();
                hv_ValidMeasuresString.Dispose();
                hv_Idx.Dispose();
                hv_ValidMeasure.Dispose();
                hv_CalculateOODMeasuresExists.Dispose();
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                return;
            }
            else
            {
                hv_NumClasses.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
                if ((int)(new HTuple((new HTuple(hv_NumClasses.TupleLength())).TupleNotEqual(
                    1))) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "'num_classes' should have length 1";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();
                    hv_CalculateOODMeasuresExists.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                    return;
                }
                if ((int)(new HTuple(((hv_NumClasses.TupleType())).TupleNotEqual((new HTuple((new HTuple(1)).TupleInt()
                    )).TupleType()))) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "'num_classes' should be of type int";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();
                    hv_CalculateOODMeasuresExists.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                    return;
                }
                if ((int)(new HTuple(hv_NumClasses.TupleLess(1))) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "'num_classes' should be at least 1";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();
                    hv_CalculateOODMeasuresExists.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                    return;
                }
            }
            //Check that num_classes is equal to |class_ids|.
            if ((int)(new HTuple(hv_NumClasses.TupleNotEqual(new HTuple(hv_ClassIDs.TupleLength()
                )))) != 0)
            {
                hv_Exception.Dispose();
                hv_Exception = "'num_classes' has to be set to the number of 'class_ids'";

                hv_ClassIDsExist.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClassesExist.Dispose();
                hv_NumClasses.Dispose();
                hv_EvalInstancesExists.Dispose();
                hv_EvaluationTypeExists.Dispose();
                hv_EvaluationType.Dispose();
                hv_Indices.Dispose();
                hv_MeasuresExists.Dispose();
                hv_Measures.Dispose();
                hv_ValidMeasures.Dispose();
                hv_Ks.Dispose();
                hv_KeysExist.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_KeyExists.Dispose();
                hv_InterpolatePRCurves.Dispose();
                hv_IouThreshExists.Dispose();
                hv_IouThresholds.Dispose();
                hv_MaxNumDetectionsExists.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRangesExist.Dispose();
                hv_AreaRanges.Dispose();
                hv_AreaKeysExist.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_InstanceTypeExists.Dispose();
                hv_InstanceType.Dispose();
                hv_ValidInstanceTypes.Dispose();
                hv_AllocationBlockLengthExists.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_DetailedEvaluationExists.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_IgnoreClassIDsExist.Dispose();
                hv_ValidMeasuresString.Dispose();
                hv_Idx.Dispose();
                hv_ValidMeasure.Dispose();
                hv_CalculateOODMeasuresExists.Dispose();
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                return;
            }
            //Check the entry 'evaluate_instances'.
            hv_EvalInstancesExists.Dispose();
            HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "evaluate_instances",
                out hv_EvalInstancesExists);
            if ((int)(hv_EvalInstancesExists.TupleNot()) != 0)
            {
                hv_Exception.Dispose();
                hv_Exception = "The evaluation parameters need a key-value pair for 'evaluate_instances'";

                hv_ClassIDsExist.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClassesExist.Dispose();
                hv_NumClasses.Dispose();
                hv_EvalInstancesExists.Dispose();
                hv_EvaluationTypeExists.Dispose();
                hv_EvaluationType.Dispose();
                hv_Indices.Dispose();
                hv_MeasuresExists.Dispose();
                hv_Measures.Dispose();
                hv_ValidMeasures.Dispose();
                hv_Ks.Dispose();
                hv_KeysExist.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_KeyExists.Dispose();
                hv_InterpolatePRCurves.Dispose();
                hv_IouThreshExists.Dispose();
                hv_IouThresholds.Dispose();
                hv_MaxNumDetectionsExists.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRangesExist.Dispose();
                hv_AreaRanges.Dispose();
                hv_AreaKeysExist.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_InstanceTypeExists.Dispose();
                hv_InstanceType.Dispose();
                hv_ValidInstanceTypes.Dispose();
                hv_AllocationBlockLengthExists.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_DetailedEvaluationExists.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_IgnoreClassIDsExist.Dispose();
                hv_ValidMeasuresString.Dispose();
                hv_Idx.Dispose();
                hv_ValidMeasure.Dispose();
                hv_CalculateOODMeasuresExists.Dispose();
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                return;
            }
            //Check the entry 'evaluation_type'.
            hv_EvaluationTypeExists.Dispose();
            HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "evaluation_type", out hv_EvaluationTypeExists);
            if ((int)(hv_EvaluationTypeExists.TupleNot()) != 0)
            {
                hv_Exception.Dispose();
                hv_Exception = "The evaluation parameters need a key-value pair for 'evaluation_type'";

                hv_ClassIDsExist.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClassesExist.Dispose();
                hv_NumClasses.Dispose();
                hv_EvalInstancesExists.Dispose();
                hv_EvaluationTypeExists.Dispose();
                hv_EvaluationType.Dispose();
                hv_Indices.Dispose();
                hv_MeasuresExists.Dispose();
                hv_Measures.Dispose();
                hv_ValidMeasures.Dispose();
                hv_Ks.Dispose();
                hv_KeysExist.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_KeyExists.Dispose();
                hv_InterpolatePRCurves.Dispose();
                hv_IouThreshExists.Dispose();
                hv_IouThresholds.Dispose();
                hv_MaxNumDetectionsExists.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRangesExist.Dispose();
                hv_AreaRanges.Dispose();
                hv_AreaKeysExist.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_InstanceTypeExists.Dispose();
                hv_InstanceType.Dispose();
                hv_ValidInstanceTypes.Dispose();
                hv_AllocationBlockLengthExists.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_DetailedEvaluationExists.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_IgnoreClassIDsExist.Dispose();
                hv_ValidMeasuresString.Dispose();
                hv_Idx.Dispose();
                hv_ValidMeasure.Dispose();
                hv_CalculateOODMeasuresExists.Dispose();
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                return;
            }
            else
            {
                hv_EvaluationType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
                hv_Indices.Dispose();
                HOperatorSet.TupleFind(((((((((new HTuple("3d_gripping_point_detection")).TupleConcat(
                    "anomaly_detection")).TupleConcat("classification")).TupleConcat("multi_label_classification")).TupleConcat(
                    "detection")).TupleConcat("gc_anomaly_detection")).TupleConcat("ocr_recognition")).TupleConcat(
                    "ocr_detection")).TupleConcat("segmentation"), hv_EvaluationType, out hv_Indices);
                if ((int)((new HTuple(hv_Indices.TupleEqual(-1))).TupleOr(new HTuple(hv_Indices.TupleEqual(
                    new HTuple())))) != 0)
                {
                    hv_Exception.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Exception = "Invalid entry for 'evaluation_type': " + hv_EvaluationType;
                    }

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();
                    hv_CalculateOODMeasuresExists.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                    return;
                }
            }
            //Check the entry 'measures'.
            hv_MeasuresExists.Dispose();
            HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "measures", out hv_MeasuresExists);
            if ((int)(hv_MeasuresExists.TupleNot()) != 0)
            {
                hv_Exception.Dispose();
                hv_Exception = "The evaluation parameters need a key-value pair for 'measures'";

                hv_ClassIDsExist.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClassesExist.Dispose();
                hv_NumClasses.Dispose();
                hv_EvalInstancesExists.Dispose();
                hv_EvaluationTypeExists.Dispose();
                hv_EvaluationType.Dispose();
                hv_Indices.Dispose();
                hv_MeasuresExists.Dispose();
                hv_Measures.Dispose();
                hv_ValidMeasures.Dispose();
                hv_Ks.Dispose();
                hv_KeysExist.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_KeyExists.Dispose();
                hv_InterpolatePRCurves.Dispose();
                hv_IouThreshExists.Dispose();
                hv_IouThresholds.Dispose();
                hv_MaxNumDetectionsExists.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRangesExist.Dispose();
                hv_AreaRanges.Dispose();
                hv_AreaKeysExist.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_InstanceTypeExists.Dispose();
                hv_InstanceType.Dispose();
                hv_ValidInstanceTypes.Dispose();
                hv_AllocationBlockLengthExists.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_DetailedEvaluationExists.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_IgnoreClassIDsExist.Dispose();
                hv_ValidMeasuresString.Dispose();
                hv_Idx.Dispose();
                hv_ValidMeasure.Dispose();
                hv_CalculateOODMeasuresExists.Dispose();
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                return;
            }
            else
            {
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                if ((int)(new HTuple((new HTuple(hv_Measures.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "'measures' should contain at least one entry";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();
                    hv_CalculateOODMeasuresExists.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                    return;
                }
            }
            //Check evaluation type specific entries of EvalParams.
            hv_EvaluationType.Dispose();
            HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
            if ((int)(new HTuple(hv_EvaluationType.TupleEqual("3d_gripping_point_detection"))) != 0)
            {
                //Pixel- and region-based evaluation.
                hv_ValidMeasures.Dispose();
                get_valid_pixel_measures(hv_EvaluationType, out hv_ValidMeasures);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ValidMeasures = hv_ValidMeasures.TupleConcat(
                            ((((new HTuple("mean_pro")).TupleConcat("gripping_point_precision")).TupleConcat(
                            "gripping_point_recall")).TupleConcat("gripping_point_f_score")).TupleConcat(
                            "all"));
                        hv_ValidMeasures.Dispose();
                        hv_ValidMeasures = ExpTmpLocalVar_ValidMeasures;
                    }
                }
            }
            else if ((int)((new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))).TupleOr(
                new HTuple(hv_EvaluationType.TupleEqual("gc_anomaly_detection")))) != 0)
            {
                //
                //Check for correct number of classes.
                if ((int)(new HTuple((new HTuple(hv_ClassIDs.TupleLength())).TupleNotEqual(
                    2))) != 0)
                {
                    throw new HalconException("The number of classes must be 2 for model type 'anomaly_detection' or 'gc_anomaly_detection'.");
                }
                //
                hv_ValidMeasures.Dispose();
                hv_ValidMeasures = new HTuple();
                hv_ValidMeasures[0] = "anomaly_score_histogram";
                hv_ValidMeasures[1] = "precision";
                hv_ValidMeasures[2] = "recall";
                hv_ValidMeasures[3] = "absolute_confusion_matrix";
                hv_ValidMeasures[4] = "relative_confusion_matrix";
                hv_ValidMeasures[5] = "all";
            }
            else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Ks.Dispose();
                    HOperatorSet.TupleGenSequence(1, new HTuple(hv_ClassIDs.TupleLength()), 1,
                        out hv_Ks);
                }
                hv_ValidMeasures.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ValidMeasures = new HTuple();
                    hv_ValidMeasures[0] = "all";
                    hv_ValidMeasures = hv_ValidMeasures.TupleConcat(("top" + hv_Ks) + "_error");
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ValidMeasures = hv_ValidMeasures.TupleConcat(
                            (((((((((((new HTuple("precision")).TupleConcat("recall")).TupleConcat(
                            "f_score")).TupleConcat("absolute_confusion_matrix")).TupleConcat("relative_confusion_matrix")).TupleConcat(
                            "ood_confusion_matrix")).TupleConcat("ood_precision")).TupleConcat("ood_recall")).TupleConcat(
                            "ood_f_score")).TupleConcat("ood_false_positive_rate")).TupleConcat("ood_score_histogram")).TupleConcat(
                            "ood_thresholds"));
                        hv_ValidMeasures.Dispose();
                        hv_ValidMeasures = ExpTmpLocalVar_ValidMeasures;
                    }
                }
                //
                //Check if not both of the two options to specify the evaluated classes are chosen.
                hv_KeysExist.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", (new HTuple("class_names_to_evaluate")).TupleConcat(
                    "class_ids_to_evaluate"), out hv_KeysExist);
                if ((int)(new HTuple(((hv_KeysExist.TupleSum())).TupleEqual(2))) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "No more than one option of 'class_names_to_evaluate' and 'class_ids_to_evaluate' is allowed";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();
                    hv_CalculateOODMeasuresExists.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                    return;
                }
                if ((int)(hv_KeysExist.TupleSelect(0)) != 0)
                {
                    hv_ClassNames.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_names", out hv_ClassNames);
                    hv_ClassesToEvaluate.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_names_to_evaluate", out hv_ClassesToEvaluate);
                    if ((int)(new HTuple(((hv_ClassesToEvaluate.TupleDifference(hv_ClassNames.TupleConcat(
                        "global")))).TupleNotEqual(new HTuple()))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "Invalid entry in 'class_names_to_evaluate'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                }
                if ((int)(hv_KeysExist.TupleSelect(1)) != 0)
                {
                    hv_ClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                    hv_ClassIDsToEvaluate.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids_to_evaluate", out hv_ClassIDsToEvaluate);
                    if ((int)(new HTuple(((hv_ClassIDsToEvaluate.TupleDifference(hv_ClassIDs.TupleConcat(
                        "global")))).TupleNotEqual(new HTuple()))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "Invalid entry in 'class_ids_to_evaluate'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                }
            }
            else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("multi_label_classification"))) != 0)
            {
                hv_ValidMeasures.Dispose();
                hv_ValidMeasures = new HTuple();
                hv_ValidMeasures[0] = "all";
                hv_ValidMeasures[1] = "mean_ap";
                hv_ValidMeasures[2] = "f_score";
                hv_ValidMeasures[3] = "precision";
                hv_ValidMeasures[4] = "recall";
                hv_ValidMeasures[5] = "accuracy";
                //
                //Check if not both of the two options to specify the evaluated classes are chosen.
                hv_KeysExist.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", (new HTuple("class_names_to_evaluate")).TupleConcat(
                    "class_ids_to_evaluate"), out hv_KeysExist);
                if ((int)(new HTuple(((hv_KeysExist.TupleSum())).TupleEqual(2))) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "No more than one option of 'class_names_to_evaluate' and 'class_ids_to_evaluate' is allowed";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();
                    hv_CalculateOODMeasuresExists.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                    return;
                }
                if ((int)(hv_KeysExist.TupleSelect(0)) != 0)
                {
                    hv_ClassNames.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_names", out hv_ClassNames);
                    hv_ClassesToEvaluate.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_names_to_evaluate", out hv_ClassesToEvaluate);
                    if ((int)(new HTuple(((hv_ClassesToEvaluate.TupleDifference(hv_ClassNames.TupleConcat(
                        "global")))).TupleNotEqual(new HTuple()))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "Invalid entry in 'class_names_to_evaluate'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                }
                if ((int)(hv_KeysExist.TupleSelect(1)) != 0)
                {
                    hv_ClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                    hv_ClassIDsToEvaluate.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids_to_evaluate", out hv_ClassIDsToEvaluate);
                    if ((int)(new HTuple(((hv_ClassIDsToEvaluate.TupleDifference(hv_ClassIDs.TupleConcat(
                        "global")))).TupleNotEqual(new HTuple()))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "Invalid entry in 'class_ids_to_evaluate'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                }
                //Check if the entry 'interpolate_pr_curves' is valid if present.
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "interpolate_pr_curves",
                    out hv_KeyExists);
                if ((int)(hv_KeyExists.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'interpolate_pr_curves'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();
                    hv_CalculateOODMeasuresExists.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                    return;
                }
                else
                {
                    hv_InterpolatePRCurves.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "interpolate_pr_curves", out hv_InterpolatePRCurves);
                    //Check the length of 'interpolate_pr_curves'.
                    if ((int)(new HTuple((new HTuple(hv_InterpolatePRCurves.TupleLength())).TupleNotEqual(
                        1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'interpolate_pr_curves' should have length 1";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                    //Check the type of 'interpolate_pr_curves'.
                    if ((int)(new HTuple(((hv_InterpolatePRCurves.TupleType())).TupleNotEqual(
                        (new HTuple(1)).TupleType()))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'interpolate_pr_curves' should be of type int";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                    //Check if 'interpolate_pr_curves' is true or false.
                    if ((int)((new HTuple(hv_InterpolatePRCurves.TupleNotEqual(0))).TupleAnd(
                        new HTuple(hv_InterpolatePRCurves.TupleNotEqual(1)))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'interpolate_pr_curves' should be zero or one";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                }
            }
            else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("detection"))) != 0)
            {
                //Instance-based evaluation.
                //Add instance measures.
                hv_ValidMeasures.Dispose();
                hv_ValidMeasures = new HTuple();
                hv_ValidMeasures[0] = "all";
                hv_ValidMeasures[1] = "mean_ap";
                //
                //Check if the entry 'iou_threshold' is present.
                hv_IouThreshExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "iou_threshold", out hv_IouThreshExists);
                if ((int)(hv_IouThreshExists.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'iou_threshold'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();
                    hv_CalculateOODMeasuresExists.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                    return;
                }
                else
                {
                    hv_IouThresholds.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_IouThresholds);
                    //Check the length of 'iou_threshold'.
                    if ((int)(new HTuple((new HTuple(hv_IouThresholds.TupleLength())).TupleLess(
                        1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'iou_threshold' is empty";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                    if ((int)(new HTuple(((hv_IouThresholds.TupleIsRealElem())).TupleNotEqual(
                        HTuple.TupleGenConst(new HTuple(hv_IouThresholds.TupleLength()), 1)))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'iou_threshold' should be of type real";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                    //Check if the IoU thresholds are within (0.0, 1.0).
                    if ((int)((new HTuple(((hv_IouThresholds.TupleMin())).TupleLessEqual(0.0))).TupleOr(
                        new HTuple(((hv_IouThresholds.TupleMax())).TupleGreaterEqual(1.0)))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = new HTuple("Invalid 'iou_threshold', not in range (0.0, 1.0)");

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                }
                //
                //Check if the entry 'max_num_detections' is present.
                hv_MaxNumDetectionsExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "max_num_detections",
                    out hv_MaxNumDetectionsExists);
                if ((int)(hv_MaxNumDetectionsExists.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'max_num_detections'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();
                    hv_CalculateOODMeasuresExists.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                    return;
                }
                else
                {
                    hv_MaxNumDetections.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "max_num_detections", out hv_MaxNumDetections);
                    //Check the length of 'max_num_detections'.
                    if ((int)(new HTuple((new HTuple(hv_MaxNumDetections.TupleLength())).TupleLess(
                        1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'max_num_detections' is empty";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                    if ((int)(new HTuple(((hv_MaxNumDetections.TupleIsIntElem())).TupleNotEqual(
                        HTuple.TupleGenConst(new HTuple(hv_MaxNumDetections.TupleLength()),
                        1)))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'max_num_detections' should be of type int";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                    //Check if 'max_num_detections' is -1 (to use all detections) or positive.
                    if ((int)((new HTuple(((hv_MaxNumDetections.TupleMin())).TupleLess(-1))).TupleOr(
                        new HTuple(((hv_MaxNumDetections.TupleFind(0))).TupleGreater(-1)))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'max_num_detections' should be -1 or positive";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                }
                //
                //Check if the entry 'area_ranges' is present.
                hv_AreaRangesExist.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "area_ranges", out hv_AreaRangesExist);
                if ((int)(hv_AreaRangesExist.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'area_ranges'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();
                    hv_CalculateOODMeasuresExists.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                    return;
                }
                else
                {
                    //Check if the entry 'area_ranges' is a dict.
                    hv_AreaRanges.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "area_ranges", out hv_AreaRanges);
                    if ((int)(new HTuple(((hv_AreaRanges.TupleSemType())).TupleNotEqual("dict"))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'area_ranges' must be a dict";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                    //Check that the necessary keys exist.
                    hv_AreaKeysExist.Dispose();
                    HOperatorSet.GetDictParam(hv_AreaRanges, "key_exists", ((new HTuple("name")).TupleConcat(
                        "min")).TupleConcat("max"), out hv_AreaKeysExist);
                    if ((int)(((hv_AreaKeysExist.TupleSelect(0))).TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'area_ranges' need a key-value pair for 'name'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                    if ((int)(((hv_AreaKeysExist.TupleSelect(1))).TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'area_ranges' need a key-value pair for 'min'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                    if ((int)(((hv_AreaKeysExist.TupleSelect(2))).TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'area_ranges' need a key-value pair for 'max'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                    //Check the lengths of the area keys.
                    hv_AreaNames.Dispose();
                    HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaNames);
                    if ((int)(new HTuple((new HTuple(hv_AreaNames.TupleLength())).TupleLess(
                        1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'area_ranges': 'name' is empty";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                    hv_MinAreas.Dispose();
                    HOperatorSet.GetDictTuple(hv_AreaRanges, "min", out hv_MinAreas);
                    if ((int)(new HTuple((new HTuple(hv_MinAreas.TupleLength())).TupleLess(
                        1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'area_ranges': 'min' is empty";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                    hv_MaxAreas.Dispose();
                    HOperatorSet.GetDictTuple(hv_AreaRanges, "max", out hv_MaxAreas);
                    if ((int)(new HTuple((new HTuple(hv_MaxAreas.TupleLength())).TupleLess(
                        1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'area_ranges': 'max' is empty";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                    if ((int)((new HTuple((new HTuple(hv_AreaNames.TupleLength())).TupleNotEqual(
                        new HTuple(hv_MinAreas.TupleLength())))).TupleOr(new HTuple((new HTuple(hv_AreaNames.TupleLength()
                        )).TupleNotEqual(new HTuple(hv_MaxAreas.TupleLength()))))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = new HTuple("'area_ranges': 'name', 'min' and 'max' must have the same length");

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                    //Check values of min, max.
                    if ((int)(new HTuple(((((hv_MinAreas.TupleGreaterEqualElem(hv_MaxAreas))).TupleFind(
                        1))).TupleGreater(-1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'area_ranges': 'min' must be elementwise smaller than 'max'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                }
                //
                //Check if instance-type is valid.
                hv_InstanceTypeExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "instance_type", out hv_InstanceTypeExists);
                if ((int)(hv_InstanceTypeExists.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'instance_type'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();
                    hv_CalculateOODMeasuresExists.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                    return;
                }
                else
                {
                    hv_InstanceType.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "instance_type", out hv_InstanceType);
                    hv_ValidInstanceTypes.Dispose();
                    hv_ValidInstanceTypes = new HTuple();
                    hv_ValidInstanceTypes[0] = "rectangle1";
                    hv_ValidInstanceTypes[1] = "rectangle2";
                    hv_ValidInstanceTypes[2] = "mask";
                    if ((int)(new HTuple(((hv_ValidInstanceTypes.TupleFind(hv_InstanceType))).TupleEqual(
                        -1))) != 0)
                    {
                        hv_Exception.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Exception = ("Invalid instance type '" + hv_InstanceType) + "'";
                        }

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                }
                //
                //Check if the entry 'allocation_block_length' is present and valid.
                hv_AllocationBlockLengthExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "allocation_block_length",
                    out hv_AllocationBlockLengthExists);
                if ((int)(hv_AllocationBlockLengthExists.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'allocation_block_length'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();
                    hv_CalculateOODMeasuresExists.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                    return;
                }
                else
                {
                    hv_AllocationBlockLength.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "allocation_block_length", out hv_AllocationBlockLength);
                    //Check the length of 'allocation_block_length'.
                    if ((int)(new HTuple((new HTuple(hv_AllocationBlockLength.TupleLength()
                        )).TupleNotEqual(1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'allocation_block_length' should have length 1";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                    //Check the type of 'allocation_block_length'.
                    if ((int)(new HTuple(((hv_AllocationBlockLength.TupleType())).TupleNotEqual(
                        (new HTuple((new HTuple(0)).TupleInt())).TupleType()))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'allocation_block_length' should be of type int";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                    //Check if 'allocation_block_length' is larger than zero.
                    if ((int)(new HTuple(hv_AllocationBlockLength.TupleLess(1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'allocation_block_length' should be positive";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                }
                //
                //Check if the entry 'detailed_evaluation' is valid if present.
                hv_DetailedEvaluationExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "detailed_evaluation",
                    out hv_DetailedEvaluationExists);
                if ((int)(hv_DetailedEvaluationExists.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'detailed_evaluation'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();
                    hv_CalculateOODMeasuresExists.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                    return;
                }
                else
                {
                    hv_DetailedEvaluation.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "detailed_evaluation", out hv_DetailedEvaluation);
                    //Check the length of 'detailed_evaluation'.
                    if ((int)(new HTuple((new HTuple(hv_DetailedEvaluation.TupleLength())).TupleNotEqual(
                        1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'detailed_evaluation' should have length 1";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                    //Check the type of 'detailed_evaluation'.
                    if ((int)(new HTuple(((hv_DetailedEvaluation.TupleType())).TupleNotEqual(
                        (new HTuple(1)).TupleType()))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'detailed_evaluation' should be of type int";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                    //Check if 'detailed_evaluation' is true or false.
                    if ((int)((new HTuple(hv_DetailedEvaluation.TupleNotEqual(0))).TupleAnd(
                        new HTuple(hv_DetailedEvaluation.TupleNotEqual(1)))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'detailed_evaluation' should be zero or one";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                }
                //
                //Check if the entry 'interpolate_pr_curves' is valid if present.
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "interpolate_pr_curves",
                    out hv_KeyExists);
                if ((int)(hv_KeyExists.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'interpolate_pr_curves'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();
                    hv_CalculateOODMeasuresExists.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                    return;
                }
                else
                {
                    hv_InterpolatePRCurves.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "interpolate_pr_curves", out hv_InterpolatePRCurves);
                    //Check the length of 'interpolate_pr_curves'.
                    if ((int)(new HTuple((new HTuple(hv_InterpolatePRCurves.TupleLength())).TupleNotEqual(
                        1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'interpolate_pr_curves' should have length 1";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                    //Check the type of 'interpolate_pr_curves'.
                    if ((int)(new HTuple(((hv_InterpolatePRCurves.TupleType())).TupleNotEqual(
                        (new HTuple(1)).TupleType()))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'interpolate_pr_curves' should be of type int";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                    //Check if 'interpolate_pr_curves' is true or false.
                    if ((int)((new HTuple(hv_InterpolatePRCurves.TupleNotEqual(0))).TupleAnd(
                        new HTuple(hv_InterpolatePRCurves.TupleNotEqual(1)))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'interpolate_pr_curves' should be zero or one";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();
                        hv_CalculateOODMeasuresExists.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                        return;
                    }
                }
                //
                //Add valid measure 'soap' if instance_type is 'rectangle2'.
                if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ValidMeasures = hv_ValidMeasures.TupleConcat(
                                "soap");
                            hv_ValidMeasures.Dispose();
                            hv_ValidMeasures = ExpTmpLocalVar_ValidMeasures;
                        }
                    }
                }
            }
            else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
            {
                //Pixel-based evaluation.
                hv_ValidMeasures.Dispose();
                get_valid_pixel_measures(hv_EvaluationType, out hv_ValidMeasures);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ValidMeasures = hv_ValidMeasures.TupleConcat(
                            "all");
                        hv_ValidMeasures.Dispose();
                        hv_ValidMeasures = ExpTmpLocalVar_ValidMeasures;
                    }
                }
                //
                //Check if the entry 'ignore_class_ids' exists.
                hv_IgnoreClassIDsExist.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "ignore_class_ids",
                    out hv_IgnoreClassIDsExist);
                if ((int)(hv_IgnoreClassIDsExist.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'ignore_class_ids'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();
                    hv_CalculateOODMeasuresExists.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                    return;
                }
            }
            else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("ocr_recognition"))) != 0)
            {
                //OCR recognition evaluation.
                hv_ValidMeasures.Dispose();
                hv_ValidMeasures = "accuracy";
            }
            else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("ocr_detection"))) != 0)
            {
                //OCR detection evaluation.
                hv_ValidMeasures.Dispose();
                hv_ValidMeasures = new HTuple();
                hv_ValidMeasures[0] = "all";
                hv_ValidMeasures[1] = "recall";
                hv_ValidMeasures[2] = "precision";
                hv_ValidMeasures[3] = "f_score";
                hv_ValidMeasures[4] = "soap";
            }
            else
            {
                hv_Exception.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Exception = "Unknown evaluation_type: " + hv_EvaluationType;
                }

                hv_ClassIDsExist.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClassesExist.Dispose();
                hv_NumClasses.Dispose();
                hv_EvalInstancesExists.Dispose();
                hv_EvaluationTypeExists.Dispose();
                hv_EvaluationType.Dispose();
                hv_Indices.Dispose();
                hv_MeasuresExists.Dispose();
                hv_Measures.Dispose();
                hv_ValidMeasures.Dispose();
                hv_Ks.Dispose();
                hv_KeysExist.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_KeyExists.Dispose();
                hv_InterpolatePRCurves.Dispose();
                hv_IouThreshExists.Dispose();
                hv_IouThresholds.Dispose();
                hv_MaxNumDetectionsExists.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRangesExist.Dispose();
                hv_AreaRanges.Dispose();
                hv_AreaKeysExist.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_InstanceTypeExists.Dispose();
                hv_InstanceType.Dispose();
                hv_ValidInstanceTypes.Dispose();
                hv_AllocationBlockLengthExists.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_DetailedEvaluationExists.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_IgnoreClassIDsExist.Dispose();
                hv_ValidMeasuresString.Dispose();
                hv_Idx.Dispose();
                hv_ValidMeasure.Dispose();
                hv_CalculateOODMeasuresExists.Dispose();
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                return;
            }
            //Check measures.
            hv_ValidMeasuresString.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_ValidMeasuresString = HTuple.TupleGenConst(
                    ((new HTuple(hv_ValidMeasures.TupleLength())) * 2) - 1, new HTuple("','"));
            }
            if (hv_ValidMeasuresString == null)
                hv_ValidMeasuresString = new HTuple();
            hv_ValidMeasuresString[HTuple.TupleGenSequence(0, (new HTuple(hv_ValidMeasuresString.TupleLength()
                )) - 1, 2)] = hv_ValidMeasures;
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                {
                    HTuple
                      ExpTmpLocalVar_ValidMeasuresString = hv_ValidMeasuresString.TupleSum()
                        ;
                    hv_ValidMeasuresString.Dispose();
                    hv_ValidMeasuresString = ExpTmpLocalVar_ValidMeasuresString;
                }
            }
            for (hv_Idx = 0; (int)hv_Idx <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_Idx = (int)hv_Idx + 1)
            {
                hv_ValidMeasure.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ValidMeasure = ((hv_ValidMeasures.TupleFind(
                        hv_Measures.TupleSelect(hv_Idx)))).TupleGreaterElem(-1);
                }
                if ((int)(hv_ValidMeasure.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Exception = ((("Invalid measure '" + (hv_Measures.TupleSelect(
                            hv_Idx))) + new HTuple("', choose one of ['")) + hv_ValidMeasuresString) + "']";
                    }

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();
                    hv_CalculateOODMeasuresExists.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                    return;
                }
            }
            //
            //Check OOD information.
            hv_CalculateOODMeasuresExists.Dispose();
            HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "calculate_ood_measures",
                out hv_CalculateOODMeasuresExists);
            if ((int)(hv_CalculateOODMeasuresExists) != 0)
            {
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_0);
                HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_0, "comp", 0);
                hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_1);
                HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_1, "comp", 1);
                if ((int)((new HTuple(((((hv_EvalParams.TupleConcat(hv___Tmp_Ctrl_Dict_Init_1))).TupleTestEqualDictItem(
                    "calculate_ood_measures", "comp"))).TupleNot())).TupleAnd(((((hv_EvalParams.TupleConcat(
                    hv___Tmp_Ctrl_Dict_Init_0))).TupleTestEqualDictItem("calculate_ood_measures",
                    "comp"))).TupleNot())) != 0)
                {
                    throw new HalconException("The 'calculate_ood_measures' entry of EvalParams must be true or false.");
                }
                hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv___Tmp_Ctrl_Dict_Init_1 = HTuple.TupleConstant(
                        "HNULL");
                }
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv___Tmp_Ctrl_Dict_Init_0 = HTuple.TupleConstant(
                        "HNULL");
                }
                if ((int)((new HTuple(hv_EvaluationType.TupleNotEqual("classification"))).TupleAnd(
                    hv_EvalParams.TupleGetDictTuple("calculate_ood_measures"))) != 0)
                {
                    throw new HalconException("Out-of-distribution detection evaluation is only possible for classification models.");
                }
            }
            else
            {
                //No out-of-distribution results are collected by default.
                HOperatorSet.SetDictTuple(hv_EvalParams, "calculate_ood_measures", 0);
            }
            //
            //Done with checks.
            hv_Valid.Dispose();
            hv_Valid = 1;

            hv_ClassIDsExist.Dispose();
            hv_ClassIDs.Dispose();
            hv_NumClassesExist.Dispose();
            hv_NumClasses.Dispose();
            hv_EvalInstancesExists.Dispose();
            hv_EvaluationTypeExists.Dispose();
            hv_EvaluationType.Dispose();
            hv_Indices.Dispose();
            hv_MeasuresExists.Dispose();
            hv_Measures.Dispose();
            hv_ValidMeasures.Dispose();
            hv_Ks.Dispose();
            hv_KeysExist.Dispose();
            hv_ClassNames.Dispose();
            hv_ClassesToEvaluate.Dispose();
            hv_ClassIDsToEvaluate.Dispose();
            hv_KeyExists.Dispose();
            hv_InterpolatePRCurves.Dispose();
            hv_IouThreshExists.Dispose();
            hv_IouThresholds.Dispose();
            hv_MaxNumDetectionsExists.Dispose();
            hv_MaxNumDetections.Dispose();
            hv_AreaRangesExist.Dispose();
            hv_AreaRanges.Dispose();
            hv_AreaKeysExist.Dispose();
            hv_AreaNames.Dispose();
            hv_MinAreas.Dispose();
            hv_MaxAreas.Dispose();
            hv_InstanceTypeExists.Dispose();
            hv_InstanceType.Dispose();
            hv_ValidInstanceTypes.Dispose();
            hv_AllocationBlockLengthExists.Dispose();
            hv_AllocationBlockLength.Dispose();
            hv_DetailedEvaluationExists.Dispose();
            hv_DetailedEvaluation.Dispose();
            hv_IgnoreClassIDsExist.Dispose();
            hv_ValidMeasuresString.Dispose();
            hv_Idx.Dispose();
            hv_ValidMeasure.Dispose();
            hv_CalculateOODMeasuresExists.Dispose();
            hv___Tmp_Ctrl_Dict_Init_0.Dispose();
            hv___Tmp_Ctrl_Dict_Init_1.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_ClassIDsExist.Dispose();
            hv_ClassIDs.Dispose();
            hv_NumClassesExist.Dispose();
            hv_NumClasses.Dispose();
            hv_EvalInstancesExists.Dispose();
            hv_EvaluationTypeExists.Dispose();
            hv_EvaluationType.Dispose();
            hv_Indices.Dispose();
            hv_MeasuresExists.Dispose();
            hv_Measures.Dispose();
            hv_ValidMeasures.Dispose();
            hv_Ks.Dispose();
            hv_KeysExist.Dispose();
            hv_ClassNames.Dispose();
            hv_ClassesToEvaluate.Dispose();
            hv_ClassIDsToEvaluate.Dispose();
            hv_KeyExists.Dispose();
            hv_InterpolatePRCurves.Dispose();
            hv_IouThreshExists.Dispose();
            hv_IouThresholds.Dispose();
            hv_MaxNumDetectionsExists.Dispose();
            hv_MaxNumDetections.Dispose();
            hv_AreaRangesExist.Dispose();
            hv_AreaRanges.Dispose();
            hv_AreaKeysExist.Dispose();
            hv_AreaNames.Dispose();
            hv_MinAreas.Dispose();
            hv_MaxAreas.Dispose();
            hv_InstanceTypeExists.Dispose();
            hv_InstanceType.Dispose();
            hv_ValidInstanceTypes.Dispose();
            hv_AllocationBlockLengthExists.Dispose();
            hv_AllocationBlockLength.Dispose();
            hv_DetailedEvaluationExists.Dispose();
            hv_DetailedEvaluation.Dispose();
            hv_IgnoreClassIDsExist.Dispose();
            hv_ValidMeasuresString.Dispose();
            hv_Idx.Dispose();
            hv_ValidMeasure.Dispose();
            hv_CalculateOODMeasuresExists.Dispose();
            hv___Tmp_Ctrl_Dict_Init_0.Dispose();
            hv___Tmp_Ctrl_Dict_Init_1.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Local procedures 
    public void bench_dl_model(HTuple hv_DLModelHandle, HTuple hv_DLDataset, out HTuple hv_TimePerBatch)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_BatchSize = new HTuple(), hv_TotalTime = new HTuple();
        HTuple hv_DLSampleBatch = new HTuple(), hv_DLResultBatch = new HTuple();
        HTuple hv_Iterations = new HTuple(), hv_Start = new HTuple();
        HTuple hv_Current = new HTuple(), hv_Elapsed = new HTuple();
        // Initialize local and output iconic variables 
        hv_TimePerBatch = new HTuple();
        try
        {
            //This local procedure benchmarks the inference of the classification model
            //DLModelHandle.
            //
            hv_BatchSize.Dispose();
            HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size", out hv_BatchSize);
            //
            //Run the benchmark for 5 seconds.
            hv_TotalTime.Dispose();
            hv_TotalTime = 5;
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_DLSampleBatch.Dispose();
                read_dl_samples(hv_DLDataset, HTuple.TupleGenSequence(0, hv_BatchSize - 1, 1),
                    out hv_DLSampleBatch);
            }
            hv_DLResultBatch.Dispose();
            HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_DLSampleBatch, new HTuple(),
                out hv_DLResultBatch);
            hv_DLResultBatch.Dispose();
            HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_DLSampleBatch, new HTuple(),
                out hv_DLResultBatch);
            hv_Iterations.Dispose();
            hv_Iterations = 0;
            hv_Start.Dispose();
            HOperatorSet.CountSeconds(out hv_Start);
            do
            {
                hv_DLResultBatch.Dispose();
                HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_DLSampleBatch, new HTuple(),
                    out hv_DLResultBatch);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_Iterations = hv_Iterations + 1;
                        hv_Iterations.Dispose();
                        hv_Iterations = ExpTmpLocalVar_Iterations;
                    }
                }
                hv_Current.Dispose();
                HOperatorSet.CountSeconds(out hv_Current);
                hv_Elapsed.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Elapsed = hv_Current - hv_Start;
                }
            }
            while ((int)(new HTuple(hv_Elapsed.TupleGreater(hv_TotalTime))) == 0);
            hv_TimePerBatch.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_TimePerBatch = hv_Elapsed / hv_Iterations;
            }

            hv_BatchSize.Dispose();
            hv_TotalTime.Dispose();
            hv_DLSampleBatch.Dispose();
            hv_DLResultBatch.Dispose();
            hv_Iterations.Dispose();
            hv_Start.Dispose();
            hv_Current.Dispose();
            hv_Elapsed.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_BatchSize.Dispose();
            hv_TotalTime.Dispose();
            hv_DLSampleBatch.Dispose();
            hv_DLResultBatch.Dispose();
            hv_Iterations.Dispose();
            hv_Start.Dispose();
            hv_Current.Dispose();
            hv_Elapsed.Dispose();

            throw HDevExpDefaultException;
        }
    }

    public void check_data_availability(HTuple hv_ExampleDataDir, HTuple hv_DLDatasetFileName,
        HTuple hv_TrainedModelFileName, HTuple hv_UsePretrainedModel)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_FileExists = new HTuple(), hv_Example1 = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            //This procedure checks the availability of all files required to run the
            //evaluation example.
            //
            hv_FileExists.Dispose();
            HOperatorSet.FileExists(hv_ExampleDataDir, out hv_FileExists);
            hv_Example1.Dispose();
            hv_Example1 = "classify_pill_defects_deep_learning_1_preprocess.hdev";
            if ((int)(hv_FileExists.TupleNot()) != 0)
            {
                throw new HalconException(((hv_ExampleDataDir + " does not exist. Please run ") + hv_Example1) + " of the Deep Learning Classification example series.");
            }
            //
            hv_FileExists.Dispose();
            HOperatorSet.FileExists(hv_DLDatasetFileName, out hv_FileExists);
            if ((int)(hv_FileExists.TupleNot()) != 0)
            {
                throw new HalconException(hv_DLDatasetFileName + " does not exist. Please run part 1 of the Deep Learning Classification example series.");
            }
            //
            hv_FileExists.Dispose();
            HOperatorSet.FileExists(hv_TrainedModelFileName, out hv_FileExists);
            if ((int)(hv_FileExists.TupleNot()) != 0)
            {
                if ((int)(hv_UsePretrainedModel) != 0)
                {
                    throw new HalconException(hv_TrainedModelFileName + " does not exist. Please run the HALCON Deep Learning installer.");
                }
                else
                {
                    throw new HalconException(hv_TrainedModelFileName + " does not exist. Please run part 2 of the Deep Learning Classification example series.");
                }
            }
            //

            hv_FileExists.Dispose();
            hv_Example1.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_FileExists.Dispose();
            hv_Example1.Dispose();

            throw HDevExpDefaultException;
        }
    }

    public void collect_results(HTuple hv_ResultCollector, HTuple hv_DLModelHandle,
        HTuple hv_TimePerBatch, HTuple hv_EvaluationResult)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_ResultNames = new HTuple(), hv_Exception = new HTuple();
        HTuple hv_Device = new HTuple(), hv_DeviceName = new HTuple();
        HTuple hv_InterfaceName = new HTuple(), hv_ResultPrecisions = new HTuple();
        HTuple hv_Precision = new HTuple(), hv_ResultTimes = new HTuple();
        HTuple hv_ResultTop1Error = new HTuple(), hv_GlobalEval = new HTuple();
        HTuple hv_Top1Error = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            //This local procedure collects the results of benchmarking and evaluation in
            //the ResultCollector dictionary.
            //
            try
            {
                hv_ResultNames.Dispose();
                HOperatorSet.GetDictTuple(hv_ResultCollector, "name", out hv_ResultNames);
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException1)
            {
                HDevExpDefaultException1.ToHTuple(out hv_Exception);
                hv_ResultNames.Dispose();
                hv_ResultNames = new HTuple();
            }
            hv_Device.Dispose();
            HOperatorSet.GetDlModelParam(hv_DLModelHandle, "device", out hv_Device);
            hv_DeviceName.Dispose();
            HOperatorSet.GetDlDeviceParam(hv_Device, "name", out hv_DeviceName);
            hv_InterfaceName.Dispose();
            HOperatorSet.GetDlDeviceParam(hv_Device, "ai_accelerator_interface", out hv_InterfaceName);
            if ((int)(new HTuple(hv_InterfaceName.TupleNotEqual("none"))) != 0)
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_DeviceName = (hv_InterfaceName + "/") + hv_DeviceName;
                        hv_DeviceName.Dispose();
                        hv_DeviceName = ExpTmpLocalVar_DeviceName;
                    }
                }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                HOperatorSet.SetDictTuple(hv_ResultCollector, "name", hv_ResultNames.TupleConcat(
                    hv_DeviceName));
            }
            //
            try
            {
                hv_ResultPrecisions.Dispose();
                HOperatorSet.GetDictTuple(hv_ResultCollector, "precision", out hv_ResultPrecisions);
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException1)
            {
                HDevExpDefaultException1.ToHTuple(out hv_Exception);
                hv_ResultPrecisions.Dispose();
                hv_ResultPrecisions = new HTuple();
            }
            hv_Precision.Dispose();
            HOperatorSet.GetDlModelParam(hv_DLModelHandle, "precision", out hv_Precision);
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                HOperatorSet.SetDictTuple(hv_ResultCollector, "precision", hv_ResultPrecisions.TupleConcat(
                    hv_Precision));
            }
            //
            try
            {
                hv_ResultTimes.Dispose();
                HOperatorSet.GetDictTuple(hv_ResultCollector, "time_per_batch", out hv_ResultTimes);
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException1)
            {
                HDevExpDefaultException1.ToHTuple(out hv_Exception);
                hv_ResultTimes.Dispose();
                hv_ResultTimes = new HTuple();
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                HOperatorSet.SetDictTuple(hv_ResultCollector, "time_per_batch", hv_ResultTimes.TupleConcat(
                    hv_TimePerBatch));
            }
            //
            try
            {
                hv_ResultTop1Error.Dispose();
                HOperatorSet.GetDictTuple(hv_ResultCollector, "top1_error", out hv_ResultTop1Error);
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException1)
            {
                HDevExpDefaultException1.ToHTuple(out hv_Exception);
                hv_ResultTop1Error.Dispose();
                hv_ResultTop1Error = new HTuple();
            }
            hv_GlobalEval.Dispose();
            HOperatorSet.GetDictTuple(hv_EvaluationResult, "global", out hv_GlobalEval);
            hv_Top1Error.Dispose();
            HOperatorSet.GetDictTuple(hv_GlobalEval, "top1_error", out hv_Top1Error);
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                HOperatorSet.SetDictTuple(hv_ResultCollector, "top1_error", hv_ResultTop1Error.TupleConcat(
                    hv_Top1Error));
            }

            hv_ResultNames.Dispose();
            hv_Exception.Dispose();
            hv_Device.Dispose();
            hv_DeviceName.Dispose();
            hv_InterfaceName.Dispose();
            hv_ResultPrecisions.Dispose();
            hv_Precision.Dispose();
            hv_ResultTimes.Dispose();
            hv_ResultTop1Error.Dispose();
            hv_GlobalEval.Dispose();
            hv_Top1Error.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_ResultNames.Dispose();
            hv_Exception.Dispose();
            hv_Device.Dispose();
            hv_DeviceName.Dispose();
            hv_InterfaceName.Dispose();
            hv_ResultPrecisions.Dispose();
            hv_Precision.Dispose();
            hv_ResultTimes.Dispose();
            hv_ResultTop1Error.Dispose();
            hv_GlobalEval.Dispose();
            hv_Top1Error.Dispose();

            throw HDevExpDefaultException;
        }
    }

    public void dev_close_example_image_window(HTuple hv_ExampleInternals)
    {



        // Local control variables 

        HTuple hv_WindowHandleImages = new HTuple();
        HTuple hv_Exception = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            //This procedure closes the image window.

            try
            {
                hv_WindowHandleImages.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
                HDevWindowStack.SetActive(hv_WindowHandleImages);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                }
                //Delete key.
                HOperatorSet.RemoveDictKey(hv_ExampleInternals, "window_images");
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException1)
            {
                HDevExpDefaultException1.ToHTuple(out hv_Exception);
            }


            hv_WindowHandleImages.Dispose();
            hv_Exception.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_WindowHandleImages.Dispose();
            hv_Exception.Dispose();

            throw HDevExpDefaultException;
        }
    }

    public void dev_close_example_legend_window(HTuple hv_ExampleInternals)
    {



        // Local control variables 

        HTuple hv_WindowHandleLegend = new HTuple();
        HTuple hv_Exception = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            //This procedure closes the legend window.

            try
            {
                hv_WindowHandleLegend.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend", out hv_WindowHandleLegend);
                HDevWindowStack.SetActive(hv_WindowHandleLegend);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                }
                //Delete key.
                HOperatorSet.RemoveDictKey(hv_ExampleInternals, "window_legend");
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException1)
            {
                HDevExpDefaultException1.ToHTuple(out hv_Exception);
            }


            hv_WindowHandleLegend.Dispose();
            hv_Exception.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_WindowHandleLegend.Dispose();
            hv_Exception.Dispose();

            throw HDevExpDefaultException;
        }
    }

    public void dev_close_example_windows(HTuple hv_ExampleInternals)
    {



        // Local control variables 

        HTuple hv_ShowExampleScreens = new HTuple();
        HTuple hv_Keys = new HTuple(), hv_Index = new HTuple();
        HTuple hv_WindowHandle = new HTuple(), hv_Exception = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            //This procedure closes all example windows.
            //
            hv_ShowExampleScreens.Dispose();
            HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
            if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
            {

                hv_ShowExampleScreens.Dispose();
                hv_Keys.Dispose();
                hv_Index.Dispose();
                hv_WindowHandle.Dispose();
                hv_Exception.Dispose();

                return;
            }
            //
            hv_Keys.Dispose();
            HOperatorSet.GetDictParam(hv_ExampleInternals, "keys", new HTuple(), out hv_Keys);
            for (hv_Index = 0; (int)hv_Index <= (int)(new HTuple(hv_Keys.TupleLength())); hv_Index = (int)hv_Index + 1)
            {
                try
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_WindowHandle.Dispose();
                        HOperatorSet.GetDictTuple(hv_ExampleInternals, hv_Keys.TupleSelect(hv_Index),
                            out hv_WindowHandle);
                    }
                    HDevWindowStack.SetActive(hv_WindowHandle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                }
            }
            //

            hv_ShowExampleScreens.Dispose();
            hv_Keys.Dispose();
            hv_Index.Dispose();
            hv_WindowHandle.Dispose();
            hv_Exception.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_ShowExampleScreens.Dispose();
            hv_Keys.Dispose();
            hv_Index.Dispose();
            hv_WindowHandle.Dispose();
            hv_Exception.Dispose();

            throw HDevExpDefaultException;
        }
    }

    public void dev_display_example_continue_message(HTuple hv_ExampleInternals)
    {



        // Local control variables 

        HTuple hv_ShowExampleScreens = new HTuple();
        HTuple hv_WindowHandleText = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            hv_ShowExampleScreens.Dispose();
            HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
            if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();

                return;
            }

            hv_WindowHandleText.Dispose();
            HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
            HDevWindowStack.SetActive(hv_WindowHandleText);

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                    "window", "bottom", "right", "black", "box", "true");
            }

            hv_ShowExampleScreens.Dispose();
            hv_WindowHandleText.Dispose();

            return;

            hv_ShowExampleScreens.Dispose();
            hv_WindowHandleText.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_ShowExampleScreens.Dispose();
            hv_WindowHandleText.Dispose();

            throw HDevExpDefaultException;
        }
    }

    public void dev_display_example_reset_windows(HTuple hv_ExampleInternals)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_WindowHandlesToClose = new HTuple();
        HTuple hv_Exception = new HTuple(), hv_I = new HTuple();
        HTuple hv_WindowHandleKeys = new HTuple(), hv_Index = new HTuple();
        HTuple hv_WindowImagesNeeded = new HTuple(), hv_WindowLegendNeeded = new HTuple();
        HTuple hv_WindowHandleImages = new HTuple(), hv_WindowHandleLegend = new HTuple();
        HTuple hv_WindowHandleText = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            //This procedure resets the graphics windows.

            //Close any windows that are listed in key 'window_handles_to_close'.
            try
            {
                hv_WindowHandlesToClose.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_handles_to_close",
                    out hv_WindowHandlesToClose);
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException1)
            {
                HDevExpDefaultException1.ToHTuple(out hv_Exception);
                hv_WindowHandlesToClose.Dispose();
                hv_WindowHandlesToClose = new HTuple();
            }
            for (hv_I = 0; (int)hv_I <= (int)((new HTuple(hv_WindowHandlesToClose.TupleLength()
                )) - 1); hv_I = (int)hv_I + 1)
            {
                HDevWindowStack.SetActive(hv_WindowHandlesToClose.TupleSelect(
                    hv_I));
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                }
            }
            HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_handles_to_close", new HTuple());

            //Open image window if needed
            hv_WindowHandleKeys.Dispose();
            HOperatorSet.GetDictParam(hv_ExampleInternals, "keys", new HTuple(), out hv_WindowHandleKeys);
            hv_Index.Dispose();
            HOperatorSet.TupleFind(hv_WindowHandleKeys, "window_images", out hv_Index);
            hv_WindowImagesNeeded.Dispose();
            HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_needed", out hv_WindowImagesNeeded);
            if ((int)(hv_WindowImagesNeeded.TupleAnd(new HTuple(hv_Index.TupleEqual(-1)))) != 0)
            {
                //Open new window for images
                dev_open_example_image_window(hv_ExampleInternals);
            }
            else if ((int)((new HTuple(hv_WindowImagesNeeded.TupleNot())).TupleAnd(
                new HTuple(hv_Index.TupleNotEqual(-1)))) != 0)
            {
                //Window for images exists but is not needed -> close it
                dev_close_example_image_window(hv_ExampleInternals);
            }

            //Open legend window if needed
            hv_WindowHandleKeys.Dispose();
            HOperatorSet.GetDictParam(hv_ExampleInternals, "keys", new HTuple(), out hv_WindowHandleKeys);
            hv_Index.Dispose();
            HOperatorSet.TupleFind(hv_WindowHandleKeys, "window_legend", out hv_Index);
            hv_WindowLegendNeeded.Dispose();
            HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend_needed", out hv_WindowLegendNeeded);
            if ((int)(hv_WindowLegendNeeded.TupleAnd(new HTuple(hv_Index.TupleEqual(-1)))) != 0)
            {
                //Open new window for legend
                dev_open_example_legend_window(hv_ExampleInternals, 280);
            }
            else if ((int)((new HTuple(hv_WindowLegendNeeded.TupleNot())).TupleAnd(
                new HTuple(hv_Index.TupleNotEqual(-1)))) != 0)
            {
                //Window for legend exists but is not needed -> close it
                dev_close_example_legend_window(hv_ExampleInternals);
            }

            //Set the correct area (part) of the image window.
            try
            {
                hv_WindowHandleImages.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
                HDevWindowStack.SetActive(hv_WindowHandleImages);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                }
                //Set default window extends
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), 360, 0, 800,
                        500);
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetPart(HDevWindowStack.GetActive(), 1, 1, -1, -1);
                }
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException1)
            {
                HDevExpDefaultException1.ToHTuple(out hv_Exception);
            }

            //Set the correct area (part) of the legend window.
            try
            {
                hv_WindowHandleLegend.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend", out hv_WindowHandleLegend);
                HDevWindowStack.SetActive(hv_WindowHandleLegend);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetPart(HDevWindowStack.GetActive(), 1, 1, -1, -1);
                }
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException1)
            {
                HDevExpDefaultException1.ToHTuple(out hv_Exception);
            }
            hv_WindowHandleText.Dispose();
            HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
            HDevWindowStack.SetActive(hv_WindowHandleText);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
            }

            hv_WindowHandlesToClose.Dispose();
            hv_Exception.Dispose();
            hv_I.Dispose();
            hv_WindowHandleKeys.Dispose();
            hv_Index.Dispose();
            hv_WindowImagesNeeded.Dispose();
            hv_WindowLegendNeeded.Dispose();
            hv_WindowHandleImages.Dispose();
            hv_WindowHandleLegend.Dispose();
            hv_WindowHandleText.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_WindowHandlesToClose.Dispose();
            hv_Exception.Dispose();
            hv_I.Dispose();
            hv_WindowHandleKeys.Dispose();
            hv_Index.Dispose();
            hv_WindowImagesNeeded.Dispose();
            hv_WindowLegendNeeded.Dispose();
            hv_WindowHandleImages.Dispose();
            hv_WindowHandleLegend.Dispose();
            hv_WindowHandleText.Dispose();

            throw HDevExpDefaultException;
        }
    }

    public void dev_display_example_show_current_stage(HTuple hv_ExampleInternals,
        HTuple hv_Type, HTuple hv_Precision)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_ShowExampleScreens = new HTuple();
        HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            //This local procedure explains the current stage of the example
            //
            hv_ShowExampleScreens.Dispose();
            HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
            if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                return;
            }

            //Reset the open windows for a clean display.
            HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
            dev_display_example_reset_windows(hv_ExampleInternals);

            hv_WindowHandleText.Dispose();
            HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
            HDevWindowStack.SetActive(hv_WindowHandleText);

            if ((int)(new HTuple(hv_Type.TupleEqual("baseline"))) != 0)
            {
                hv_Text.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Text = ("Obtaining baseline for evaluation and benchmark with '" + hv_Precision) + "' precision.";
                }
            }
            else
            {
                hv_Text.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Text = ("Evaluating and benchmarking for OpenVINO? '" + hv_Type) + "' device";
                }
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = ("with '" + hv_Precision) + "' precision.";
            }
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            //
            if ((int)(new HTuple(hv_Type.TupleNotEqual("baseline"))) != 0)
            {
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = ("For '" + hv_Precision) + "' precision no calibration samples are needed since it";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = ("is a 'cast_precision'. Not all OpenVINO? devices support '" + hv_Precision) + "'.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            }

            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "This process might take some time.";

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                    "left", "black", "box", "true");
            }


            hv_ShowExampleScreens.Dispose();
            hv_WindowHandleText.Dispose();
            hv_Text.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_ShowExampleScreens.Dispose();
            hv_WindowHandleText.Dispose();
            hv_Text.Dispose();

            throw HDevExpDefaultException;
        }
    }

    public void dev_display_example_show_results(HTuple hv_ExampleInternals, HTuple hv_ResultCollector)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_ShowExampleScreens = new HTuple();
        HTuple hv_UsePretrainedModel = new HTuple(), hv_WindowHandleText = new HTuple();
        HTuple hv_MaxNameLength = new HTuple(), hv_MaxTimeLength = new HTuple();
        HTuple hv_MaxErrorLength = new HTuple(), hv_Names = new HTuple();
        HTuple hv_Precisions = new HTuple(), hv_TimesPerBatch = new HTuple();
        HTuple hv_Top1Errors = new HTuple(), hv_FullWidth = new HTuple();
        HTuple hv_Text = new HTuple(), hv_CaptionName = new HTuple();
        HTuple hv_CaptionTime = new HTuple(), hv_CaptionError = new HTuple();
        HTuple hv_Index = new HTuple(), hv_Name = new HTuple();
        HTuple hv_Precision = new HTuple(), hv_TimePerBatch = new HTuple();
        HTuple hv_Top1Error = new HTuple();
        HTuple hv_ExampleInternals_COPY_INP_TMP = new HTuple(hv_ExampleInternals);

        // Initialize local and output iconic variables 
        try
        {
            //This local procedure presents the results of the example in a table.
            //
            //Open window for result display if it has not been done so far.
            hv_ShowExampleScreens.Dispose();
            HOperatorSet.GetDictTuple(hv_ExampleInternals_COPY_INP_TMP, "show_example_screens",
                out hv_ShowExampleScreens);
            if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
            {
                hv_UsePretrainedModel.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals_COPY_INP_TMP, "use_pretrained_model",
                    out hv_UsePretrainedModel);
                hv_ExampleInternals_COPY_INP_TMP.Dispose();
                dev_example_init(1, hv_UsePretrainedModel, out hv_ExampleInternals_COPY_INP_TMP);
            }
            //
            //Reset the open windows for a clean display.
            HOperatorSet.SetDictTuple(hv_ExampleInternals_COPY_INP_TMP, "window_images_needed",
                0);
            dev_display_example_reset_windows(hv_ExampleInternals_COPY_INP_TMP);

            hv_WindowHandleText.Dispose();
            HOperatorSet.GetDictTuple(hv_ExampleInternals_COPY_INP_TMP, "window_text",
                out hv_WindowHandleText);
            HDevWindowStack.SetActive(hv_WindowHandleText);

            //Set the column sizes for the table
            hv_MaxNameLength.Dispose();
            hv_MaxNameLength = 40;
            hv_MaxTimeLength.Dispose();
            hv_MaxTimeLength = 15;
            hv_MaxErrorLength.Dispose();
            hv_MaxErrorLength = 11;

            hv_Names.Dispose();
            HOperatorSet.GetDictTuple(hv_ResultCollector, "name", out hv_Names);
            hv_Precisions.Dispose();
            HOperatorSet.GetDictTuple(hv_ResultCollector, "precision", out hv_Precisions);
            hv_TimesPerBatch.Dispose();
            HOperatorSet.GetDictTuple(hv_ResultCollector, "time_per_batch", out hv_TimesPerBatch);
            hv_Top1Errors.Dispose();
            HOperatorSet.GetDictTuple(hv_ResultCollector, "top1_error", out hv_Top1Errors);

            hv_FullWidth.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_FullWidth = (((((2 + hv_MaxNameLength) + 3) + hv_MaxTimeLength) + 3) + hv_MaxErrorLength) + 2;
            }
            hv_Text.Dispose();
            hv_Text = "This table presents the results obtained with different precisions.";
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Note that they strongly depend on the used OpenVINO? device.";
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = ((((("╔" + ((HTuple.TupleGenConst(
                hv_MaxNameLength + 2, "═")).TupleSum())) + "╤") + ((HTuple.TupleGenConst(hv_MaxTimeLength + 2,
                "═")).TupleSum())) + "╤") + ((HTuple.TupleGenConst(hv_MaxErrorLength + 2, "═")).TupleSum()
                )) + "╗";
            hv_CaptionName.Dispose();
            hv_CaptionName = "DeviceName [precision]";
            hv_CaptionTime.Dispose();
            hv_CaptionTime = "Time per Batch";
            hv_CaptionError.Dispose();
            hv_CaptionError = "Top1 Error";
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = ("║ " + hv_CaptionName) + ((HTuple.TupleGenConst(
                hv_MaxNameLength - (hv_CaptionName.TupleStrlen()), " ")).TupleSum());
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[(new HTuple(hv_Text.TupleLength())) - 1] = (((hv_Text.TupleSelect((new HTuple(hv_Text.TupleLength()
                )) - 1)) + " │ ") + ((HTuple.TupleGenConst(hv_MaxTimeLength - (hv_CaptionTime.TupleStrlen()
                ), " ")).TupleSum())) + hv_CaptionTime;
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[(new HTuple(hv_Text.TupleLength())) - 1] = (((hv_Text.TupleSelect((new HTuple(hv_Text.TupleLength()
                )) - 1)) + " │ ") + ((HTuple.TupleGenConst(hv_MaxErrorLength - (hv_CaptionError.TupleStrlen()
                ), " ")).TupleSum())) + hv_CaptionError;
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[(new HTuple(hv_Text.TupleLength())) - 1] = (hv_Text.TupleSelect((new HTuple(hv_Text.TupleLength()
                )) - 1)) + " ║";
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = ((((("╠" + ((HTuple.TupleGenConst(
                hv_MaxNameLength + 2, "═")).TupleSum())) + "╪") + ((HTuple.TupleGenConst(hv_MaxTimeLength + 2,
                "═")).TupleSum())) + "╪") + ((HTuple.TupleGenConst(hv_MaxErrorLength + 2, "═")).TupleSum()
                )) + "╣";

            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Names.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
            {
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "║ ";
                hv_Name.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Name = hv_Names.TupleSelect(
                        hv_Index);
                }
                hv_Precision.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Precision = hv_Precisions.TupleSelect(
                        hv_Index);
                }
                if ((int)(new HTuple(((((hv_Name.TupleStrlen()) + (hv_Precision.TupleStrlen()
                    )) + 3)).TupleGreater(hv_MaxNameLength))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Name = (hv_Name.TupleSubstr(
                                0, hv_MaxNameLength - ((hv_Precision.TupleStrlen()) + 7))) + "...";
                            hv_Name.Dispose();
                            hv_Name = ExpTmpLocalVar_Name;
                        }
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_Name = ((hv_Name + " [") + hv_Precision) + "]";
                        hv_Name.Dispose();
                        hv_Name = ExpTmpLocalVar_Name;
                    }
                }
                //right pad with spaces
                if ((int)(new HTuple(((hv_Name.TupleStrlen())).TupleLess(hv_MaxNameLength))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Name = hv_Name + ((HTuple.TupleGenConst(
                                hv_MaxNameLength - (hv_Name.TupleStrlen()), " ")).TupleSum());
                            hv_Name.Dispose();
                            hv_Name = ExpTmpLocalVar_Name;
                        }
                    }
                }
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[(new HTuple(hv_Text.TupleLength())) - 1] = ((hv_Text.TupleSelect((new HTuple(hv_Text.TupleLength()
                    )) - 1)) + hv_Name) + " │ ";
                //
                hv_TimePerBatch.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TimePerBatch = (hv_TimesPerBatch.TupleSelect(
                        hv_Index)) * 1000.0;
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_TimePerBatch = (hv_TimePerBatch.TupleString(
                            ".3f")) + " ms";
                        hv_TimePerBatch.Dispose();
                        hv_TimePerBatch = ExpTmpLocalVar_TimePerBatch;
                    }
                }
                //left pad with spaces
                if ((int)(new HTuple(((hv_TimePerBatch.TupleStrlen())).TupleLess(hv_MaxTimeLength))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TimePerBatch = ((HTuple.TupleGenConst(
                                hv_MaxTimeLength - (hv_TimePerBatch.TupleStrlen()), " ")).TupleSum()) + hv_TimePerBatch;
                            hv_TimePerBatch.Dispose();
                            hv_TimePerBatch = ExpTmpLocalVar_TimePerBatch;
                        }
                    }
                }
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[(new HTuple(hv_Text.TupleLength())) - 1] = ((hv_Text.TupleSelect((new HTuple(hv_Text.TupleLength()
                    )) - 1)) + hv_TimePerBatch) + " │ ";
                //
                hv_Top1Error.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Top1Error = (hv_Top1Errors.TupleSelect(
                        hv_Index)) * 100.0;
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_Top1Error = (hv_Top1Error.TupleString(
                            ".2f")) + " %";
                        hv_Top1Error.Dispose();
                        hv_Top1Error = ExpTmpLocalVar_Top1Error;
                    }
                }
                //left pad with spaces
                if ((int)(new HTuple(((hv_Top1Error.TupleStrlen())).TupleLess(hv_MaxErrorLength))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Top1Error = ((HTuple.TupleGenConst(
                                hv_MaxErrorLength - (hv_Top1Error.TupleStrlen()), " ")).TupleSum()) + hv_Top1Error;
                            hv_Top1Error.Dispose();
                            hv_Top1Error = ExpTmpLocalVar_Top1Error;
                        }
                    }
                }
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[(new HTuple(hv_Text.TupleLength())) - 1] = ((hv_Text.TupleSelect((new HTuple(hv_Text.TupleLength()
                    )) - 1)) + hv_Top1Error) + " ║";
            }
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = ((((("╚" + ((HTuple.TupleGenConst(
                hv_MaxNameLength + 2, "═")).TupleSum())) + "╧") + ((HTuple.TupleGenConst(hv_MaxTimeLength + 2,
                "═")).TupleSum())) + "╧") + ((HTuple.TupleGenConst(hv_MaxErrorLength + 2, "═")).TupleSum()
                )) + "╝";

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                    "left", "black", new HTuple(), new HTuple());
            }
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                    "window", "bottom", "right", "black", "box", "true");
            }

            hv_ExampleInternals_COPY_INP_TMP.Dispose();
            hv_ShowExampleScreens.Dispose();
            hv_UsePretrainedModel.Dispose();
            hv_WindowHandleText.Dispose();
            hv_MaxNameLength.Dispose();
            hv_MaxTimeLength.Dispose();
            hv_MaxErrorLength.Dispose();
            hv_Names.Dispose();
            hv_Precisions.Dispose();
            hv_TimesPerBatch.Dispose();
            hv_Top1Errors.Dispose();
            hv_FullWidth.Dispose();
            hv_Text.Dispose();
            hv_CaptionName.Dispose();
            hv_CaptionTime.Dispose();
            hv_CaptionError.Dispose();
            hv_Index.Dispose();
            hv_Name.Dispose();
            hv_Precision.Dispose();
            hv_TimePerBatch.Dispose();
            hv_Top1Error.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_ExampleInternals_COPY_INP_TMP.Dispose();
            hv_ShowExampleScreens.Dispose();
            hv_UsePretrainedModel.Dispose();
            hv_WindowHandleText.Dispose();
            hv_MaxNameLength.Dispose();
            hv_MaxTimeLength.Dispose();
            hv_MaxErrorLength.Dispose();
            hv_Names.Dispose();
            hv_Precisions.Dispose();
            hv_TimesPerBatch.Dispose();
            hv_Top1Errors.Dispose();
            hv_FullWidth.Dispose();
            hv_Text.Dispose();
            hv_CaptionName.Dispose();
            hv_CaptionTime.Dispose();
            hv_CaptionError.Dispose();
            hv_Index.Dispose();
            hv_Name.Dispose();
            hv_Precision.Dispose();
            hv_TimePerBatch.Dispose();
            hv_Top1Error.Dispose();

            throw HDevExpDefaultException;
        }
    }

    public void dev_display_screen_device_settable_params(HTuple hv_ExampleInternals,
        HTuple hv_DLDevice)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_WindowHandleText = new HTuple();
        HTuple hv_DLDeviceType = new HTuple(), hv_SettableDeviceParams = new HTuple();
        HTuple hv_Keys = new HTuple(), hv_MaxAscent = new HTuple();
        HTuple hv_MaxDescent = new HTuple(), hv_MaxWidth = new HTuple();
        HTuple hv_MaxHeight = new HTuple(), hv_Row = new HTuple();
        HTuple hv_Column = new HTuple(), hv_Width = new HTuple();
        HTuple hv_Height = new HTuple(), hv_MaxNumLines = new HTuple();
        HTuple hv_DLDeviceInfo = new HTuple(), hv_OpenVINOVersion = new HTuple();
        HTuple hv_Text = new HTuple(), hv_Index = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            //This procedure displays information about the used device.

            //Reset the open windows for a clean display.
            HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
            HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
            dev_display_example_reset_windows(hv_ExampleInternals);

            //Display the explanatory text.
            hv_WindowHandleText.Dispose();
            HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
            HDevWindowStack.SetActive(hv_WindowHandleText);

            hv_DLDeviceType.Dispose();
            HOperatorSet.GetDlDeviceParam(hv_DLDevice, "type", out hv_DLDeviceType);
            hv_SettableDeviceParams.Dispose();
            HOperatorSet.GetDlDeviceParam(hv_DLDevice, "settable_device_params", out hv_SettableDeviceParams);
            hv_Keys.Dispose();
            HOperatorSet.GetDictParam(hv_SettableDeviceParams, "keys", new HTuple(), out hv_Keys);

            hv_MaxAscent.Dispose(); hv_MaxDescent.Dispose(); hv_MaxWidth.Dispose(); hv_MaxHeight.Dispose();
            HOperatorSet.GetFontExtents(hv_WindowHandleText, out hv_MaxAscent, out hv_MaxDescent,
                out hv_MaxWidth, out hv_MaxHeight);
            hv_Row.Dispose(); hv_Column.Dispose(); hv_Width.Dispose(); hv_Height.Dispose();
            HOperatorSet.GetWindowExtents(hv_WindowHandleText, out hv_Row, out hv_Column,
                out hv_Width, out hv_Height);
            hv_MaxNumLines.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_MaxNumLines = ((hv_Height / hv_MaxHeight)).TupleFloor()
                    ;
            }

            hv_DLDeviceInfo.Dispose();
            HOperatorSet.GetDlDeviceParam(hv_DLDevice, "info", out hv_DLDeviceInfo);
            hv_OpenVINOVersion.Dispose();
            HOperatorSet.GetDictTuple(hv_DLDeviceInfo, "openvino_version", out hv_OpenVINOVersion);

            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_Text = ("In the following an OpenVINO? '" + hv_DLDeviceType) + "' device will be used.";
            }
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "The OpenVINO? AI2-interface allows to change available OpenVINO? device";
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "settings via the 'settable_device_params' device parameter. For an";
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "explanation of the parameters we refer to the documentation of the";
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = ("Intel? Distribution of the OpenVINO? Toolkit (Version " + hv_OpenVINOVersion) + ")";
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "The selected device supports the following settings:";
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Keys.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
            {
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = ("- '" + (hv_Keys.TupleSelect(
                    hv_Index))) + "'";
                //Stay within window boundaries
                if ((int)(new HTuple(((hv_Index + 13)).TupleGreaterEqual(hv_MaxNumLines))) != 0)
                {
                    if (hv_Text == null)
                        hv_Text = new HTuple();
                    hv_Text[new HTuple(hv_Text.TupleLength())] = "- and more...";
                    break;
                }
            }
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";


            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                    "left", "black", "box", "true");
            }
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                    "window", "bottom", "right", "black", new HTuple(), new HTuple());
            }


            hv_WindowHandleText.Dispose();
            hv_DLDeviceType.Dispose();
            hv_SettableDeviceParams.Dispose();
            hv_Keys.Dispose();
            hv_MaxAscent.Dispose();
            hv_MaxDescent.Dispose();
            hv_MaxWidth.Dispose();
            hv_MaxHeight.Dispose();
            hv_Row.Dispose();
            hv_Column.Dispose();
            hv_Width.Dispose();
            hv_Height.Dispose();
            hv_MaxNumLines.Dispose();
            hv_DLDeviceInfo.Dispose();
            hv_OpenVINOVersion.Dispose();
            hv_Text.Dispose();
            hv_Index.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_WindowHandleText.Dispose();
            hv_DLDeviceType.Dispose();
            hv_SettableDeviceParams.Dispose();
            hv_Keys.Dispose();
            hv_MaxAscent.Dispose();
            hv_MaxDescent.Dispose();
            hv_MaxWidth.Dispose();
            hv_MaxHeight.Dispose();
            hv_Row.Dispose();
            hv_Column.Dispose();
            hv_Width.Dispose();
            hv_Height.Dispose();
            hv_MaxNumLines.Dispose();
            hv_DLDeviceInfo.Dispose();
            hv_OpenVINOVersion.Dispose();
            hv_Text.Dispose();
            hv_Index.Dispose();

            throw HDevExpDefaultException;
        }
    }

    public void dev_display_screen_devices(HTuple hv_ExampleInternals, HTuple hv_DLDevices)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_I = new HTuple(), hv_WindowHandleText = new HTuple();
        HTuple hv_DLDevice = new HTuple(), hv_DLDeviceName = new HTuple();
        HTuple hv_MaxNameLength = new HTuple(), hv_DLDeviceType = new HTuple();
        HTuple hv_DLDeviceInfo = new HTuple(), hv_OpenVINODeviceId = new HTuple();
        HTuple hv_Precisions = new HTuple(), hv_Text = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            //This procedure displays information about the used device.

            //Reset the open windows for a clean display.
            HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
            HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
            //
            if ((int)(new HTuple(hv_DLDevices.TupleNotEqual(new HTuple()))) != 0)
            {
                for (hv_I = 0; (int)hv_I <= (int)((new HTuple(hv_DLDevices.TupleLength())) - 1); hv_I = (int)hv_I + 1)
                {
                    dev_display_example_reset_windows(hv_ExampleInternals);
                    //
                    //Display the explanatory text.
                    hv_WindowHandleText.Dispose();
                    HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                    HDevWindowStack.SetActive(hv_WindowHandleText);
                    hv_DLDevice.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DLDevice = hv_DLDevices.TupleSelect(
                            hv_I);
                    }
                    hv_DLDeviceName.Dispose();
                    HOperatorSet.GetDlDeviceParam(hv_DLDevice, "name", out hv_DLDeviceName);
                    hv_MaxNameLength.Dispose();
                    hv_MaxNameLength = 50;
                    if ((int)(new HTuple(((hv_DLDeviceName.TupleStrlen())).TupleGreater(hv_MaxNameLength))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_DLDeviceName = (hv_DLDeviceName.TupleSubstr(
                                    0, hv_MaxNameLength - 4)) + " ...";
                                hv_DLDeviceName.Dispose();
                                hv_DLDeviceName = ExpTmpLocalVar_DLDeviceName;
                            }
                        }
                    }
                    hv_DLDeviceType.Dispose();
                    HOperatorSet.GetDlDeviceParam(hv_DLDevice, "type", out hv_DLDeviceType);
                    hv_DLDeviceInfo.Dispose();
                    HOperatorSet.GetDlDeviceParam(hv_DLDevice, "info", out hv_DLDeviceInfo);
                    hv_OpenVINODeviceId.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDeviceInfo, "openvino_device_id", out hv_OpenVINODeviceId);
                    hv_Precisions.Dispose();
                    HOperatorSet.GetDlDeviceParam(hv_DLDevice, "precisions", out hv_Precisions);
                    if ((int)(new HTuple((new HTuple(hv_Precisions.TupleLength())).TupleEqual(
                        0))) != 0)
                    {
                        hv_Precisions.Dispose();
                        hv_Precisions = "N.A.";
                    }
                    if ((int)(new HTuple((new HTuple(hv_Precisions.TupleLength())).TupleGreater(
                        1))) != 0)
                    {
                        if (hv_Precisions == null)
                            hv_Precisions = new HTuple();
                        hv_Precisions[HTuple.TupleGenSequence(0, (new HTuple(hv_Precisions.TupleLength()
                            )) - 2, 1)] = (hv_Precisions.TupleSelectRange(0, (new HTuple(hv_Precisions.TupleLength()
                            )) - 2)) + new HTuple(", ");
                    }
                    hv_Text.Dispose();
                    hv_Text = new HTuple();
                    if (hv_Text == null)
                        hv_Text = new HTuple();
                    hv_Text[new HTuple(hv_Text.TupleLength())] = "Device name:          " + hv_DLDeviceName;
                    if (hv_Text == null)
                        hv_Text = new HTuple();
                    hv_Text[new HTuple(hv_Text.TupleLength())] = "Device type:          " + hv_DLDeviceType;
                    if (hv_Text == null)
                        hv_Text = new HTuple();
                    hv_Text[new HTuple(hv_Text.TupleLength())] = "Supported precisions: " + (hv_Precisions.TupleSum()
                        );
                    if (hv_Text == null)
                        hv_Text = new HTuple();
                    hv_Text[new HTuple(hv_Text.TupleLength())] = "OpenVINO? device id:  " + hv_OpenVINODeviceId;

                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                            "top", "left", "black", "box", "true");
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                            "window", "bottom", "right", "black", new HTuple(), new HTuple());
                    }
                    // stop(...); only in hdevelop
                }
            }


            hv_I.Dispose();
            hv_WindowHandleText.Dispose();
            hv_DLDevice.Dispose();
            hv_DLDeviceName.Dispose();
            hv_MaxNameLength.Dispose();
            hv_DLDeviceType.Dispose();
            hv_DLDeviceInfo.Dispose();
            hv_OpenVINODeviceId.Dispose();
            hv_Precisions.Dispose();
            hv_Text.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_I.Dispose();
            hv_WindowHandleText.Dispose();
            hv_DLDevice.Dispose();
            hv_DLDeviceName.Dispose();
            hv_MaxNameLength.Dispose();
            hv_DLDeviceType.Dispose();
            hv_DLDeviceInfo.Dispose();
            hv_OpenVINODeviceId.Dispose();
            hv_Precisions.Dispose();
            hv_Text.Dispose();

            throw HDevExpDefaultException;
        }
    }

    public void dev_display_screen_devices_prelim(HTuple hv_ExampleInternals, HTuple hv_DLDevices)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_WindowHandleText = new HTuple();
        HTuple hv_Text = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            //This procedure displays information about the used device.

            //Reset the open windows for a clean display.
            HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
            HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
            dev_display_example_reset_windows(hv_ExampleInternals);

            //Display the explanatory text.
            hv_WindowHandleText.Dispose();
            HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
            HDevWindowStack.SetActive(hv_WindowHandleText);

            hv_Text.Dispose();
            hv_Text = "This example needs the OpenVINO? AI2-interface.";
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if ((int)(new HTuple(hv_DLDevices.TupleEqual(new HTuple()))) != 0)
            {
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "No OpenVINO? AI2-interface or devices available.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            }
            else
            {
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "It will run the deep learning operators on one of the following";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "devices. As default the first device of type 'CPU' is selected.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "Note: the OpenVINO? plugin supports only Intel? GPUs.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "If you want to infer on NVIDIA? GPUs consider using";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "the TensorRT? plugin that offers a great performance.";
            }

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                    "left", "black", "box", "true");
            }
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                    "window", "bottom", "right", "black", new HTuple(), new HTuple());
            }


            hv_WindowHandleText.Dispose();
            hv_Text.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_WindowHandleText.Dispose();
            hv_Text.Dispose();

            throw HDevExpDefaultException;
        }
    }

    public void dev_display_screen_introduction(HTuple hv_ExampleInternals)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_ShowExampleScreens = new HTuple();
        HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            //This procedure shows an overview on all example parts.

            hv_ShowExampleScreens.Dispose();
            HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
            if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                return;
            }

            //Reset the open windows for a clean display.
            HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
            dev_display_example_reset_windows(hv_ExampleInternals);

            hv_WindowHandleText.Dispose();
            HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
            HDevWindowStack.SetActive(hv_WindowHandleText);

            //Display introductional text.
            hv_Text.Dispose();
            hv_Text = "This example demonstrates the use of the HALCON AI2-interface for";
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "the Intel? Distribution of the OpenVINO? Toolkit.";
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "It shows how to optimize a trained classification model with";
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "the operator 'optimize_dl_model_for_inference' for different";
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "precisions and devices supported by OpenVINO?.";
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "This example requires the output of part 1 of the deep-learning";
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("classification example series. Per default, a pretrained");
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "classification network is used. To use your own trained model";
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "run part 2 of the series and set UsePretrainedModel to false";
            if (hv_Text == null)
                hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "further above in the example.";

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                    "left", "black", "box", "true");
            }
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                    "window", "bottom", "right", "black", "box", "true");
            }


            hv_ShowExampleScreens.Dispose();
            hv_WindowHandleText.Dispose();
            hv_Text.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_ShowExampleScreens.Dispose();
            hv_WindowHandleText.Dispose();
            hv_Text.Dispose();

            throw HDevExpDefaultException;
        }
    }

    public void dev_example_init(HTuple hv_ShowExampleScreens, HTuple hv_UsePretrainedModel,
        out HTuple hv_ExampleInternals)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_WindowWidthText = new HTuple(), hv_WindowHeightText = new HTuple();
        HTuple hv_WindowBGColor = new HTuple(), hv_WindowHandleText = new HTuple();
        // Initialize local and output iconic variables 
        hv_ExampleInternals = new HTuple();
        try
        {
            //This procedure initializes the graphic windows that are used for explanations during the example.

            //A dictionary that will be used/adapted by other example procedures.
            hv_ExampleInternals.Dispose();
            HOperatorSet.CreateDict(out hv_ExampleInternals);
            HOperatorSet.SetDictTuple(hv_ExampleInternals, "show_example_screens", hv_ShowExampleScreens);
            HOperatorSet.SetDictTuple(hv_ExampleInternals, "use_pretrained_model", hv_UsePretrainedModel);
            //
            HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
            HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
            if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
            {

                hv_WindowWidthText.Dispose();
                hv_WindowHeightText.Dispose();
                hv_WindowBGColor.Dispose();
                hv_WindowHandleText.Dispose();

                return;
            }

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.CloseWindow(HDevWindowStack.Pop());
            }
            hv_WindowWidthText.Dispose();
            hv_WindowWidthText = 800;
            hv_WindowHeightText.Dispose();
            hv_WindowHeightText = 300;
            hv_WindowBGColor.Dispose();
            hv_WindowBGColor = "gray";
            HOperatorSet.SetWindowAttr("background_color", hv_WindowBGColor);
            HOperatorSet.OpenWindow(0, 0, hv_WindowWidthText, hv_WindowHeightText, 0, "visible", "", out hv_WindowHandleText);
            HDevWindowStack.Push(hv_WindowHandleText);
            set_display_font(hv_WindowHandleText, 16, "mono", "true", "false");
            HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_text", hv_WindowHandleText);
            HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_text_width", hv_WindowWidthText);
            HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_text_height", hv_WindowHeightText);



            hv_WindowWidthText.Dispose();
            hv_WindowHeightText.Dispose();
            hv_WindowBGColor.Dispose();
            hv_WindowHandleText.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_WindowWidthText.Dispose();
            hv_WindowHeightText.Dispose();
            hv_WindowBGColor.Dispose();
            hv_WindowHandleText.Dispose();

            throw HDevExpDefaultException;
        }
    }

    public void dev_open_example_image_window(HTuple hv_ExampleInternals)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_WindowHeightText = new HTuple();
        HTuple hv_WindowWidthImage = new HTuple(), hv_WindowHeightImages = new HTuple();
        HTuple hv_WindowBGColor = new HTuple(), hv_WindowYImages = new HTuple();
        HTuple hv_WindowXImages = new HTuple(), hv_WindowHandleImages = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            //This procedure initializes the graphic windows that are used to display example images.

            hv_WindowHeightText.Dispose();
            hv_WindowHeightText = 300;
            hv_WindowWidthImage.Dispose();
            hv_WindowWidthImage = 500;
            hv_WindowHeightImages.Dispose();
            hv_WindowHeightImages = 500;
            hv_WindowBGColor.Dispose();
            hv_WindowBGColor = "gray";

            hv_WindowYImages.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_WindowYImages = hv_WindowHeightText + 60;
            }
            hv_WindowXImages.Dispose();
            hv_WindowXImages = 0;
            HOperatorSet.SetWindowAttr("background_color", hv_WindowBGColor);
            HOperatorSet.OpenWindow(hv_WindowYImages, hv_WindowXImages, hv_WindowWidthImage, hv_WindowHeightImages, 0, "visible", "", out hv_WindowHandleImages);
            HDevWindowStack.Push(hv_WindowHandleImages);
            set_display_font(hv_WindowHandleImages, 16, "mono", "true", "false");
            HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images", hv_WindowHandleImages);
            HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_width", hv_WindowWidthImage);
            HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_height", hv_WindowHeightImages);
            HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_x", hv_WindowXImages);
            HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_y", hv_WindowYImages);

            hv_WindowHeightText.Dispose();
            hv_WindowWidthImage.Dispose();
            hv_WindowHeightImages.Dispose();
            hv_WindowBGColor.Dispose();
            hv_WindowYImages.Dispose();
            hv_WindowXImages.Dispose();
            hv_WindowHandleImages.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_WindowHeightText.Dispose();
            hv_WindowWidthImage.Dispose();
            hv_WindowHeightImages.Dispose();
            hv_WindowBGColor.Dispose();
            hv_WindowYImages.Dispose();
            hv_WindowXImages.Dispose();
            hv_WindowHandleImages.Dispose();

            throw HDevExpDefaultException;
        }
    }

    public void dev_open_example_legend_window(HTuple hv_ExampleInternals, HTuple hv_WindowWidth)
    {



        // Local control variables 

        HTuple hv_WindowImagesHeight = new HTuple();
        HTuple hv_WindowImagesWidth = new HTuple(), hv_WindowImagesX = new HTuple();
        HTuple hv_WindowImagesY = new HTuple(), hv_WindowHandleLegend = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            //This procedure initializes the graphic windows that are used to display a legend.

            hv_WindowImagesHeight.Dispose();
            HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_height", out hv_WindowImagesHeight);
            hv_WindowImagesWidth.Dispose();
            HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_width", out hv_WindowImagesWidth);
            hv_WindowImagesX.Dispose();
            HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_x", out hv_WindowImagesX);
            hv_WindowImagesY.Dispose();
            HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_y", out hv_WindowImagesY);
            HOperatorSet.SetWindowAttr("background_color", "black");
            HOperatorSet.OpenWindow(hv_WindowImagesY, (hv_WindowImagesX + hv_WindowImagesWidth) + 5, hv_WindowWidth, hv_WindowImagesHeight, 0, "visible", "", out hv_WindowHandleLegend);
            HDevWindowStack.Push(hv_WindowHandleLegend);
            set_display_font(hv_WindowHandleLegend, 14, "mono", "true", "false");
            HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend", hv_WindowHandleLegend);

            hv_WindowImagesHeight.Dispose();
            hv_WindowImagesWidth.Dispose();
            hv_WindowImagesX.Dispose();
            hv_WindowImagesY.Dispose();
            hv_WindowHandleLegend.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_WindowImagesHeight.Dispose();
            hv_WindowImagesWidth.Dispose();
            hv_WindowImagesX.Dispose();
            hv_WindowImagesY.Dispose();
            hv_WindowHandleLegend.Dispose();

            throw HDevExpDefaultException;
        }
    }

#if !NO_EXPORT_MAIN
    // Main procedure 
    private void action()
    {


        // Local iconic variables 

        // Local control variables 

        HTuple hv_ShowExampleScreens = new HTuple();
        HTuple hv_UsePretrainedModel = new HTuple(), hv_DLDeviceHandlesOpenVINO = new HTuple();
        HTuple hv_DLDeviceHandleCpu = new HTuple(), hv_ExampleInternals = new HTuple();
        HTuple hv_OpenVINODeviceType = new HTuple(), hv_DLDeviceHandleOpenVINO = new HTuple();
        HTuple hv_I = new HTuple(), hv_DeviceType = new HTuple();
        HTuple hv_ExampleDir = new HTuple(), hv_DLExampleDir = new HTuple();
        HTuple hv_ExampleDataDir = new HTuple(), hv_DataDirectory = new HTuple();
        HTuple hv_DLDatasetFileName = new HTuple(), hv_RetrainedModelFileName = new HTuple();
        HTuple hv_ClassificationMeasures = new HTuple(), hv_BatchSize = new HTuple();
        HTuple hv_DLModelHandle = new HTuple(), hv_DLDataset = new HTuple();
        HTuple hv_DLSampleDir = new HTuple(), hv_FileExists = new HTuple();
        HTuple hv_ResultCollector = new HTuple(), hv_GenParamEval = new HTuple();
        HTuple hv_EvaluationResultBaseLine = new HTuple(), hv_EvalParams = new HTuple();
        HTuple hv_TimePerBatchBaseLine = new HTuple(), hv_CastPrecisions = new HTuple();
        HTuple hv_IndexFP32 = new HTuple(), hv_OptimizeForInferenceParams = new HTuple();
        HTuple hv_DLModelHandleOpenVINO = new HTuple(), hv_ConversionReport = new HTuple();
        HTuple hv_EvaluationResultOpenVINO = new HTuple(), hv_TimePerBatchOpenVINO = new HTuple();
        HTuple hv_IndexFP16 = new HTuple(), hv_IndexBFP16 = new HTuple();
        // Initialize local and output iconic variables 
        try
        {
            //
            //This example shows how to optimize a trained classification model for
            //inference using the AI2-interface for the Intel? Distribution of the
            //OpenVINO? Toolkit.
            //
            //Please note: This example builds on output of the example
            //series for deep learning classification:
            //- The preprocessed images of part 1 classify_pill_defects_deep_learning_1_preprocess.hdev.
            //- (optional) The pretrained model of part 2 classify_pill_defects_deep_learning_2_train.hdev
            //   if you set UsePretrainedModel := false.
            //
            dev_update_off();
            //
            //In this example, the optimization is explained in graphics windows,
            //before it is executed. Set the following parameter to false in order to
            //skip this visualization.
            hv_ShowExampleScreens.Dispose();
            hv_ShowExampleScreens = 1;
            //
            //By default, this example uses a model pretrained by MVTec. To use the model
            //which was trained in part 2 of this example series, set the following
            //variable to false.
            hv_UsePretrainedModel.Dispose();
            hv_UsePretrainedModel = 1;
            //
            //This example needs the HALCON AI2-interface for the Intel? Distribution of the OpenVINO? Toolkit
            hv_DLDeviceHandlesOpenVINO.Dispose();
            HOperatorSet.QueryAvailableDlDevices("ai_accelerator_interface", "openvino",
                out hv_DLDeviceHandlesOpenVINO);
            if ((int)(new HTuple((new HTuple(hv_DLDeviceHandlesOpenVINO.TupleLength())).TupleEqual(
                0))) != 0)
            {
                throw new HalconException(new HTuple("No supported device found to continue this example. ") + "Ensure that the OpenVINO? AI2-interface is installed!");
            }
            //This example will also need a CPU (default) device.
            hv_DLDeviceHandleCpu.Dispose();
            HOperatorSet.QueryAvailableDlDevices((new HTuple("runtime")).TupleConcat("id"),
                (new HTuple("cpu")).TupleConcat(0), out hv_DLDeviceHandleCpu);
            if ((int)(new HTuple((new HTuple(hv_DLDeviceHandleCpu.TupleLength())).TupleEqual(
                0))) != 0)
            {
                throw new HalconException("No supported device found to continue this example.");
            }
            //
            //Initial example windows and parameters etc.
            hv_ExampleInternals.Dispose();
            dev_example_init(hv_ShowExampleScreens, hv_UsePretrainedModel, out hv_ExampleInternals);
            if ((int)(hv_ShowExampleScreens) != 0)
            {
                //
                //Example series introduction text.
                dev_display_screen_introduction(hv_ExampleInternals);
                // stop(...); only in hdevelop
                //
                dev_display_screen_devices_prelim(hv_ExampleInternals, hv_DLDeviceHandlesOpenVINO);
                // stop(...); only in hdevelop
                //
                dev_display_screen_devices(hv_ExampleInternals, hv_DLDeviceHandlesOpenVINO);
            }
            //
            //Select OpenVINO? device.
            //
            //The device parameter 'type' can be used for further selection.
            //It states the OpenVINO? plugin responsible for handling the
            //device. Depending on your OpenVINO? installation, possible values
            //are 'CPU' and 'GPU'.
            hv_OpenVINODeviceType.Dispose();
            hv_OpenVINODeviceType = "CPU";
            hv_DLDeviceHandleOpenVINO.Dispose();
            hv_DLDeviceHandleOpenVINO = new HTuple();
            for (hv_I = 0; (int)hv_I <= (int)((new HTuple(hv_DLDeviceHandlesOpenVINO.TupleLength()
                )) - 1); hv_I = (int)hv_I + 1)
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DeviceType.Dispose();
                    HOperatorSet.GetDlDeviceParam(hv_DLDeviceHandlesOpenVINO.TupleSelect(hv_I),
                        "type", out hv_DeviceType);
                }
                if ((int)(new HTuple(hv_DeviceType.TupleEqual(hv_OpenVINODeviceType))) != 0)
                {
                    //Break on first occurance of requested device type
                    hv_DLDeviceHandleOpenVINO.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DLDeviceHandleOpenVINO = hv_DLDeviceHandlesOpenVINO.TupleSelect(
                            hv_I);
                    }
                    //To select a specific device the key 'openvino_device_id'
                    //of the device parameter 'info' can be used. It contains
                    //the "native" OpenVINO? device identifier.
                    break;
                }
            }
            if ((int)(new HTuple((new HTuple(hv_DLDeviceHandleOpenVINO.TupleLength())).TupleEqual(
                0))) != 0)
            {
                throw new HalconException(("No OpenVINO device of type " + hv_OpenVINODeviceType) + " found.");
            }
            //
            if ((int)(hv_ShowExampleScreens) != 0)
            {
                dev_display_screen_device_settable_params(hv_ExampleInternals, hv_DLDeviceHandleOpenVINO);
                // stop(...); only in hdevelop
            }
            //
            //
            //********************************************************
            //**   Set paths and parameters for the evaluation     ***
            //********************************************************
            //
            //Paths.
            //
            //Project directory for any outputs written by HALCON.
            hv_ExampleDir.Dispose();
            HOperatorSet.GetSystem("example_dir", out hv_ExampleDir);
            hv_DLExampleDir.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_DLExampleDir = hv_ExampleDir + "/hdevelop/Deep-Learning/Classification";
            }
            hv_ExampleDataDir.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_ExampleDataDir = hv_DLExampleDir + "/classify_pill_defects_data";
            }
            //File path of the preprocessed DLDataset.
            //Note: Adapt DataDirectory after preprocessing with another image size.
            hv_DataDirectory.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_DataDirectory = hv_ExampleDataDir + "/dldataset_pill_300x300";
            }
            hv_DLDatasetFileName.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_DLDatasetFileName = hv_DataDirectory + "/dl_dataset.hdict";
            }
            //
            if ((int)(hv_UsePretrainedModel) != 0)
            {
                //Use the pretrained model shipping with HALCON.
                hv_RetrainedModelFileName.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RetrainedModelFileName = hv_DLExampleDir + "/classify_pill_defects.hdl";
                }
            }
            else
            {
                //Path of the retrained classification model.
                hv_RetrainedModelFileName.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RetrainedModelFileName = hv_ExampleDataDir + "/best_dl_model_classification.hdl";
                }
            }
            //
            //Evaluation parameters.
            //
            //Evaluation measures.
            hv_ClassificationMeasures.Dispose();
            hv_ClassificationMeasures = "top1_error";
            //Batch size used during evaluation and benchmarking.
            //Use BatchSize = 1 as most realistic value for inferencing.
            hv_BatchSize.Dispose();
            hv_BatchSize = 1;
            //
            //*************************************************************
            //**   Optimization of the model for different precisions   ***
            //*************************************************************
            //
            //Check if all necessary files exist.
            check_data_availability(hv_ExampleDataDir, hv_DLDatasetFileName, hv_RetrainedModelFileName,
                hv_UsePretrainedModel);
            //
            //Read the retrained model.
            hv_DLModelHandle.Dispose();
            HOperatorSet.ReadDlModel(hv_RetrainedModelFileName, out hv_DLModelHandle);
            HOperatorSet.SetDlModelParam(hv_DLModelHandle, "batch_size", hv_BatchSize);
            HOperatorSet.SetDlModelParam(hv_DLModelHandle, "device", hv_DLDeviceHandleCpu);
            //
            //Read the preprocessed DLDataset file.
            hv_DLDataset.Dispose();
            HOperatorSet.ReadDict(hv_DLDatasetFileName, new HTuple(), new HTuple(), out hv_DLDataset);
            //
            //Try to adjust the DL sample root folder if necessary.
            hv_DLSampleDir.Dispose();
            HOperatorSet.GetDictTuple(hv_DLDataset, "dlsample_dir", out hv_DLSampleDir);
            hv_FileExists.Dispose();
            HOperatorSet.FileExists(hv_DLSampleDir, out hv_FileExists);
            if ((int)(hv_FileExists.TupleNot()) != 0)
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_FileExists.Dispose();
                    HOperatorSet.FileExists((hv_DLExampleDir + "/") + hv_DLSampleDir, out hv_FileExists);
                }
                if ((int)(hv_FileExists.TupleNot()) != 0)
                {
                    throw new HalconException(
                        (new HTuple(30000)).TupleConcat("'dlsample_dir' of dataset does not exist."));
                }
                else
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_DLDataset, "dlsample_dir", (hv_DLExampleDir + "/") + hv_DLSampleDir);
                    }
                }
            }
            //
            //Use a dictionary to collect the results obtained in this example.
            hv_ResultCollector.Dispose();
            HOperatorSet.CreateDict(out hv_ResultCollector);
            //
            //Set parameters for evaluation.
            hv_GenParamEval.Dispose();
            HOperatorSet.CreateDict(out hv_GenParamEval);
            HOperatorSet.SetDictTuple(hv_GenParamEval, "measures", hv_ClassificationMeasures);
            //
            //First, evaluate the retrained model on the baseline device.
            //
            dev_display_example_show_current_stage(hv_ExampleInternals, "baseline", "float32");
            hv_EvaluationResultBaseLine.Dispose(); hv_EvalParams.Dispose();
            evaluate_dl_model(hv_DLDataset, hv_DLModelHandle, "split", "test", hv_GenParamEval,
                out hv_EvaluationResultBaseLine, out hv_EvalParams);
            //
            //Benchmark the retrained model on the baseline device.
            hv_TimePerBatchBaseLine.Dispose();
            bench_dl_model(hv_DLModelHandle, hv_DLDataset, out hv_TimePerBatchBaseLine);

            //Add the results to the ResultCollector.
            collect_results(hv_ResultCollector, hv_DLModelHandle, hv_TimePerBatchBaseLine,
                hv_EvaluationResultBaseLine);
            if ((int)(hv_ShowExampleScreens) != 0)
            {
                dev_display_example_continue_message(hv_ExampleInternals);
                // stop(...); only in hdevelop
            }
            //
            //
            //Now, optimize the retrained model for 'float32' inference on the OpenVINO? device, if this precision
            //is available for the selected device.
            hv_CastPrecisions.Dispose();
            HOperatorSet.GetDlDeviceParam(hv_DLDeviceHandleOpenVINO, "cast_precisions",
                out hv_CastPrecisions);
            hv_IndexFP32.Dispose();
            HOperatorSet.TupleFindFirst(hv_CastPrecisions, "float32", out hv_IndexFP32);
            if ((int)(new HTuple(hv_IndexFP32.TupleGreaterEqual(0))) != 0)
            {
                dev_display_example_show_current_stage(hv_ExampleInternals, hv_OpenVINODeviceType,
                    "float32");
                //
                //To convert the model to 'float32' precision, no samples have to be provided to
                //optimize_dl_model_for_inference.
                //No additional conversion parameters are required, so use the default parameters.
                hv_OptimizeForInferenceParams.Dispose();
                HOperatorSet.GetDlDeviceParam(hv_DLDeviceHandleOpenVINO, "optimize_for_inference_params",
                    out hv_OptimizeForInferenceParams);
                hv_DLModelHandleOpenVINO.Dispose(); hv_ConversionReport.Dispose();
                HOperatorSet.OptimizeDlModelForInference(hv_DLModelHandle, hv_DLDeviceHandleOpenVINO,
                    "float32", new HTuple(), hv_OptimizeForInferenceParams, out hv_DLModelHandleOpenVINO,
                    out hv_ConversionReport);
                //
                //Evaluate the optimized model on the OpenVINO? device.
                hv_EvaluationResultOpenVINO.Dispose(); hv_EvalParams.Dispose();
                evaluate_dl_model(hv_DLDataset, hv_DLModelHandleOpenVINO, "split", "test",
                    hv_GenParamEval, out hv_EvaluationResultOpenVINO, out hv_EvalParams);
                //
                //Benchmark the optimized model on the OpenVINO? device.
                hv_TimePerBatchOpenVINO.Dispose();
                bench_dl_model(hv_DLModelHandleOpenVINO, hv_DLDataset, out hv_TimePerBatchOpenVINO);
                //
                //Add the results to the ResultCollector.
                collect_results(hv_ResultCollector, hv_DLModelHandleOpenVINO, hv_TimePerBatchOpenVINO,
                    hv_EvaluationResultOpenVINO);
                if ((int)(hv_ShowExampleScreens) != 0)
                {
                    dev_display_example_continue_message(hv_ExampleInternals);
                    // stop(...); only in hdevelop
                }
            }
            //
            //
            //Now, optimize the retrained model for 'float16' inference on the OpenVINO? device, if this precision
            //is available for the selected device.
            hv_IndexFP16.Dispose();
            HOperatorSet.TupleFindFirst(hv_CastPrecisions, "float16", out hv_IndexFP16);
            if ((int)(new HTuple(hv_IndexFP16.TupleGreaterEqual(0))) != 0)
            {
                dev_display_example_show_current_stage(hv_ExampleInternals, hv_OpenVINODeviceType,
                    "float16");
                //
                //To convert the model to 'float16' precision, no samples have to be provided to
                //optimize_dl_model_for_inference.
                //No additional conversion parameters are required, so use the default parameters.
                hv_OptimizeForInferenceParams.Dispose();
                HOperatorSet.GetDlDeviceParam(hv_DLDeviceHandleOpenVINO, "optimize_for_inference_params",
                    out hv_OptimizeForInferenceParams);
                hv_DLModelHandleOpenVINO.Dispose(); hv_ConversionReport.Dispose();
                HOperatorSet.OptimizeDlModelForInference(hv_DLModelHandle, hv_DLDeviceHandleOpenVINO,
                    "float16", new HTuple(), hv_OptimizeForInferenceParams, out hv_DLModelHandleOpenVINO,
                    out hv_ConversionReport);
                //
                //Evaluate the optimized model on the OpenVINO? device.
                hv_EvaluationResultOpenVINO.Dispose(); hv_EvalParams.Dispose();
                evaluate_dl_model(hv_DLDataset, hv_DLModelHandleOpenVINO, "split", "test",
                    hv_GenParamEval, out hv_EvaluationResultOpenVINO, out hv_EvalParams);
                //
                //Benchmark the optimized model on the OpenVINO? device.
                hv_TimePerBatchOpenVINO.Dispose();
                bench_dl_model(hv_DLModelHandleOpenVINO, hv_DLDataset, out hv_TimePerBatchOpenVINO);
                //
                //Add the results to the ResultCollector.
                collect_results(hv_ResultCollector, hv_DLModelHandleOpenVINO, hv_TimePerBatchOpenVINO,
                    hv_EvaluationResultOpenVINO);
                if ((int)(hv_ShowExampleScreens) != 0)
                {
                    dev_display_example_continue_message(hv_ExampleInternals);
                    // stop(...); only in hdevelop
                }
            }
            //
            //
            //Now, optimize the retrained model for 'bfloat16' inference on the OpenVINO? device, if this precision
            //is available for the selected device.
            hv_IndexBFP16.Dispose();
            HOperatorSet.TupleFindFirst(hv_CastPrecisions, "bfloat16", out hv_IndexBFP16);
            if ((int)(new HTuple(hv_IndexBFP16.TupleGreaterEqual(0))) != 0)
            {
                dev_display_example_show_current_stage(hv_ExampleInternals, hv_OpenVINODeviceType,
                    "bfloat16");
                //
                //To convert the model to 'bfloat16' precision, no samples have to be provided to
                //optimize_dl_model_for_inference.
                //No additional conversion parameters are required, so use the default parameters.
                hv_OptimizeForInferenceParams.Dispose();
                HOperatorSet.GetDlDeviceParam(hv_DLDeviceHandleOpenVINO, "optimize_for_inference_params",
                    out hv_OptimizeForInferenceParams);
                hv_DLModelHandleOpenVINO.Dispose(); hv_ConversionReport.Dispose();
                HOperatorSet.OptimizeDlModelForInference(hv_DLModelHandle, hv_DLDeviceHandleOpenVINO,
                    "bfloat16", new HTuple(), hv_OptimizeForInferenceParams, out hv_DLModelHandleOpenVINO,
                    out hv_ConversionReport);
                //
                //Evaluate the optimized model on the OpenVINO? device.
                hv_EvaluationResultOpenVINO.Dispose(); hv_EvalParams.Dispose();
                evaluate_dl_model(hv_DLDataset, hv_DLModelHandleOpenVINO, "split", "test",
                    hv_GenParamEval, out hv_EvaluationResultOpenVINO, out hv_EvalParams);
                //
                //Benchmark the optimized model on the OpenVINO? device.
                hv_TimePerBatchOpenVINO.Dispose();
                bench_dl_model(hv_DLModelHandleOpenVINO, hv_DLDataset, out hv_TimePerBatchOpenVINO);
                //
                //Add the results to the ResultCollector.
                collect_results(hv_ResultCollector, hv_DLModelHandleOpenVINO, hv_TimePerBatchOpenVINO,
                    hv_EvaluationResultOpenVINO);
                if ((int)(hv_ShowExampleScreens) != 0)
                {
                    dev_display_example_continue_message(hv_ExampleInternals);
                    // stop(...); only in hdevelop
                }
            }
            //
            //******************************
            //**   Display the results   ***
            //******************************
            //
            dev_display_example_show_results(hv_ExampleInternals, hv_ResultCollector);
            // stop(...); only in hdevelop
            //
            if ((int)(hv_ShowExampleScreens) != 0)
            {
                //Close example windows.
                dev_close_example_windows(hv_ExampleInternals);
            }
        }
        catch (HalconException HDevExpDefaultException)
        {

            hv_ShowExampleScreens.Dispose();
            hv_UsePretrainedModel.Dispose();
            hv_DLDeviceHandlesOpenVINO.Dispose();
            hv_DLDeviceHandleCpu.Dispose();
            hv_ExampleInternals.Dispose();
            hv_OpenVINODeviceType.Dispose();
            hv_DLDeviceHandleOpenVINO.Dispose();
            hv_I.Dispose();
            hv_DeviceType.Dispose();
            hv_ExampleDir.Dispose();
            hv_DLExampleDir.Dispose();
            hv_ExampleDataDir.Dispose();
            hv_DataDirectory.Dispose();
            hv_DLDatasetFileName.Dispose();
            hv_RetrainedModelFileName.Dispose();
            hv_ClassificationMeasures.Dispose();
            hv_BatchSize.Dispose();
            hv_DLModelHandle.Dispose();
            hv_DLDataset.Dispose();
            hv_DLSampleDir.Dispose();
            hv_FileExists.Dispose();
            hv_ResultCollector.Dispose();
            hv_GenParamEval.Dispose();
            hv_EvaluationResultBaseLine.Dispose();
            hv_EvalParams.Dispose();
            hv_TimePerBatchBaseLine.Dispose();
            hv_CastPrecisions.Dispose();
            hv_IndexFP32.Dispose();
            hv_OptimizeForInferenceParams.Dispose();
            hv_DLModelHandleOpenVINO.Dispose();
            hv_ConversionReport.Dispose();
            hv_EvaluationResultOpenVINO.Dispose();
            hv_TimePerBatchOpenVINO.Dispose();
            hv_IndexFP16.Dispose();
            hv_IndexBFP16.Dispose();

            throw HDevExpDefaultException;
        }

        hv_ShowExampleScreens.Dispose();
        hv_UsePretrainedModel.Dispose();
        hv_DLDeviceHandlesOpenVINO.Dispose();
        hv_DLDeviceHandleCpu.Dispose();
        hv_ExampleInternals.Dispose();
        hv_OpenVINODeviceType.Dispose();
        hv_DLDeviceHandleOpenVINO.Dispose();
        hv_I.Dispose();
        hv_DeviceType.Dispose();
        hv_ExampleDir.Dispose();
        hv_DLExampleDir.Dispose();
        hv_ExampleDataDir.Dispose();
        hv_DataDirectory.Dispose();
        hv_DLDatasetFileName.Dispose();
        hv_RetrainedModelFileName.Dispose();
        hv_ClassificationMeasures.Dispose();
        hv_BatchSize.Dispose();
        hv_DLModelHandle.Dispose();
        hv_DLDataset.Dispose();
        hv_DLSampleDir.Dispose();
        hv_FileExists.Dispose();
        hv_ResultCollector.Dispose();
        hv_GenParamEval.Dispose();
        hv_EvaluationResultBaseLine.Dispose();
        hv_EvalParams.Dispose();
        hv_TimePerBatchBaseLine.Dispose();
        hv_CastPrecisions.Dispose();
        hv_IndexFP32.Dispose();
        hv_OptimizeForInferenceParams.Dispose();
        hv_DLModelHandleOpenVINO.Dispose();
        hv_ConversionReport.Dispose();
        hv_EvaluationResultOpenVINO.Dispose();
        hv_TimePerBatchOpenVINO.Dispose();
        hv_IndexFP16.Dispose();
        hv_IndexBFP16.Dispose();

    }

#endif


}
#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
public class HDevelopExportApp
{
    static void Main(string[] args)
    {
        new HDevelopExport();
    }
}
#endif

